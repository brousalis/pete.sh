{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/config.ts"],"sourcesContent":["/**\n * Configuration utility for environment variables\n * Validates and provides typed access to environment variables\n */\n\nimport { z } from 'zod'\n\n// Schema for environment variables\nconst envSchema = z.object({\n  // HUE Bridge\n  HUE_BRIDGE_IP: z.string().ip().optional(),\n  HUE_BRIDGE_USERNAME: z.string().optional(),\n  HUE_CLIENT_KEY: z.string().optional(), // Required for entertainment streaming\n\n  // Google\n  GOOGLE_CLIENT_ID: z.string().optional(),\n  GOOGLE_CLIENT_SECRET: z.string().optional(),\n  GOOGLE_API_KEY: z.string().optional(),\n  GOOGLE_CALENDAR_ID: z.string().optional(),\n\n  // Weather\n  WEATHER_LATITUDE: z\n    .string()\n    .regex(/^-?\\d+\\.?\\d*$/)\n    .optional(),\n  WEATHER_LONGITUDE: z\n    .string()\n    .regex(/^-?\\d+\\.?\\d*$/)\n    .optional(),\n\n  // CTA\n  CTA_API_KEY: z.string().optional(),\n  CTA_TRAIN_API_KEY: z.string().optional(),\n\n  // Spotify\n  NEXT_SPOTIFY_CLIENT_ID: z.string().optional(),\n  NEXT_SPOTIFY_CLIENT_SECRET: z.string().optional(),\n\n  // Desktop (local Windows features)\n  DESKTOP_ENABLED: z.string().optional(),\n})\n\n// Parse and validate environment variables\nconst parseEnv = () => {\n  const parsed = envSchema.safeParse(process.env)\n\n  if (!parsed.success) {\n    console.warn(\n      'Environment variable validation warnings:',\n      parsed.error.format()\n    )\n  }\n\n  return parsed.success ? parsed.data : {}\n}\n\nconst env = parseEnv()\n\n/**\n * Configuration object with typed environment variables\n */\nexport const config = {\n  hue: {\n    bridgeIp: env.HUE_BRIDGE_IP,\n    username: env.HUE_BRIDGE_USERNAME,\n    clientKey: env.HUE_CLIENT_KEY, // For entertainment streaming\n    isConfigured: Boolean(env.HUE_BRIDGE_IP && env.HUE_BRIDGE_USERNAME),\n    isEntertainmentConfigured: Boolean(\n      env.HUE_BRIDGE_IP && env.HUE_BRIDGE_USERNAME && env.HUE_CLIENT_KEY\n    ),\n  },\n  google: {\n    clientId: env.GOOGLE_CLIENT_ID,\n    clientSecret: env.GOOGLE_CLIENT_SECRET,\n    apiKey: env.GOOGLE_API_KEY,\n    calendarId: env.GOOGLE_CALENDAR_ID || 'primary',\n    isConfigured: Boolean(\n      env.GOOGLE_CLIENT_ID && env.GOOGLE_CLIENT_SECRET && env.GOOGLE_API_KEY\n    ),\n  },\n  weather: {\n    latitude: env.WEATHER_LATITUDE ? parseFloat(env.WEATHER_LATITUDE) : 41.8781, // Chicago default\n    longitude: env.WEATHER_LONGITUDE\n      ? parseFloat(env.WEATHER_LONGITUDE)\n      : -87.6298, // Chicago default\n  },\n  cta: {\n    apiKey: env.CTA_API_KEY,\n    trainApiKey: env.CTA_TRAIN_API_KEY,\n    isConfigured: Boolean(env.CTA_API_KEY),\n    isTrainConfigured: Boolean(env.CTA_TRAIN_API_KEY),\n  },\n  spotify: {\n    clientId: env.NEXT_SPOTIFY_CLIENT_ID,\n    clientSecret: env.NEXT_SPOTIFY_CLIENT_SECRET,\n    redirectUri: 'http://127.0.0.1:3000/spotify/callback',\n    isConfigured: Boolean(\n      env.NEXT_SPOTIFY_CLIENT_ID && env.NEXT_SPOTIFY_CLIENT_SECRET\n    ),\n    scopes: [\n      'user-read-playback-state',\n      'user-modify-playback-state',\n      'user-read-currently-playing',\n      'user-read-recently-played',\n      'user-library-read',\n      'playlist-read-private',\n      'playlist-read-collaborative',\n      'streaming',\n      'user-read-email',\n      'user-read-private',\n    ],\n  },\n  desktop: {\n    enabled: env.DESKTOP_ENABLED === 'true',\n  },\n} as const\n\n/**\n * Check if running in development mode\n */\nexport const isDev = process.env.NODE_ENV === 'development'\n\n/**\n * Check if running on localhost\n */\nexport const isLocalhost =\n  typeof window !== 'undefined' &&\n  (window.location.hostname === 'localhost' ||\n    window.location.hostname === '127.0.0.1' ||\n    window.location.hostname.startsWith('192.168.') ||\n    window.location.hostname.startsWith('10.'))\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGC,GAED;;AAEA,mCAAmC;AACnC,MAAM,YAAY,yKAAC,CAAC,MAAM,CAAC;IACzB,aAAa;IACb,eAAe,yKAAC,CAAC,MAAM,GAAG,EAAE,GAAG,QAAQ;IACvC,qBAAqB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACxC,gBAAgB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAEnC,SAAS;IACT,kBAAkB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACrC,sBAAsB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACzC,gBAAgB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,oBAAoB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAEvC,UAAU;IACV,kBAAkB,yKAAC,CAChB,MAAM,GACN,KAAK,CAAC,iBACN,QAAQ;IACX,mBAAmB,yKAAC,CACjB,MAAM,GACN,KAAK,CAAC,iBACN,QAAQ;IAEX,MAAM;IACN,aAAa,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,mBAAmB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAEtC,UAAU;IACV,wBAAwB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAC3C,4BAA4B,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAE/C,mCAAmC;IACnC,iBAAiB,yKAAC,CAAC,MAAM,GAAG,QAAQ;AACtC;AAEA,2CAA2C;AAC3C,MAAM,WAAW;IACf,MAAM,SAAS,UAAU,SAAS,CAAC,QAAQ,GAAG;IAE9C,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,QAAQ,IAAI,CACV,6CACA,OAAO,KAAK,CAAC,MAAM;IAEvB;IAEA,OAAO,OAAO,OAAO,GAAG,OAAO,IAAI,GAAG,CAAC;AACzC;AAEA,MAAM,MAAM;AAKL,MAAM,SAAS;IACpB,KAAK;QACH,UAAU,IAAI,aAAa;QAC3B,UAAU,IAAI,mBAAmB;QACjC,WAAW,IAAI,cAAc;QAC7B,cAAc,QAAQ,IAAI,aAAa,IAAI,IAAI,mBAAmB;QAClE,2BAA2B,QACzB,IAAI,aAAa,IAAI,IAAI,mBAAmB,IAAI,IAAI,cAAc;IAEtE;IACA,QAAQ;QACN,UAAU,IAAI,gBAAgB;QAC9B,cAAc,IAAI,oBAAoB;QACtC,QAAQ,IAAI,cAAc;QAC1B,YAAY,IAAI,kBAAkB,IAAI;QACtC,cAAc,QACZ,IAAI,gBAAgB,IAAI,IAAI,oBAAoB,IAAI,IAAI,cAAc;IAE1E;IACA,SAAS;QACP,UAAU,IAAI,gBAAgB,GAAG,WAAW,IAAI,gBAAgB,IAAI;QACpE,WAAW,IAAI,iBAAiB,GAC5B,WAAW,IAAI,iBAAiB,IAChC,CAAC;IACP;IACA,KAAK;QACH,QAAQ,IAAI,WAAW;QACvB,aAAa,IAAI,iBAAiB;QAClC,cAAc,QAAQ,IAAI,WAAW;QACrC,mBAAmB,QAAQ,IAAI,iBAAiB;IAClD;IACA,SAAS;QACP,UAAU,IAAI,sBAAsB;QACpC,cAAc,IAAI,0BAA0B;QAC5C,aAAa;QACb,cAAc,QACZ,IAAI,sBAAsB,IAAI,IAAI,0BAA0B;QAE9D,QAAQ;YACN;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;IACH;IACA,SAAS;QACP,SAAS,IAAI,eAAe,KAAK;IACnC;AACF;AAKO,MAAM,QAAQ,oDAAyB;AAKvC,MAAM,cACX,kDAAkB,eAClB,CAAC,OAAO,QAAQ,CAAC,QAAQ,KAAK,eAC5B,OAAO,QAAQ,CAAC,QAAQ,KAAK,eAC7B,OAAO,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,eACpC,OAAO,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/token-storage.ts"],"sourcesContent":["/**\n * Server-side token storage for OAuth tokens\n *\n * Stores tokens in a JSON file on disk instead of cookies.\n * This solves the cross-origin cookie problem when pete.sh makes\n * requests to localhost:3000 - cookies set on localhost aren't\n * sent with cross-origin fetch requests.\n *\n * The local server can read/write this file regardless of which\n * domain initiated the request.\n */\n\nimport fs from 'fs'\nimport path from 'path'\n\ninterface StoredTokens {\n  google_calendar?: {\n    access_token: string\n    refresh_token?: string\n    expiry_date?: number\n    updated_at: string\n  }\n  spotify?: {\n    access_token: string\n    refresh_token?: string\n    expiry_date?: number\n    updated_at: string\n  }\n}\n\n// Store tokens in the project root (gitignored)\nconst TOKEN_FILE = path.join(process.cwd(), '.tokens.json')\n\n/**\n * Read all tokens from storage\n */\nfunction readTokens(): StoredTokens {\n  try {\n    if (fs.existsSync(TOKEN_FILE)) {\n      const data = fs.readFileSync(TOKEN_FILE, 'utf-8')\n      return JSON.parse(data)\n    }\n  } catch (error) {\n    console.error('[TokenStorage] Error reading tokens:', error)\n  }\n  return {}\n}\n\n/**\n * Write tokens to storage\n * Uses fsync to ensure data is flushed to disk (prevents race conditions)\n */\nfunction writeTokens(tokens: StoredTokens): void {\n  try {\n    const data = JSON.stringify(tokens, null, 2)\n    // Open, write, fsync, close - ensures data is on disk before returning\n    const fd = fs.openSync(TOKEN_FILE, 'w')\n    fs.writeSync(fd, data, 0, 'utf-8')\n    fs.fsyncSync(fd)\n    fs.closeSync(fd)\n    console.log('[TokenStorage] Tokens written and synced to disk')\n  } catch (error) {\n    console.error('[TokenStorage] Error writing tokens:', error)\n  }\n}\n\n// ============================================\n// Google Calendar Tokens\n// ============================================\n\nexport function getGoogleCalendarTokens(): {\n  accessToken: string | null\n  refreshToken: string | null\n  expiryDate: number | null\n} {\n  const tokens = readTokens()\n  const calendarTokens = tokens.google_calendar\n\n  if (!calendarTokens) {\n    return { accessToken: null, refreshToken: null, expiryDate: null }\n  }\n\n  // Check if access token is expired\n  if (calendarTokens.expiry_date && Date.now() > calendarTokens.expiry_date) {\n    console.log('[TokenStorage] Google Calendar access token expired')\n    return {\n      accessToken: null,\n      refreshToken: calendarTokens.refresh_token || null,\n      expiryDate: null\n    }\n  }\n\n  return {\n    accessToken: calendarTokens.access_token || null,\n    refreshToken: calendarTokens.refresh_token || null,\n    expiryDate: calendarTokens.expiry_date || null,\n  }\n}\n\nexport function setGoogleCalendarTokens(tokens: {\n  access_token: string\n  refresh_token?: string | null\n  expiry_date?: number | null\n}): void {\n  const allTokens = readTokens()\n\n  allTokens.google_calendar = {\n    access_token: tokens.access_token,\n    refresh_token: tokens.refresh_token || allTokens.google_calendar?.refresh_token || undefined,\n    expiry_date: tokens.expiry_date || undefined,\n    updated_at: new Date().toISOString(),\n  }\n\n  writeTokens(allTokens)\n  console.log('[TokenStorage] Google Calendar tokens saved')\n}\n\nexport function clearGoogleCalendarTokens(): void {\n  const tokens = readTokens()\n  delete tokens.google_calendar\n  writeTokens(tokens)\n  console.log('[TokenStorage] Google Calendar tokens cleared')\n}\n\n// ============================================\n// Spotify Tokens\n// ============================================\n\nexport function getSpotifyTokens(): {\n  accessToken: string | null\n  refreshToken: string | null\n  expiryDate: number | null\n} {\n  const tokens = readTokens()\n  const spotifyTokens = tokens.spotify\n\n  if (!spotifyTokens) {\n    return { accessToken: null, refreshToken: null, expiryDate: null }\n  }\n\n  // Check if access token is expired\n  if (spotifyTokens.expiry_date && Date.now() > spotifyTokens.expiry_date) {\n    console.log('[TokenStorage] Spotify access token expired')\n    return {\n      accessToken: null,\n      refreshToken: spotifyTokens.refresh_token || null,\n      expiryDate: null\n    }\n  }\n\n  return {\n    accessToken: spotifyTokens.access_token || null,\n    refreshToken: spotifyTokens.refresh_token || null,\n    expiryDate: spotifyTokens.expiry_date || null,\n  }\n}\n\nexport function setSpotifyTokens(tokens: {\n  access_token: string\n  refresh_token?: string | null\n  expiry_date?: number | null\n}): void {\n  const allTokens = readTokens()\n\n  allTokens.spotify = {\n    access_token: tokens.access_token,\n    refresh_token: tokens.refresh_token || allTokens.spotify?.refresh_token || undefined,\n    expiry_date: tokens.expiry_date || undefined,\n    updated_at: new Date().toISOString(),\n  }\n\n  writeTokens(allTokens)\n  console.log('[TokenStorage] Spotify tokens saved')\n}\n\nexport function clearSpotifyTokens(): void {\n  const tokens = readTokens()\n  delete tokens.spotify\n  writeTokens(tokens)\n  console.log('[TokenStorage] Spotify tokens cleared')\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;;;;;;;;CAUC,GAED;AACA;;;AAiBA,gDAAgD;AAChD,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAE5C;;CAEC,GACD,SAAS;IACP,IAAI;QACF,IAAI,wGAAE,CAAC,UAAU,CAAC,aAAa;YAC7B,MAAM,OAAO,wGAAE,CAAC,YAAY,CAAC,YAAY;YACzC,OAAO,KAAK,KAAK,CAAC;QACpB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;IACxD;IACA,OAAO,CAAC;AACV;AAEA;;;CAGC,GACD,SAAS,YAAY,MAAoB;IACvC,IAAI;QACF,MAAM,OAAO,KAAK,SAAS,CAAC,QAAQ,MAAM;QAC1C,uEAAuE;QACvE,MAAM,KAAK,wGAAE,CAAC,QAAQ,CAAC,YAAY;QACnC,wGAAE,CAAC,SAAS,CAAC,IAAI,MAAM,GAAG;QAC1B,wGAAE,CAAC,SAAS,CAAC;QACb,wGAAE,CAAC,SAAS,CAAC;QACb,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;IACxD;AACF;AAMO,SAAS;IAKd,MAAM,SAAS;IACf,MAAM,iBAAiB,OAAO,eAAe;IAE7C,IAAI,CAAC,gBAAgB;QACnB,OAAO;YAAE,aAAa;YAAM,cAAc;YAAM,YAAY;QAAK;IACnE;IAEA,mCAAmC;IACnC,IAAI,eAAe,WAAW,IAAI,KAAK,GAAG,KAAK,eAAe,WAAW,EAAE;QACzE,QAAQ,GAAG,CAAC;QACZ,OAAO;YACL,aAAa;YACb,cAAc,eAAe,aAAa,IAAI;YAC9C,YAAY;QACd;IACF;IAEA,OAAO;QACL,aAAa,eAAe,YAAY,IAAI;QAC5C,cAAc,eAAe,aAAa,IAAI;QAC9C,YAAY,eAAe,WAAW,IAAI;IAC5C;AACF;AAEO,SAAS,wBAAwB,MAIvC;IACC,MAAM,YAAY;IAElB,UAAU,eAAe,GAAG;QAC1B,cAAc,OAAO,YAAY;QACjC,eAAe,OAAO,aAAa,IAAI,UAAU,eAAe,EAAE,iBAAiB;QACnF,aAAa,OAAO,WAAW,IAAI;QACnC,YAAY,IAAI,OAAO,WAAW;IACpC;IAEA,YAAY;IACZ,QAAQ,GAAG,CAAC;AACd;AAEO,SAAS;IACd,MAAM,SAAS;IACf,OAAO,OAAO,eAAe;IAC7B,YAAY;IACZ,QAAQ,GAAG,CAAC;AACd;AAMO,SAAS;IAKd,MAAM,SAAS;IACf,MAAM,gBAAgB,OAAO,OAAO;IAEpC,IAAI,CAAC,eAAe;QAClB,OAAO;YAAE,aAAa;YAAM,cAAc;YAAM,YAAY;QAAK;IACnE;IAEA,mCAAmC;IACnC,IAAI,cAAc,WAAW,IAAI,KAAK,GAAG,KAAK,cAAc,WAAW,EAAE;QACvE,QAAQ,GAAG,CAAC;QACZ,OAAO;YACL,aAAa;YACb,cAAc,cAAc,aAAa,IAAI;YAC7C,YAAY;QACd;IACF;IAEA,OAAO;QACL,aAAa,cAAc,YAAY,IAAI;QAC3C,cAAc,cAAc,aAAa,IAAI;QAC7C,YAAY,cAAc,WAAW,IAAI;IAC3C;AACF;AAEO,SAAS,iBAAiB,MAIhC;IACC,MAAM,YAAY;IAElB,UAAU,OAAO,GAAG;QAClB,cAAc,OAAO,YAAY;QACjC,eAAe,OAAO,aAAa,IAAI,UAAU,OAAO,EAAE,iBAAiB;QAC3E,aAAa,OAAO,WAAW,IAAI;QACnC,YAAY,IAAI,OAAO,WAAW;IACpC;IAEA,YAAY;IACZ,QAAQ,GAAG,CAAC;AACd;AAEO,SAAS;IACd,MAAM,SAAS;IACf,OAAO,OAAO,OAAO;IACrB,YAAY;IACZ,QAAQ,GAAG,CAAC;AACd"}},
    {"offset": {"line": 303, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/spotify.service.ts"],"sourcesContent":["/**\r\n * Spotify Service\r\n * Handles OAuth and communication with Spotify Web API\r\n */\r\n\r\nimport { config } from \"@/lib/config\"\r\nimport { getSpotifyTokens, setSpotifyTokens, clearSpotifyTokens } from \"./token-storage\"\r\nimport type {\r\n  SpotifyTokens,\r\n  SpotifyUser,\r\n  SpotifyPlaybackState,\r\n  SpotifyDevice,\r\n  SpotifyPlaylist,\r\n  SpotifyRecentTrack,\r\n  SpotifySearchResults,\r\n  SpotifyTrack,\r\n  SpotifyQueue,\r\n  SpotifyRepeatMode,\r\n  SpotifyAudioFeatures,\r\n  SpotifySavedTrack,\r\n  SpotifyRecommendationsParams,\r\n  SpotifyRecommendationsResponse,\r\n} from \"@/lib/types/spotify.types\"\r\n\r\nconst SPOTIFY_AUTH_URL = \"https://accounts.spotify.com/authorize\"\r\nconst SPOTIFY_TOKEN_URL = \"https://accounts.spotify.com/api/token\"\r\nconst SPOTIFY_API_URL = \"https://api.spotify.com/v1\"\r\n\r\nexport class SpotifyService {\r\n  private accessToken: string | null = null\r\n  private refreshToken: string | null = null\r\n\r\n  constructor() {}\r\n\r\n  isConfigured(): boolean {\r\n    return config.spotify.isConfigured\r\n  }\r\n\r\n  /**\r\n   * Generate the OAuth authorization URL\r\n   */\r\n  getAuthUrl(state?: string): string {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"Spotify not configured\")\r\n    }\r\n\r\n    const params = new URLSearchParams({\r\n      client_id: config.spotify.clientId!,\r\n      response_type: \"code\",\r\n      redirect_uri: config.spotify.redirectUri,\r\n      scope: config.spotify.scopes.join(\" \"),\r\n      show_dialog: \"false\",\r\n    })\r\n\r\n    if (state) {\r\n      params.set(\"state\", state)\r\n    }\r\n\r\n    return `${SPOTIFY_AUTH_URL}?${params.toString()}`\r\n  }\r\n\r\n  /**\r\n   * Exchange authorization code for tokens\r\n   */\r\n  async exchangeCode(code: string): Promise<SpotifyTokens> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"Spotify not configured\")\r\n    }\r\n\r\n    const body = new URLSearchParams({\r\n      grant_type: \"authorization_code\",\r\n      code,\r\n      redirect_uri: config.spotify.redirectUri,\r\n    })\r\n\r\n    const response = await fetch(SPOTIFY_TOKEN_URL, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n        Authorization: `Basic ${Buffer.from(\r\n          `${config.spotify.clientId}:${config.spotify.clientSecret}`\r\n        ).toString(\"base64\")}`,\r\n      },\r\n      body: body.toString(),\r\n    })\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json().catch(() => ({}))\r\n      throw new Error(error.error_description || \"Failed to exchange code for tokens\")\r\n    }\r\n\r\n    const tokens: SpotifyTokens = await response.json()\r\n    this.accessToken = tokens.access_token\r\n    this.refreshToken = tokens.refresh_token || null\r\n\r\n    return tokens\r\n  }\r\n\r\n  /**\r\n   * Refresh access token using refresh token\r\n   */\r\n  async refreshAccessToken(refreshToken: string): Promise<SpotifyTokens> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"Spotify not configured\")\r\n    }\r\n\r\n    const body = new URLSearchParams({\r\n      grant_type: \"refresh_token\",\r\n      refresh_token: refreshToken,\r\n    })\r\n\r\n    const response = await fetch(SPOTIFY_TOKEN_URL, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n        Authorization: `Basic ${Buffer.from(\r\n          `${config.spotify.clientId}:${config.spotify.clientSecret}`\r\n        ).toString(\"base64\")}`,\r\n      },\r\n      body: body.toString(),\r\n    })\r\n\r\n    if (!response.ok) {\r\n      const error = await response.json().catch(() => ({}))\r\n      throw new Error(error.error_description || \"Failed to refresh token\")\r\n    }\r\n\r\n    const tokens: SpotifyTokens = await response.json()\r\n    this.accessToken = tokens.access_token\r\n    // Spotify doesn't always return a new refresh token\r\n    if (tokens.refresh_token) {\r\n      this.refreshToken = tokens.refresh_token\r\n    }\r\n\r\n    return {\r\n      ...tokens,\r\n      refresh_token: tokens.refresh_token || refreshToken,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set credentials for API requests\r\n   */\r\n  setCredentials(accessToken: string, refreshToken?: string): void {\r\n    this.accessToken = accessToken\r\n    if (refreshToken) {\r\n      this.refreshToken = refreshToken\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make authenticated API request\r\n   */\r\n  private async apiRequest<T>(\r\n    endpoint: string,\r\n    options: RequestInit = {}\r\n  ): Promise<T> {\r\n    if (!this.accessToken) {\r\n      throw new Error(\"No access token available\")\r\n    }\r\n\r\n    const response = await fetch(`${SPOTIFY_API_URL}${endpoint}`, {\r\n      ...options,\r\n      headers: {\r\n        ...options.headers,\r\n        Authorization: `Bearer ${this.accessToken}`,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n    })\r\n\r\n    // Handle 204 No Content and 202 Accepted (successful but no body)\r\n    if (response.status === 204 || response.status === 202) {\r\n      return {} as T\r\n    }\r\n\r\n    // Get response text first to safely handle empty or non-JSON responses\r\n    const text = await response.text()\r\n\r\n    if (!response.ok) {\r\n      if (response.status === 401) {\r\n        throw new Error(\"TOKEN_EXPIRED\")\r\n      }\r\n      // Try to parse error as JSON\r\n      try {\r\n        const error = text ? JSON.parse(text) : {}\r\n        throw new Error(error.error?.message || `API request failed: ${response.status}`)\r\n      } catch {\r\n        throw new Error(`API request failed: ${response.status}`)\r\n      }\r\n    }\r\n\r\n    // Handle empty successful response\r\n    if (!text) {\r\n      return {} as T\r\n    }\r\n\r\n    // Parse JSON response\r\n    try {\r\n      return JSON.parse(text) as T\r\n    } catch {\r\n      // If parsing fails but response was ok, return empty object\r\n      return {} as T\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // User Endpoints\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get current user's profile\r\n   */\r\n  async getCurrentUser(): Promise<SpotifyUser> {\r\n    return this.apiRequest<SpotifyUser>(\"/me\")\r\n  }\r\n\r\n  // ==========================================\r\n  // Player Endpoints\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get current playback state\r\n   */\r\n  async getPlaybackState(): Promise<SpotifyPlaybackState | null> {\r\n    try {\r\n      return await this.apiRequest<SpotifyPlaybackState>(\"/me/player\")\r\n    } catch (error) {\r\n      // 204 means no active device\r\n      if (error instanceof Error && error.message.includes(\"API request failed\")) {\r\n        return null\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get available devices\r\n   */\r\n  async getDevices(): Promise<SpotifyDevice[]> {\r\n    const response = await this.apiRequest<{ devices: SpotifyDevice[] }>(\"/me/player/devices\")\r\n    return response.devices || []\r\n  }\r\n\r\n  /**\r\n   * Get current queue\r\n   */\r\n  async getQueue(): Promise<SpotifyQueue> {\r\n    return this.apiRequest<SpotifyQueue>(\"/me/player/queue\")\r\n  }\r\n\r\n  /**\r\n   * Start/resume playback\r\n   */\r\n  async play(options?: {\r\n    deviceId?: string\r\n    contextUri?: string\r\n    uris?: string[]\r\n    offset?: { position: number } | { uri: string }\r\n    positionMs?: number\r\n  }): Promise<void> {\r\n    const params = options?.deviceId ? `?device_id=${options.deviceId}` : \"\"\r\n    const body: Record<string, unknown> = {}\r\n\r\n    if (options?.contextUri) body.context_uri = options.contextUri\r\n    if (options?.uris) body.uris = options.uris\r\n    if (options?.offset) body.offset = options.offset\r\n    if (options?.positionMs !== undefined) body.position_ms = options.positionMs\r\n\r\n    await this.apiRequest(`/me/player/play${params}`, {\r\n      method: \"PUT\",\r\n      body: Object.keys(body).length > 0 ? JSON.stringify(body) : undefined,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Pause playback\r\n   */\r\n  async pause(deviceId?: string): Promise<void> {\r\n    const params = deviceId ? `?device_id=${deviceId}` : \"\"\r\n    await this.apiRequest(`/me/player/pause${params}`, { method: \"PUT\" })\r\n  }\r\n\r\n  /**\r\n   * Skip to next track\r\n   */\r\n  async skipToNext(deviceId?: string): Promise<void> {\r\n    const params = deviceId ? `?device_id=${deviceId}` : \"\"\r\n    await this.apiRequest(`/me/player/next${params}`, { method: \"POST\" })\r\n  }\r\n\r\n  /**\r\n   * Skip to previous track\r\n   */\r\n  async skipToPrevious(deviceId?: string): Promise<void> {\r\n    const params = deviceId ? `?device_id=${deviceId}` : \"\"\r\n    await this.apiRequest(`/me/player/previous${params}`, { method: \"POST\" })\r\n  }\r\n\r\n  /**\r\n   * Seek to position in current track\r\n   */\r\n  async seek(positionMs: number, deviceId?: string): Promise<void> {\r\n    const params = new URLSearchParams({ position_ms: positionMs.toString() })\r\n    if (deviceId) params.set(\"device_id\", deviceId)\r\n    await this.apiRequest(`/me/player/seek?${params.toString()}`, { method: \"PUT\" })\r\n  }\r\n\r\n  /**\r\n   * Set volume\r\n   */\r\n  async setVolume(volumePercent: number, deviceId?: string): Promise<void> {\r\n    const params = new URLSearchParams({\r\n      volume_percent: Math.round(volumePercent).toString(),\r\n    })\r\n    if (deviceId) params.set(\"device_id\", deviceId)\r\n    await this.apiRequest(`/me/player/volume?${params.toString()}`, { method: \"PUT\" })\r\n  }\r\n\r\n  /**\r\n   * Set repeat mode\r\n   */\r\n  async setRepeat(state: SpotifyRepeatMode, deviceId?: string): Promise<void> {\r\n    const params = new URLSearchParams({ state })\r\n    if (deviceId) params.set(\"device_id\", deviceId)\r\n    await this.apiRequest(`/me/player/repeat?${params.toString()}`, { method: \"PUT\" })\r\n  }\r\n\r\n  /**\r\n   * Toggle shuffle\r\n   */\r\n  async setShuffle(state: boolean, deviceId?: string): Promise<void> {\r\n    const params = new URLSearchParams({ state: state.toString() })\r\n    if (deviceId) params.set(\"device_id\", deviceId)\r\n    await this.apiRequest(`/me/player/shuffle?${params.toString()}`, { method: \"PUT\" })\r\n  }\r\n\r\n  /**\r\n   * Add item to queue\r\n   */\r\n  async addToQueue(uri: string, deviceId?: string): Promise<void> {\r\n    const params = new URLSearchParams({ uri })\r\n    if (deviceId) params.set(\"device_id\", deviceId)\r\n    await this.apiRequest(`/me/player/queue?${params.toString()}`, { method: \"POST\" })\r\n  }\r\n\r\n  /**\r\n   * Transfer playback to a device\r\n   */\r\n  async transferPlayback(deviceId: string, play?: boolean): Promise<void> {\r\n    await this.apiRequest(\"/me/player\", {\r\n      method: \"PUT\",\r\n      body: JSON.stringify({\r\n        device_ids: [deviceId],\r\n        play: play ?? false,\r\n      }),\r\n    })\r\n  }\r\n\r\n  // ==========================================\r\n  // Library Endpoints\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get user's playlists\r\n   */\r\n  async getPlaylists(limit = 20, offset = 0): Promise<{ items: SpotifyPlaylist[]; total: number }> {\r\n    const params = new URLSearchParams({\r\n      limit: limit.toString(),\r\n      offset: offset.toString(),\r\n    })\r\n    return this.apiRequest(`/me/playlists?${params.toString()}`)\r\n  }\r\n\r\n  /**\r\n   * Get recently played tracks\r\n   */\r\n  async getRecentlyPlayed(limit = 20): Promise<{ items: SpotifyRecentTrack[] }> {\r\n    const params = new URLSearchParams({ limit: limit.toString() })\r\n    return this.apiRequest(`/me/player/recently-played?${params.toString()}`)\r\n  }\r\n\r\n  /**\r\n   * Get a playlist's tracks\r\n   */\r\n  async getPlaylistTracks(\r\n    playlistId: string,\r\n    limit = 50,\r\n    offset = 0\r\n  ): Promise<{ items: { track: SpotifyTrack }[]; total: number }> {\r\n    const params = new URLSearchParams({\r\n      limit: limit.toString(),\r\n      offset: offset.toString(),\r\n    })\r\n    return this.apiRequest(`/playlists/${playlistId}/tracks?${params.toString()}`)\r\n  }\r\n\r\n  // ==========================================\r\n  // Search Endpoint\r\n  // ==========================================\r\n\r\n  /**\r\n   * Search for tracks, artists, albums, or playlists\r\n   */\r\n  async search(\r\n    query: string,\r\n    types: (\"track\" | \"artist\" | \"album\" | \"playlist\")[] = [\"track\"],\r\n    limit = 20\r\n  ): Promise<SpotifySearchResults> {\r\n    const params = new URLSearchParams({\r\n      q: query,\r\n      type: types.join(\",\"),\r\n      limit: limit.toString(),\r\n    })\r\n    return this.apiRequest(`/search?${params.toString()}`)\r\n  }\r\n\r\n  // ==========================================\r\n  // Audio Features Endpoints\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get audio features for a single track\r\n   */\r\n  async getAudioFeatures(trackId: string): Promise<SpotifyAudioFeatures> {\r\n    return this.apiRequest<SpotifyAudioFeatures>(`/audio-features/${trackId}`)\r\n  }\r\n\r\n  /**\r\n   * Get audio features for multiple tracks (max 100)\r\n   */\r\n  async getAudioFeaturesForTracks(trackIds: string[]): Promise<SpotifyAudioFeatures[]> {\r\n    if (trackIds.length === 0) return []\r\n    // API allows max 100 tracks per request\r\n    const ids = trackIds.slice(0, 100).join(\",\")\r\n    const response = await this.apiRequest<{ audio_features: (SpotifyAudioFeatures | null)[] }>(\r\n      `/audio-features?ids=${ids}`\r\n    )\r\n    // Filter out null values (tracks without audio features)\r\n    return response.audio_features.filter((f): f is SpotifyAudioFeatures => f !== null)\r\n  }\r\n\r\n  // ==========================================\r\n  // User Library Endpoints\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get user's saved tracks (library)\r\n   */\r\n  async getSavedTracks(\r\n    limit = 50,\r\n    offset = 0\r\n  ): Promise<{ items: SpotifySavedTrack[]; total: number; next: string | null }> {\r\n    const params = new URLSearchParams({\r\n      limit: Math.min(limit, 50).toString(),\r\n      offset: offset.toString(),\r\n    })\r\n    return this.apiRequest(`/me/tracks?${params.toString()}`)\r\n  }\r\n\r\n  /**\r\n   * Get all saved tracks with pagination\r\n   * Warning: This can be slow for large libraries\r\n   */\r\n  async getAllSavedTracks(progressCallback?: (loaded: number, total: number) => void): Promise<SpotifySavedTrack[]> {\r\n    const allTracks: SpotifySavedTrack[] = []\r\n    let offset = 0\r\n    const limit = 50\r\n    let total = 0\r\n\r\n    do {\r\n      const response = await this.getSavedTracks(limit, offset)\r\n      allTracks.push(...response.items)\r\n      total = response.total\r\n      offset += limit\r\n      progressCallback?.(allTracks.length, total)\r\n    } while (offset < total)\r\n\r\n    return allTracks\r\n  }\r\n\r\n  // ==========================================\r\n  // Recommendations Endpoint\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get track recommendations based on seeds and audio features\r\n   */\r\n  async getRecommendations(params: SpotifyRecommendationsParams): Promise<SpotifyRecommendationsResponse> {\r\n    const queryParams = new URLSearchParams()\r\n\r\n    // Add seed parameters (max 5 total across all seed types)\r\n    if (params.seed_artists?.length) {\r\n      queryParams.set(\"seed_artists\", params.seed_artists.slice(0, 5).join(\",\"))\r\n    }\r\n    if (params.seed_tracks?.length) {\r\n      queryParams.set(\"seed_tracks\", params.seed_tracks.slice(0, 5).join(\",\"))\r\n    }\r\n    if (params.seed_genres?.length) {\r\n      queryParams.set(\"seed_genres\", params.seed_genres.slice(0, 5).join(\",\"))\r\n    }\r\n\r\n    // Limit\r\n    if (params.limit) {\r\n      queryParams.set(\"limit\", Math.min(params.limit, 100).toString())\r\n    }\r\n\r\n    // Tempo filters\r\n    if (params.target_tempo !== undefined) {\r\n      queryParams.set(\"target_tempo\", params.target_tempo.toString())\r\n    }\r\n    if (params.min_tempo !== undefined) {\r\n      queryParams.set(\"min_tempo\", params.min_tempo.toString())\r\n    }\r\n    if (params.max_tempo !== undefined) {\r\n      queryParams.set(\"max_tempo\", params.max_tempo.toString())\r\n    }\r\n\r\n    // Energy filters\r\n    if (params.target_energy !== undefined) {\r\n      queryParams.set(\"target_energy\", params.target_energy.toString())\r\n    }\r\n    if (params.min_energy !== undefined) {\r\n      queryParams.set(\"min_energy\", params.min_energy.toString())\r\n    }\r\n    if (params.max_energy !== undefined) {\r\n      queryParams.set(\"max_energy\", params.max_energy.toString())\r\n    }\r\n\r\n    // Danceability filters\r\n    if (params.target_danceability !== undefined) {\r\n      queryParams.set(\"target_danceability\", params.target_danceability.toString())\r\n    }\r\n    if (params.min_danceability !== undefined) {\r\n      queryParams.set(\"min_danceability\", params.min_danceability.toString())\r\n    }\r\n    if (params.max_danceability !== undefined) {\r\n      queryParams.set(\"max_danceability\", params.max_danceability.toString())\r\n    }\r\n\r\n    return this.apiRequest<SpotifyRecommendationsResponse>(`/recommendations?${queryParams.toString()}`)\r\n  }\r\n\r\n  // ==========================================\r\n  // Playlist Management Endpoints\r\n  // ==========================================\r\n\r\n  /**\r\n   * Create a new playlist\r\n   */\r\n  async createPlaylist(\r\n    userId: string,\r\n    name: string,\r\n    options?: { description?: string; public?: boolean }\r\n  ): Promise<SpotifyPlaylist> {\r\n    return this.apiRequest<SpotifyPlaylist>(`/users/${userId}/playlists`, {\r\n      method: \"POST\",\r\n      body: JSON.stringify({\r\n        name,\r\n        description: options?.description || \"\",\r\n        public: options?.public ?? false,\r\n      }),\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Add tracks to a playlist\r\n   */\r\n  async addTracksToPlaylist(\r\n    playlistId: string,\r\n    trackUris: string[],\r\n    position?: number\r\n  ): Promise<{ snapshot_id: string }> {\r\n    const body: { uris: string[]; position?: number } = {\r\n      uris: trackUris.slice(0, 100), // Max 100 tracks per request\r\n    }\r\n    if (position !== undefined) {\r\n      body.position = position\r\n    }\r\n    return this.apiRequest(`/playlists/${playlistId}/tracks`, {\r\n      method: \"POST\",\r\n      body: JSON.stringify(body),\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove tracks from a playlist\r\n   */\r\n  async removeTracksFromPlaylist(\r\n    playlistId: string,\r\n    trackUris: string[]\r\n  ): Promise<{ snapshot_id: string }> {\r\n    return this.apiRequest(`/playlists/${playlistId}/tracks`, {\r\n      method: \"DELETE\",\r\n      body: JSON.stringify({\r\n        tracks: trackUris.map((uri) => ({ uri })),\r\n      }),\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get a single playlist by ID\r\n   */\r\n  async getPlaylist(playlistId: string): Promise<SpotifyPlaylist> {\r\n    return this.apiRequest<SpotifyPlaylist>(`/playlists/${playlistId}`)\r\n  }\r\n\r\n  /**\r\n   * Get top tracks for an artist\r\n   */\r\n  async getArtistTopTracks(artistId: string, market = \"US\"): Promise<{ tracks: SpotifyTrack[] }> {\r\n    return this.apiRequest<{ tracks: SpotifyTrack[] }>(\r\n      `/artists/${artistId}/top-tracks?market=${market}`\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function to load Spotify tokens\r\n * First checks file-based storage (for cross-origin requests from pete.sh)\r\n * Falls back to cookies (for same-origin requests)\r\n */\r\nexport async function loadSpotifyTokensFromCookies(\r\n  spotifyService: SpotifyService,\r\n  cookieStore: { get: (name: string) => { value: string } | undefined }\r\n): Promise<{ accessToken: string | null; refreshToken: string | null; needsRefresh: boolean }> {\r\n  // First try file-based storage (works for cross-origin requests)\r\n  const fileTokens = getSpotifyTokens()\r\n  \r\n  // Fall back to cookies if file storage is empty\r\n  const cookieAccessToken = cookieStore.get(\"spotify_access_token\")?.value || null\r\n  const cookieRefreshToken = cookieStore.get(\"spotify_refresh_token\")?.value || null\r\n  const cookieExpiresAt = cookieStore.get(\"spotify_expires_at\")?.value\r\n  \r\n  // Use file tokens if available, otherwise use cookies\r\n  const accessToken = fileTokens.accessToken || cookieAccessToken\r\n  const refreshToken = fileTokens.refreshToken || cookieRefreshToken\r\n  const expiresAt = fileTokens.expiryDate || (cookieExpiresAt ? parseInt(cookieExpiresAt, 10) : null)\r\n\r\n  console.log(\"[SpotifyService] Loading tokens:\", {\r\n    fromFile: { hasAccessToken: !!fileTokens.accessToken, hasRefreshToken: !!fileTokens.refreshToken },\r\n    fromCookies: { hasAccessToken: !!cookieAccessToken, hasRefreshToken: !!cookieRefreshToken },\r\n    using: { hasAccessToken: !!accessToken, hasRefreshToken: !!refreshToken },\r\n  })\r\n\r\n  // Check if token is expired or about to expire (within 5 minutes)\r\n  const needsRefresh = expiresAt\r\n    ? expiresAt < Date.now() + 5 * 60 * 1000\r\n    : !accessToken && !!refreshToken\r\n\r\n  if (accessToken) {\r\n    spotifyService.setCredentials(accessToken, refreshToken || undefined)\r\n  }\r\n\r\n  return { accessToken, refreshToken, needsRefresh }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 834, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/spotify-auth.ts"],"sourcesContent":["/**\n * Shared Spotify authentication utilities\n * Handles token loading, refreshing, and cookie management\n */\n\nimport { cookies } from \"next/headers\"\nimport { SpotifyService } from \"@/lib/services/spotify.service\"\nimport { getSpotifyTokens, setSpotifyTokens, clearSpotifyTokens } from \"@/lib/services/token-storage\"\n\nconst COOKIE_OPTIONS = {\n  httpOnly: true,\n  secure: process.env.NODE_ENV === \"production\",\n  sameSite: \"lax\" as const,\n  path: \"/\",\n}\n\n/**\n * Load and refresh Spotify tokens as needed\n * First checks file-based storage (for cross-origin requests from pete.sh)\n * Falls back to cookies (for same-origin requests)\n * Returns the spotify service instance with credentials set\n */\nexport async function getAuthenticatedSpotifyService(): Promise<{\n  service: SpotifyService\n  authenticated: boolean\n}> {\n  const spotifyService = new SpotifyService()\n\n  if (!spotifyService.isConfigured()) {\n    return { service: spotifyService, authenticated: false }\n  }\n\n  // First try file-based storage (works for cross-origin requests)\n  const fileTokens = getSpotifyTokens()\n\n  // Fall back to cookies if file storage is empty\n  const cookieStore = await cookies()\n  const cookieAccessToken = cookieStore.get(\"spotify_access_token\")?.value\n  const cookieRefreshToken = cookieStore.get(\"spotify_refresh_token\")?.value\n  const cookieExpiresAt = cookieStore.get(\"spotify_expires_at\")?.value\n\n  // Use file tokens if available, otherwise use cookies\n  let accessToken = fileTokens.accessToken || cookieAccessToken || null\n  const refreshToken = fileTokens.refreshToken || cookieRefreshToken || null\n  const expiresAt = fileTokens.expiryDate || (cookieExpiresAt ? parseInt(cookieExpiresAt, 10) : null)\n\n  console.log(\"[Spotify Auth] Loading tokens:\", {\n    fromFile: { hasAccessToken: !!fileTokens.accessToken, hasRefreshToken: !!fileTokens.refreshToken },\n    fromCookies: { hasAccessToken: !!cookieAccessToken, hasRefreshToken: !!cookieRefreshToken },\n    using: { hasAccessToken: !!accessToken, hasRefreshToken: !!refreshToken },\n  })\n\n  // No tokens at all - not authenticated\n  if (!accessToken && !refreshToken) {\n    return { service: spotifyService, authenticated: false }\n  }\n\n  // Check if we need to refresh\n  // Refresh if: no access token, OR token expires within 5 minutes\n  const needsRefresh = !accessToken || (expiresAt && expiresAt < Date.now() + 5 * 60 * 1000)\n\n  if (needsRefresh && refreshToken) {\n    try {\n      console.log(\"[Spotify Auth] Refreshing access token...\")\n      const tokens = await spotifyService.refreshAccessToken(refreshToken)\n      const newExpiresAt = Date.now() + tokens.expires_in * 1000\n\n      // Save to file storage (for cross-origin requests)\n      setSpotifyTokens({\n        access_token: tokens.access_token,\n        refresh_token: tokens.refresh_token || refreshToken,\n        expiry_date: newExpiresAt,\n      })\n\n      // Also save to cookies (for same-origin as backup)\n      cookieStore.set(\"spotify_access_token\", tokens.access_token, {\n        ...COOKIE_OPTIONS,\n        maxAge: tokens.expires_in,\n      })\n\n      cookieStore.set(\"spotify_expires_at\", newExpiresAt.toString(), {\n        ...COOKIE_OPTIONS,\n        maxAge: 365 * 24 * 60 * 60,\n      })\n\n      if (tokens.refresh_token) {\n        cookieStore.set(\"spotify_refresh_token\", tokens.refresh_token, {\n          ...COOKIE_OPTIONS,\n          maxAge: 365 * 24 * 60 * 60,\n        })\n      }\n\n      spotifyService.setCredentials(tokens.access_token, tokens.refresh_token || refreshToken)\n      console.log(\"[Spotify Auth] Token refreshed successfully\")\n      return { service: spotifyService, authenticated: true }\n    } catch (error) {\n      console.error(\"[Spotify Auth] Token refresh failed:\", error)\n      // Clear all tokens on refresh failure\n      clearSpotifyTokens()\n      cookieStore.delete(\"spotify_access_token\")\n      cookieStore.delete(\"spotify_refresh_token\")\n      cookieStore.delete(\"spotify_expires_at\")\n      return { service: spotifyService, authenticated: false }\n    }\n  }\n\n  // We have a valid access token\n  if (accessToken) {\n    spotifyService.setCredentials(accessToken, refreshToken || undefined)\n    return { service: spotifyService, authenticated: true }\n  }\n\n  return { service: spotifyService, authenticated: false }\n}\n\n/**\n * Check if Spotify is configured\n */\nexport function isSpotifyConfigured(): boolean {\n  const spotifyService = new SpotifyService()\n  return spotifyService.isConfigured()\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 964, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/api/utils.ts"],"sourcesContent":["/**\n * API utility functions for Next.js API routes\n */\n\nimport { NextResponse } from \"next/server\"\nimport type { ApiResponse, ApiError } from \"@/lib/types/api.types\"\n\n/**\n * Create a successful API response\n */\nexport function successResponse<T>(data: T, status = 200): NextResponse<ApiResponse<T>> {\n  return NextResponse.json(\n    {\n      success: true,\n      data,\n    },\n    { status }\n  )\n}\n\n/**\n * Create an error API response\n */\nexport function errorResponse(\n  error: string | ApiError,\n  status = 500\n): NextResponse<ApiResponse> {\n  const errorObj = typeof error === \"string\" ? { code: \"UNKNOWN\", message: error } : error\n\n  const response: ApiResponse = {\n    success: false,\n    error: errorObj.message,\n  }\n  \n  if (errorObj.code) {\n    response.code = errorObj.code\n  }\n  \n  if (errorObj.details) {\n    response.details = errorObj.details\n  }\n\n  return NextResponse.json(response, { status })\n}\n\n/**\n * Handle API route errors\n */\nexport function handleApiError(error: unknown): NextResponse<ApiResponse> {\n  console.error(\"API Error:\", error)\n\n  if (error instanceof Error) {\n    return errorResponse(error.message, 500)\n  }\n\n  return errorResponse(\"An unexpected error occurred\", 500)\n}\n\n/**\n * Validate request method\n */\nexport function validateMethod(request: Request, allowedMethods: string[]): boolean {\n  return allowedMethods.includes(request.method)\n}\n\n/**\n * Get JSON body from request\n */\nexport async function getJsonBody<T = unknown>(request: Request): Promise<T> {\n  try {\n    return await request.json()\n  } catch {\n    throw new Error(\"Invalid JSON body\")\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;CAEC,GAED;;AAMO,SAAS,gBAAmB,IAAO,EAAE,SAAS,GAAG;IACtD,OAAO,gJAAY,CAAC,IAAI,CACtB;QACE,SAAS;QACT;IACF,GACA;QAAE;IAAO;AAEb;AAKO,SAAS,cACd,KAAwB,EACxB,SAAS,GAAG;IAEZ,MAAM,WAAW,OAAO,UAAU,WAAW;QAAE,MAAM;QAAW,SAAS;IAAM,IAAI;IAEnF,MAAM,WAAwB;QAC5B,SAAS;QACT,OAAO,SAAS,OAAO;IACzB;IAEA,IAAI,SAAS,IAAI,EAAE;QACjB,SAAS,IAAI,GAAG,SAAS,IAAI;IAC/B;IAEA,IAAI,SAAS,OAAO,EAAE;QACpB,SAAS,OAAO,GAAG,SAAS,OAAO;IACrC;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,UAAU;QAAE;IAAO;AAC9C;AAKO,SAAS,eAAe,KAAc;IAC3C,QAAQ,KAAK,CAAC,cAAc;IAE5B,IAAI,iBAAiB,OAAO;QAC1B,OAAO,cAAc,MAAM,OAAO,EAAE;IACtC;IAEA,OAAO,cAAc,gCAAgC;AACvD;AAKO,SAAS,eAAe,OAAgB,EAAE,cAAwB;IACvE,OAAO,eAAe,QAAQ,CAAC,QAAQ,MAAM;AAC/C;AAKO,eAAe,YAAyB,OAAgB;IAC7D,IAAI;QACF,OAAO,MAAM,QAAQ,IAAI;IAC3B,EAAE,OAAM;QACN,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 1028, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/supabase/client.ts"],"sourcesContent":["/**\r\n * Supabase Client\r\n * Initializes and exports Supabase clients for the application\r\n */\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\r\nimport type { Database } from './types'\r\n\r\n// Environment variables\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n/**\r\n * Check if a string is a valid HTTP/HTTPS URL\r\n */\r\nfunction isValidUrl(urlString: string | undefined): boolean {\r\n  if (!urlString) return false\r\n  try {\r\n    const url = new URL(urlString)\r\n    return url.protocol === 'http:' || url.protocol === 'https:'\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Supabase is properly configured with valid credentials\r\n */\r\nexport function isSupabaseConfigured(): boolean {\r\n  // Check that URL exists and is a valid HTTP/HTTPS URL\r\n  if (!isValidUrl(supabaseUrl)) return false\r\n  // Check that anon key exists and isn't a placeholder\r\n  if (!supabaseAnonKey || supabaseAnonKey.includes('your-') || supabaseAnonKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n/**\r\n * Check if service role key is available and valid (for writes)\r\n */\r\nexport function hasServiceRoleKey(): boolean {\r\n  if (!supabaseServiceKey) return false\r\n  // Check it's not a placeholder\r\n  if (supabaseServiceKey.includes('your-') || supabaseServiceKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n// Singleton instances\r\nlet anonClient: SupabaseClient<Database> | null = null\r\nlet serviceClient: SupabaseClient<Database> | null = null\r\n\r\n/**\r\n * Get the public Supabase client (anon key)\r\n * Use this for read operations and client-side queries\r\n * Returns null if not configured (call isSupabaseConfigured() first)\r\n */\r\nexport function getSupabaseClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!anonClient) {\r\n    try {\r\n      anonClient = createClient<Database>(supabaseUrl!, supabaseAnonKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return anonClient\r\n}\r\n\r\n/**\r\n * Get the service role Supabase client\r\n * Use this for server-side write operations (local mode only)\r\n * Returns null if not configured\r\n * WARNING: Never expose this in client-side code\r\n */\r\nexport function getSupabaseServiceClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!hasServiceRoleKey()) {\r\n    return null\r\n  }\r\n\r\n  if (!serviceClient) {\r\n    try {\r\n      serviceClient = createClient<Database>(supabaseUrl!, supabaseServiceKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return serviceClient\r\n}\r\n\r\n/**\r\n * Get the appropriate client based on operation type\r\n * - For reads: use anon client\r\n * - For writes: use service client (if available) or anon client\r\n * Returns null if Supabase is not configured\r\n */\r\nexport function getSupabaseClientForOperation(operation: 'read' | 'write'): SupabaseClient<Database> | null {\r\n  if (operation === 'write' && hasServiceRoleKey()) {\r\n    return getSupabaseServiceClient()\r\n  }\r\n  return getSupabaseClient()\r\n}\r\n\r\n// Export types for convenience\r\nexport type { Database }\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGC,GAED;;AAGA,wBAAwB;AACxB,MAAM;AACN,MAAM;AACN,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;AAEhE;;CAEC,GACD,SAAS,WAAW,SAA6B;IAC/C,IAAI,CAAC,WAAW,OAAO;IACvB,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;IACtD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,SAAS;IACd,sDAAsD;IACtD,IAAI,CAAC,WAAW,cAAc,OAAO;IACrC,qDAAqD;IACrD,IAAI,CAAC,mBAAmB,gBAAgB,QAAQ,CAAC,YAAY,gBAAgB,MAAM,GAAG,IAAI,OAAO;IACjG,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,oBAAoB,OAAO;IAChC,+BAA+B;IAC/B,IAAI,mBAAmB,QAAQ,CAAC,YAAY,mBAAmB,MAAM,GAAG,IAAI,OAAO;IACnF,OAAO;AACT;AAEA,sBAAsB;AACtB,IAAI,aAA8C;AAClD,IAAI,gBAAiD;AAO9C,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,YAAY;QACf,IAAI;YACF,aAAa,IAAA,gMAAY,EAAW,aAAc,iBAAkB;gBAClE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,eAAe;QAClB,IAAI;YACF,gBAAgB,IAAA,gMAAY,EAAW,aAAc,oBAAqB;gBACxE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,8BAA8B,SAA2B;IACvE,IAAI,cAAc,WAAW,qBAAqB;QAChD,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 1125, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/base.adapter.ts"],"sourcesContent":["/**\r\n * Base Adapter\r\n * Provides common functionality for all service adapters\r\n * \r\n * The adapter pattern allows seamless switching between:\r\n * - Local mode: Fetch from real service + write to Supabase (auto-detected)\r\n * - Production mode: Read from Supabase cache (fallback when services unreachable)\r\n * \r\n * Mode is auto-detected by attempting to reach local services.\r\n * No DEPLOYMENT_MODE env var required.\r\n */\r\n\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\nimport { getSupabaseClient, getSupabaseServiceClient, isSupabaseConfigured, hasServiceRoleKey } from '@/lib/supabase/client'\r\nimport type { Database, ServiceName } from '@/lib/supabase/types'\r\n\r\n// ============================================\r\n// Server-side Connectivity Detection\r\n// ============================================\r\n\r\ninterface ServiceAvailability {\r\n  available: boolean\r\n  checkedAt: Date\r\n  error?: string\r\n}\r\n\r\n/** Cache of service availability checks */\r\nconst serviceAvailabilityCache = new Map<ServiceName, ServiceAvailability>()\r\n\r\n/** How long to cache availability results (ms) */\r\nconst AVAILABILITY_CACHE_TTL = 5 * 60 * 1000 // 5 minutes\r\n\r\n/** Timeout for availability checks (ms) */\r\nexport const AVAILABILITY_CHECK_TIMEOUT = 2000 // 2 seconds\r\n\r\n/**\r\n * Check if a cached availability result is still valid\r\n */\r\nfunction isAvailabilityCacheValid(serviceName: ServiceName): boolean {\r\n  const cached = serviceAvailabilityCache.get(serviceName)\r\n  if (!cached) return false\r\n  \r\n  const age = Date.now() - cached.checkedAt.getTime()\r\n  return age < AVAILABILITY_CACHE_TTL\r\n}\r\n\r\n/**\r\n * Get global service availability status (for health endpoint)\r\n */\r\nexport function getServiceAvailabilityStatus(): Record<ServiceName, ServiceAvailability | null> {\r\n  const result: Record<string, ServiceAvailability | null> = {}\r\n  const services: ServiceName[] = ['hue', 'spotify', 'cta', 'calendar', 'fitness']\r\n  \r\n  for (const service of services) {\r\n    result[service] = serviceAvailabilityCache.get(service) ?? null\r\n  }\r\n  \r\n  return result as Record<ServiceName, ServiceAvailability | null>\r\n}\r\n\r\n/**\r\n * Check if any local service is available (for mode detection)\r\n */\r\nexport function isAnyLocalServiceAvailable(): boolean {\r\n  for (const [, status] of serviceAvailabilityCache) {\r\n    if (status.available) return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Clear the availability cache (for testing or manual refresh)\r\n */\r\nexport function clearAvailabilityCache(): void {\r\n  serviceAvailabilityCache.clear()\r\n}\r\n\r\n// ============================================\r\n// Adapter Types\r\n// ============================================\r\n\r\nexport interface AdapterConfig {\r\n  /** Service name for logging and sync tracking */\r\n  serviceName: ServiceName\r\n  /** Whether to log operations */\r\n  debug?: boolean\r\n}\r\n\r\nexport interface SyncResult {\r\n  success: boolean\r\n  recordsWritten: number\r\n  error?: string\r\n}\r\n\r\n/**\r\n * Base adapter class that all service adapters extend\r\n */\r\nexport abstract class BaseAdapter<TServiceData, TCachedData> {\r\n  protected serviceName: ServiceName\r\n  protected debug: boolean\r\n  \r\n  /** Cached availability status for this adapter instance */\r\n  private localAvailable: boolean | null = null\r\n\r\n  constructor(config: AdapterConfig) {\r\n    this.serviceName = config.serviceName\r\n    this.debug = config.debug ?? false\r\n  }\r\n\r\n  /**\r\n   * Get the Supabase client for read operations\r\n   * Returns null if Supabase is not configured\r\n   */\r\n  protected getReadClient(): SupabaseClient<Database> | null {\r\n    return getSupabaseClient()\r\n  }\r\n\r\n  /**\r\n   * Get the Supabase client for write operations\r\n   * Uses service role key if available (for local mode writes)\r\n   * Returns null if Supabase is not configured\r\n   */\r\n  protected getWriteClient(): SupabaseClient<Database> | null {\r\n    if (hasServiceRoleKey()) {\r\n      return getSupabaseServiceClient()\r\n    }\r\n    return getSupabaseClient()\r\n  }\r\n\r\n  /**\r\n   * Check if Supabase is available for caching\r\n   */\r\n  protected isSupabaseAvailable(): boolean {\r\n    return isSupabaseConfigured()\r\n  }\r\n\r\n  // ============================================\r\n  // Auto-Detection Methods\r\n  // ============================================\r\n\r\n  /**\r\n   * Abstract method to check if the local service is reachable\r\n   * Each adapter implements this with a quick ping to their service\r\n   * Should timeout quickly (< 2 seconds)\r\n   */\r\n  protected abstract checkServiceAvailability(): Promise<boolean>\r\n\r\n  /**\r\n   * Check if local service is available (with caching)\r\n   */\r\n  protected async isLocalServiceAvailable(): Promise<boolean> {\r\n    // Check instance cache first (for multiple calls in same request)\r\n    if (this.localAvailable !== null) {\r\n      return this.localAvailable\r\n    }\r\n\r\n    // Check global cache\r\n    if (isAvailabilityCacheValid(this.serviceName)) {\r\n      const cached = serviceAvailabilityCache.get(this.serviceName)!\r\n      this.localAvailable = cached.available\r\n      return cached.available\r\n    }\r\n\r\n    // Perform actual check\r\n    this.log('Checking local service availability...')\r\n    \r\n    try {\r\n      const available = await this.checkServiceAvailability()\r\n      \r\n      // Cache the result\r\n      serviceAvailabilityCache.set(this.serviceName, {\r\n        available,\r\n        checkedAt: new Date(),\r\n      })\r\n      this.localAvailable = available\r\n      \r\n      this.log(`Local service ${available ? 'available' : 'unavailable'}`)\r\n      return available\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      \r\n      // Cache the failure\r\n      serviceAvailabilityCache.set(this.serviceName, {\r\n        available: false,\r\n        checkedAt: new Date(),\r\n        error: errorMessage,\r\n      })\r\n      this.localAvailable = false\r\n      \r\n      this.log(`Local service check failed: ${errorMessage}`)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if running in local mode (service available)\r\n   * Auto-detects based on service reachability\r\n   */\r\n  protected async isLocal(): Promise<boolean> {\r\n    return this.isLocalServiceAvailable()\r\n  }\r\n\r\n  /**\r\n   * Check if running in production mode (service unavailable)\r\n   * Auto-detects based on service reachability\r\n   */\r\n  protected async isProduction(): Promise<boolean> {\r\n    return !(await this.isLocalServiceAvailable())\r\n  }\r\n\r\n  /**\r\n   * Synchronous check if local - uses cached value\r\n   * Returns false if no cached value (assumes production until proven otherwise)\r\n   */\r\n  protected isLocalSync(): boolean {\r\n    if (this.localAvailable !== null) {\r\n      return this.localAvailable\r\n    }\r\n    \r\n    const cached = serviceAvailabilityCache.get(this.serviceName)\r\n    if (cached && isAvailabilityCacheValid(this.serviceName)) {\r\n      return cached.available\r\n    }\r\n    \r\n    // Default to false (production) if not yet checked\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Log a message if debug is enabled\r\n   */\r\n  protected log(message: string, data?: unknown): void {\r\n    if (this.debug) {\r\n      console.log(`[${this.serviceName.toUpperCase()} Adapter] ${message}`, data ?? '')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log an error\r\n   * Silently ignores Supabase configuration errors to avoid console spam\r\n   */\r\n  protected logError(message: string, error?: unknown): void {\r\n    // Suppress errors related to missing tables or unconfigured Supabase\r\n    if (error && typeof error === 'object') {\r\n      const errObj = error as Record<string, unknown>\r\n      // Suppress table not found errors (migration not run yet)\r\n      if (errObj.code === 'PGRST205' || errObj.code === '42P01') return\r\n      // Suppress connection errors when Supabase isn't properly configured  \r\n      if (errObj.message && String(errObj.message).includes('not configured')) return\r\n    }\r\n    console.error(`[${this.serviceName.toUpperCase()} Adapter] ${message}`, error ?? '')\r\n  }\r\n\r\n  /**\r\n   * Record a sync operation in the sync_log table\r\n   */\r\n  protected async logSync(status: 'success' | 'error', recordsSynced: number = 0, errorMessage?: string): Promise<void> {\r\n    if (!this.isSupabaseAvailable()) return\r\n\r\n    try {\r\n      const client = this.getWriteClient()\r\n      if (!client) return // Supabase not configured\r\n      \r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      await (client.from('sync_log') as any).insert({\r\n        service: this.serviceName,\r\n        status,\r\n        records_synced: recordsSynced,\r\n        error_message: errorMessage ?? null,\r\n        synced_at: new Date().toISOString(),\r\n      })\r\n    } catch (error) {\r\n      // Silently ignore - logging sync shouldn't break the app\r\n      if (this.debug) {\r\n        this.logError('Failed to log sync', error)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the last sync time for this service\r\n   */\r\n  async getLastSyncTime(): Promise<Date | null> {\r\n    if (!this.isSupabaseAvailable()) return null\r\n\r\n    try {\r\n      const client = this.getReadClient()\r\n      if (!client) return null // Supabase not configured\r\n      \r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const { data, error } = await (client.from('sync_log') as any)\r\n        .select('synced_at')\r\n        .eq('service', this.serviceName)\r\n        .eq('status', 'success')\r\n        .order('synced_at', { ascending: false })\r\n        .limit(1)\r\n        .single()\r\n\r\n      if (error || !data) return null\r\n      return new Date((data as { synced_at: string }).synced_at)\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Abstract method to fetch data from the real service\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract fetchFromService(): Promise<TServiceData>\r\n\r\n  /**\r\n   * Abstract method to fetch cached data from Supabase\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract fetchFromCache(): Promise<TCachedData | null>\r\n\r\n  /**\r\n   * Abstract method to write data to Supabase cache\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract writeToCache(data: TServiceData): Promise<SyncResult>\r\n\r\n  /**\r\n   * Main method to get data\r\n   * Auto-detects mode:\r\n   * - If local service reachable: fetches from service and writes to cache\r\n   * - If local service unreachable: reads from cache\r\n   */\r\n  async getData(): Promise<TServiceData | TCachedData | null> {\r\n    const isLocalAvailable = await this.isLocal()\r\n    \r\n    if (isLocalAvailable) {\r\n      return this.getDataLocal()\r\n    }\r\n    return this.getDataProduction()\r\n  }\r\n\r\n  /**\r\n   * Get data in local mode\r\n   * Fetches from real service and writes to Supabase\r\n   */\r\n  protected async getDataLocal(): Promise<TServiceData | null> {\r\n    this.log('Fetching from real service (local mode)')\r\n\r\n    try {\r\n      const data = await this.fetchFromService()\r\n      \r\n      // Write to cache in background (don't block the response)\r\n      if (this.isSupabaseAvailable()) {\r\n        this.writeToCache(data)\r\n          .then((result) => {\r\n            if (result.success) {\r\n              this.log(`Cached ${result.recordsWritten} records`)\r\n            } else {\r\n              this.logError('Failed to cache data', result.error)\r\n            }\r\n          })\r\n          .catch((error) => {\r\n            this.logError('Error writing to cache', error)\r\n          })\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from service', error)\r\n      \r\n      // On service error, try falling back to cache\r\n      this.log('Service error, attempting cache fallback...')\r\n      if (this.isSupabaseAvailable()) {\r\n        try {\r\n          const cached = await this.fetchFromCache()\r\n          if (cached) {\r\n            this.log('Using cached data as fallback')\r\n            return cached as TServiceData\r\n          }\r\n        } catch {\r\n          // Cache fallback also failed\r\n        }\r\n      }\r\n      \r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get data in production mode\r\n   * Reads from Supabase cache\r\n   */\r\n  protected async getDataProduction(): Promise<TCachedData | null> {\r\n    this.log('Fetching from cache (production mode)')\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      this.logError('Supabase not configured')\r\n      return null\r\n    }\r\n\r\n    try {\r\n      const data = await this.fetchFromCache()\r\n      \r\n      if (!data) {\r\n        this.log('No cached data available')\r\n        return null\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force refresh the cache (local mode only)\r\n   * Fetches from service and writes to cache, waiting for write to complete\r\n   */\r\n  async refreshCache(): Promise<SyncResult> {\r\n    const isLocalAvailable = await this.isLocal()\r\n    \r\n    if (!isLocalAvailable) {\r\n      return { success: false, recordsWritten: 0, error: 'Cache refresh only available when local services are reachable' }\r\n    }\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    this.log('Force refreshing cache')\r\n\r\n    try {\r\n      const data = await this.fetchFromService()\r\n      const result = await this.writeToCache(data)\r\n      \r\n      await this.logSync(result.success ? 'success' : 'error', result.recordsWritten, result.error)\r\n      \r\n      return result\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      await this.logSync('error', 0, errorMessage)\r\n      return { success: false, recordsWritten: 0, error: errorMessage }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to safely parse JSON from Supabase\r\n */\r\nexport function parseJsonSafe<T>(data: unknown, fallback: T): T {\r\n  if (data === null || data === undefined) return fallback\r\n  if (typeof data === 'object') return data as T\r\n  if (typeof data === 'string') {\r\n    try {\r\n      return JSON.parse(data) as T\r\n    } catch {\r\n      return fallback\r\n    }\r\n  }\r\n  return fallback\r\n}\r\n\r\n/**\r\n * Utility function to get current timestamp in ISO format\r\n */\r\nexport function getCurrentTimestamp(): string {\r\n  return new Date().toISOString()\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1541, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/hue.service.ts"],"sourcesContent":["/**\r\n * HUE Bridge Service\r\n * Handles communication with Philips HUE bridge\r\n */\r\n\r\nimport axios from \"axios\"\r\nimport { config } from \"@/lib/config\"\r\nimport type { HueLight, HueZone, HueScene } from \"@/lib/types/hue.types\"\r\n\r\nexport class HueService {\r\n  private baseUrl: string\r\n\r\n  constructor() {\r\n    const bridgeIp = config.hue.bridgeIp\r\n    const username = config.hue.username\r\n\r\n    if (!bridgeIp || !username) {\r\n      this.baseUrl = \"\"\r\n      return\r\n    }\r\n\r\n    this.baseUrl = `http://${bridgeIp}/api/${username}`\r\n  }\r\n\r\n  isConfigured(): boolean {\r\n    return config.hue.isConfigured && this.baseUrl !== \"\"\r\n  }\r\n\r\n  /**\r\n   * Get all lights\r\n   */\r\n  async getLights(): Promise<Record<string, HueLight>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<Record<string, HueLight>>(`${this.baseUrl}/lights`)\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a single light by ID\r\n   */\r\n  async getLight(lightId: string): Promise<HueLight> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<HueLight>(`${this.baseUrl}/lights/${lightId}`)\r\n      return { ...response.data, id: lightId }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle an individual light on/off\r\n   */\r\n  async toggleLight(lightId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      // If on is not provided, toggle the current state\r\n      if (on === undefined) {\r\n        const light = await this.getLight(lightId)\r\n        on = !light.state.on\r\n      }\r\n\r\n      const response = await axios.put(`${this.baseUrl}/lights/${lightId}/state`, {\r\n        on,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all zones/rooms\r\n   */\r\n  async getZones(): Promise<Record<string, HueZone>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<Record<string, HueZone>>(`${this.baseUrl}/groups`)\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a single zone by ID\r\n   */\r\n  async getZone(zoneId: string): Promise<HueZone> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<HueZone>(`${this.baseUrl}/groups/${zoneId}`)\r\n      return { ...response.data, id: zoneId }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle a zone on/off\r\n   */\r\n  async toggleZone(zoneId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      // If on is not provided, toggle the current state\r\n      if (on === undefined) {\r\n        const zones = await this.getZones()\r\n        const zone = zones[zoneId]\r\n        if (!zone) {\r\n          throw new Error(`Zone ${zoneId} not found`)\r\n        }\r\n        on = !zone.state.any_on\r\n      }\r\n\r\n      const response = await axios.put(`${this.baseUrl}/groups/${zoneId}/action`, {\r\n        on,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle all lights on/off\r\n   */\r\n  async toggleAllLights(on: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      // Group 0 is special - it always refers to all lights\r\n      const response = await axios.put(`${this.baseUrl}/groups/0/action`, {\r\n        on,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set brightness for all lights\r\n   */\r\n  async setAllBrightness(brightness: number): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    if (brightness < 1 || brightness > 254) {\r\n      throw new Error(\"Brightness must be between 1 and 254\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/0/action`, {\r\n        on: true,\r\n        bri: brightness,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set brightness for a light\r\n   */\r\n  async setBrightness(lightId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    if (brightness < 0 || brightness > 254) {\r\n      throw new Error(\"Brightness must be between 0 and 254\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/lights/${lightId}/state`, {\r\n        bri: brightness,\r\n        on: true,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set brightness for a zone/group\r\n   */\r\n  async setZoneBrightness(zoneId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    if (brightness < 1 || brightness > 254) {\r\n      throw new Error(\"Brightness must be between 1 and 254\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/${zoneId}/action`, {\r\n        bri: brightness,\r\n        on: true,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set light state (comprehensive control)\r\n   */\r\n  async setLightState(\r\n    lightId: string,\r\n    state: {\r\n      on?: boolean\r\n      bri?: number\r\n      hue?: number\r\n      sat?: number\r\n      ct?: number\r\n      xy?: [number, number]\r\n      transitiontime?: number\r\n    }\r\n  ): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(\r\n        `${this.baseUrl}/lights/${lightId}/state`,\r\n        state\r\n      )\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set zone state (comprehensive control)\r\n   */\r\n  async setZoneState(\r\n    zoneId: string,\r\n    state: {\r\n      on?: boolean\r\n      bri?: number\r\n      hue?: number\r\n      sat?: number\r\n      ct?: number\r\n      xy?: [number, number]\r\n      scene?: string\r\n      transitiontime?: number\r\n    }\r\n  ): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(\r\n        `${this.baseUrl}/groups/${zoneId}/action`,\r\n        state\r\n      )\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all scenes\r\n   */\r\n  async getScenes(): Promise<Record<string, HueScene>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<Record<string, HueScene>>(`${this.baseUrl}/scenes`)\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get scenes for a specific zone (properly filtered)\r\n   */\r\n  async getScenesForZone(zoneId: string): Promise<HueScene[]> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const allScenes = await this.getScenes()\r\n      const zone = await this.getZone(zoneId)\r\n      const zoneLightIds = zone.lights\r\n\r\n      // Filter scenes that belong to this zone\r\n      const zoneScenes = Object.entries(allScenes)\r\n        .filter(([_, scene]) => {\r\n          // Check if scene is explicitly for this group\r\n          if (scene.group === zoneId) return true\r\n          // Check if all scene lights belong to this zone\r\n          if (scene.lights.length > 0) {\r\n            return scene.lights.every((lightId) => zoneLightIds.includes(lightId))\r\n          }\r\n          return false\r\n        })\r\n        .map(([id, scene]) => ({ ...scene, id }))\r\n\r\n      return zoneScenes\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all scenes with their zone information\r\n   */\r\n  async getAllScenesWithZones(): Promise<Array<HueScene & { zoneName?: string }>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const [scenes, zones] = await Promise.all([\r\n        this.getScenes(),\r\n        this.getZones(),\r\n      ])\r\n\r\n      const zonesArray = Object.entries(zones).map(([id, zone]) => ({\r\n        ...zone,\r\n        id,\r\n      }))\r\n\r\n      return Object.entries(scenes).map(([id, scene]) => {\r\n        const zone = zonesArray.find((z) => z.id === scene.group)\r\n        return {\r\n          ...scene,\r\n          id,\r\n          zoneName: zone?.name,\r\n        }\r\n      })\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find scene by name (case-insensitive partial match)\r\n   */\r\n  async findSceneByName(name: string): Promise<HueScene | null> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const scenes = await this.getScenes()\r\n      const normalizedSearch = name.toLowerCase()\r\n\r\n      const entry = Object.entries(scenes).find(([_, scene]) =>\r\n        scene.name.toLowerCase().includes(normalizedSearch)\r\n      )\r\n\r\n      if (entry) {\r\n        return { ...entry[1], id: entry[0] }\r\n      }\r\n\r\n      return null\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate a scene for a zone\r\n   */\r\n  async activateScene(zoneId: string, sceneId: string): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/${zoneId}/action`, {\r\n        scene: sceneId,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get lights for a zone with full details\r\n   */\r\n  async getLightsForZone(zoneId: string): Promise<HueLight[]> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const [zone, allLights] = await Promise.all([\r\n        this.getZone(zoneId),\r\n        this.getLights(),\r\n      ])\r\n\r\n      return zone.lights\r\n        .filter((lightId) => allLights[lightId] !== undefined)\r\n        .map((lightId) => {\r\n          const light = allLights[lightId]\r\n          return {\r\n            ...light,\r\n            id: lightId,\r\n          } as HueLight\r\n        })\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get aggregate status for all lights\r\n   */\r\n  async getAllLightsStatus(): Promise<{\r\n    totalLights: number\r\n    lightsOn: number\r\n    anyOn: boolean\r\n    allOn: boolean\r\n    averageBrightness: number\r\n  }> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const lights = await this.getLights()\r\n      const lightsArray = Object.values(lights)\r\n\r\n      const lightsOn = lightsArray.filter((l) => l.state.on).length\r\n      const onLights = lightsArray.filter((l) => l.state.on)\r\n      const avgBrightness =\r\n        onLights.length > 0\r\n          ? Math.round(\r\n              onLights.reduce((sum, l) => sum + (l.state.bri || 0), 0) /\r\n                onLights.length\r\n            )\r\n          : 0\r\n\r\n      return {\r\n        totalLights: lightsArray.length,\r\n        lightsOn,\r\n        anyOn: lightsOn > 0,\r\n        allOn: lightsOn === lightsArray.length,\r\n        averageBrightness: avgBrightness,\r\n      }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all entertainment areas (for Hue Sync)\r\n   */\r\n  async getEntertainmentAreas(): Promise<\r\n    Array<HueZone & { stream?: { proxymode: string; proxynode: string; active: boolean; owner?: string } }>\r\n  > {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const groups = await this.getZones()\r\n      const entertainmentAreas = Object.entries(groups)\r\n        .filter(([_, group]) => group.type === \"Entertainment\")\r\n        .map(([id, group]) => ({\r\n          ...group,\r\n          id,\r\n        }))\r\n\r\n      return entertainmentAreas\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get entertainment area by name (case-insensitive partial match)\r\n   */\r\n  async getEntertainmentAreaByName(\r\n    name: string\r\n  ): Promise<(HueZone & { stream?: { proxymode: string; proxynode: string; active: boolean; owner?: string } }) | null> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const areas = await this.getEntertainmentAreas()\r\n      const normalizedSearch = name.toLowerCase()\r\n\r\n      const area = areas.find((a) => a.name.toLowerCase().includes(normalizedSearch))\r\n\r\n      return area || null\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get entertainment/sync status for an area\r\n   */\r\n  async getEntertainmentStatus(areaId: string): Promise<{\r\n    active: boolean\r\n    owner?: string\r\n    proxymode?: string\r\n  }> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get(`${this.baseUrl}/groups/${areaId}`)\r\n      const group = response.data\r\n\r\n      return {\r\n        active: group.stream?.active || false,\r\n        owner: group.stream?.owner,\r\n        proxymode: group.stream?.proxymode,\r\n      }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle entertainment/streaming mode for an area\r\n   * Note: This enables the entertainment API mode. The actual streaming\r\n   * (sending colors) is done by Hue Sync app or Sync Box.\r\n   * \r\n   * When active=false, this stops any active entertainment session,\r\n   * returning lights to their previous state.\r\n   */\r\n  async setEntertainmentMode(areaId: string, active: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/${areaId}`, {\r\n        stream: { active },\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/hue.adapter.ts"],"sourcesContent":["/**\r\n * Hue Adapter\r\n * Handles Philips Hue data with write-through caching to Supabase\r\n * \r\n * Auto-detects mode based on Hue bridge reachability:\r\n * - Bridge reachable: Fetches from Hue bridge, writes to Supabase\r\n * - Bridge unreachable: Reads from Supabase cache\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp, AVAILABILITY_CHECK_TIMEOUT } from './base.adapter'\r\nimport { HueService } from '@/lib/services/hue.service'\r\nimport { config } from '@/lib/config'\r\nimport type { HueLight, HueZone, HueScene, HueAllLightsStatus } from '@/lib/types/hue.types'\r\nimport type { \r\n  HueLightRow, \r\n  HueZoneRow, \r\n  HueSceneRow, \r\n  HueStatusRow,\r\n  HueLightInsert,\r\n  HueZoneInsert,\r\n  HueSceneInsert,\r\n  HueStatusInsert\r\n} from '@/lib/supabase/types'\r\n\r\n// Interfaces for the combined Hue data\r\nexport interface HueFullState {\r\n  lights: Record<string, HueLight>\r\n  zones: HueZone[]\r\n  scenes: HueScene[]\r\n  status: HueAllLightsStatus\r\n}\r\n\r\nexport interface HueCachedState {\r\n  lights: HueLightRow[]\r\n  zones: HueZoneRow[]\r\n  scenes: HueSceneRow[]\r\n  status: HueStatusRow | null\r\n  recordedAt: string\r\n}\r\n\r\n/**\r\n * Hue Adapter - manages all Hue-related data\r\n */\r\nexport class HueAdapter extends BaseAdapter<HueFullState, HueCachedState> {\r\n  private hueService: HueService\r\n\r\n  constructor(debug: boolean = false) {\r\n    super({ serviceName: 'hue', debug })\r\n    this.hueService = new HueService()\r\n  }\r\n\r\n  /**\r\n   * Check if Hue bridge is configured (has IP and username)\r\n   */\r\n  isConfigured(): boolean {\r\n    return this.hueService.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Check if Hue bridge is reachable\r\n   * Used for auto-detection of local vs production mode\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    // If not configured, definitely not available\r\n    if (!this.isConfigured()) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      const bridgeIp = config.hue.bridgeIp\r\n      const username = config.hue.username\r\n      \r\n      if (!bridgeIp || !username) {\r\n        return false\r\n      }\r\n\r\n      // Quick ping to the bridge config endpoint (doesn't require auth for basic info)\r\n      const controller = new AbortController()\r\n      const timeoutId = setTimeout(() => controller.abort(), AVAILABILITY_CHECK_TIMEOUT)\r\n\r\n      const response = await fetch(`http://${bridgeIp}/api/${username}/config`, {\r\n        method: 'GET',\r\n        signal: controller.signal,\r\n      })\r\n\r\n      clearTimeout(timeoutId)\r\n\r\n      // Bridge is available if we get a valid response\r\n      return response.ok\r\n    } catch {\r\n      // Any error means bridge is not reachable\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch all Hue data from the bridge\r\n   */\r\n  protected async fetchFromService(): Promise<HueFullState> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error('Hue bridge not configured')\r\n    }\r\n\r\n    const [lights, zones, scenes, status] = await Promise.all([\r\n      this.hueService.getLights(),\r\n      this.hueService.getZones(),\r\n      this.hueService.getScenes(),\r\n      this.hueService.getAllLightsStatus(),\r\n    ])\r\n\r\n    // Convert zones object to array with IDs\r\n    const zonesArray = Object.entries(zones)\r\n      .map(([id, zone]) => ({ ...zone, id }))\r\n      .filter(z => z.type === 'Room' || z.type === 'Zone')\r\n\r\n    // Convert scenes object to array with IDs\r\n    const scenesArray = Object.entries(scenes)\r\n      .map(([id, scene]) => ({ ...scene, id }))\r\n\r\n    return {\r\n      lights,\r\n      zones: zonesArray,\r\n      scenes: scenesArray,\r\n      status,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch cached Hue data from Supabase\r\n   */\r\n  protected async fetchFromCache(): Promise<HueCachedState | null> {\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      // Fetch latest lights, zones, scenes, and status in parallel\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n      const [lightsResult, zonesResult, scenesResult, statusResult] = await Promise.all([\r\n        clientAny.rpc('get_latest_hue_lights'),\r\n        clientAny.rpc('get_latest_hue_zones'),\r\n        clientAny.rpc('get_latest_hue_scenes'),\r\n        clientAny.rpc('get_latest_hue_status'),\r\n      ])\r\n\r\n      if (lightsResult.error) throw lightsResult.error\r\n      if (zonesResult.error) throw zonesResult.error\r\n      if (scenesResult.error) throw scenesResult.error\r\n      if (statusResult.error) throw statusResult.error\r\n\r\n      const lights = (lightsResult.data ?? []) as HueLightRow[]\r\n      const zones = (zonesResult.data ?? []) as HueZoneRow[]\r\n      const scenes = (scenesResult.data ?? []) as HueSceneRow[]\r\n      const status = statusResult.data as HueStatusRow | null\r\n\r\n      // Determine the most recent recorded_at\r\n      const timestamps = [\r\n        ...lights.map(l => l.recorded_at),\r\n        ...zones.map(z => z.recorded_at),\r\n        ...scenes.map(s => s.recorded_at),\r\n        status?.recorded_at,\r\n      ].filter(Boolean) as string[]\r\n\r\n      const recordedAt = timestamps.length > 0 \r\n        ? timestamps.sort().reverse()[0]! \r\n        : new Date().toISOString()\r\n\r\n      return {\r\n        lights,\r\n        zones,\r\n        scenes,\r\n        status,\r\n        recordedAt,\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write Hue data to Supabase\r\n   */\r\n  protected async writeToCache(data: HueFullState): Promise<SyncResult> {\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    const timestamp = getCurrentTimestamp()\r\n    let recordsWritten = 0\r\n\r\n    try {\r\n      // Write lights\r\n      const lightInserts: HueLightInsert[] = Object.entries(data.lights).map(([id, light]) => ({\r\n        light_id: id,\r\n        name: light.name,\r\n        type: light.type,\r\n        model_id: light.modelid,\r\n        product_name: light.productname,\r\n        state: light.state,\r\n        is_on: light.state.on,\r\n        brightness: light.state.bri ?? null,\r\n        is_reachable: light.state.reachable,\r\n        recorded_at: timestamp,\r\n      }))\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      if (lightInserts.length > 0) {\r\n        const { error: lightsError } = await clientAny\r\n          .from('hue_lights')\r\n          .insert(lightInserts)\r\n        \r\n        if (lightsError) throw lightsError\r\n        recordsWritten += lightInserts.length\r\n      }\r\n\r\n      // Write zones\r\n      const zoneInserts: HueZoneInsert[] = data.zones.map(zone => ({\r\n        zone_id: zone.id,\r\n        name: zone.name,\r\n        type: zone.type,\r\n        class: zone.class ?? null,\r\n        lights: zone.lights,\r\n        state: zone.state,\r\n        action: zone.action ?? null,\r\n        any_on: zone.state.any_on,\r\n        all_on: zone.state.all_on,\r\n        recorded_at: timestamp,\r\n      }))\r\n\r\n      if (zoneInserts.length > 0) {\r\n        const { error: zonesError } = await clientAny\r\n          .from('hue_zones')\r\n          .insert(zoneInserts)\r\n        \r\n        if (zonesError) throw zonesError\r\n        recordsWritten += zoneInserts.length\r\n      }\r\n\r\n      // Write scenes\r\n      const sceneInserts: HueSceneInsert[] = data.scenes.map(scene => ({\r\n        scene_id: scene.id,\r\n        name: scene.name,\r\n        type: scene.type,\r\n        zone_id: scene.group ?? null,\r\n        zone_name: scene.zoneName ?? null,\r\n        lights: scene.lights,\r\n        owner: scene.owner ?? null,\r\n        recycle: scene.recycle ?? false,\r\n        locked: scene.locked ?? false,\r\n        recorded_at: timestamp,\r\n      }))\r\n\r\n      if (sceneInserts.length > 0) {\r\n        const { error: scenesError } = await clientAny\r\n          .from('hue_scenes')\r\n          .insert(sceneInserts)\r\n        \r\n        if (scenesError) throw scenesError\r\n        recordsWritten += sceneInserts.length\r\n      }\r\n\r\n      // Write status\r\n      const statusInsert: HueStatusInsert = {\r\n        total_lights: data.status.totalLights,\r\n        lights_on: data.status.lightsOn,\r\n        any_on: data.status.anyOn,\r\n        all_on: data.status.allOn,\r\n        average_brightness: data.status.averageBrightness,\r\n        recorded_at: timestamp,\r\n      }\r\n\r\n      const { error: statusError } = await clientAny\r\n        .from('hue_status')\r\n        .insert(statusInsert)\r\n      \r\n      if (statusError) throw statusError\r\n      recordsWritten += 1\r\n\r\n      return { success: true, recordsWritten }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error writing to cache', error)\r\n      return { success: false, recordsWritten, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get all lights status\r\n   */\r\n  async getAllLightsStatus(): Promise<HueAllLightsStatus | null> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      try {\r\n        const status = await this.hueService.getAllLightsStatus()\r\n        \r\n        // Write to cache in background (only if Supabase is configured)\r\n        if (this.isSupabaseAvailable()) {\r\n          const client = this.getWriteClient()\r\n          if (client) {\r\n            const timestamp = getCurrentTimestamp()\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            ;(client as any)\r\n              .from('hue_status')\r\n              .insert({\r\n                total_lights: status.totalLights,\r\n                lights_on: status.lightsOn,\r\n                any_on: status.anyOn,\r\n                all_on: status.allOn,\r\n                average_brightness: status.averageBrightness,\r\n                recorded_at: timestamp,\r\n              })\r\n              .then(({ error }: { error: unknown }) => {\r\n                if (error) this.logError('Failed to cache status', error)\r\n              })\r\n          }\r\n        }\r\n\r\n        return status\r\n      } catch (error) {\r\n        this.logError('Error fetching status', error)\r\n        throw error\r\n      }\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached?.status) return null\r\n\r\n    return {\r\n      totalLights: cached.status.total_lights,\r\n      lightsOn: cached.status.lights_on,\r\n      anyOn: cached.status.any_on,\r\n      allOn: cached.status.all_on,\r\n      averageBrightness: cached.status.average_brightness,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all lights\r\n   */\r\n  async getLights(): Promise<Record<string, HueLight>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getLights()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return {}\r\n\r\n    const lights: Record<string, HueLight> = {}\r\n    for (const row of cached.lights) {\r\n      lights[row.light_id] = {\r\n        id: row.light_id,\r\n        name: row.name,\r\n        type: row.type ?? '',\r\n        modelid: row.model_id ?? '',\r\n        manufacturername: '',\r\n        productname: row.product_name ?? '',\r\n        state: row.state,\r\n        capabilities: { control: { mindimlevel: 0, maxlumen: 0 } },\r\n      }\r\n    }\r\n    return lights\r\n  }\r\n\r\n  /**\r\n   * Get all zones\r\n   */\r\n  async getZones(): Promise<Record<string, HueZone>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getZones()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return {}\r\n\r\n    const zones: Record<string, HueZone> = {}\r\n    for (const row of cached.zones) {\r\n      zones[row.zone_id] = {\r\n        id: row.zone_id,\r\n        name: row.name,\r\n        type: row.type ?? '',\r\n        class: row.class ?? undefined,\r\n        lights: row.lights,\r\n        state: row.state,\r\n        action: row.action ?? undefined,\r\n      }\r\n    }\r\n    return zones\r\n  }\r\n\r\n  /**\r\n   * Get all scenes\r\n   */\r\n  async getScenes(): Promise<Record<string, HueScene>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getScenes()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return {}\r\n\r\n    const scenes: Record<string, HueScene> = {}\r\n    for (const row of cached.scenes) {\r\n      scenes[row.scene_id] = {\r\n        id: row.scene_id,\r\n        name: row.name,\r\n        type: row.type ?? '',\r\n        group: row.zone_id ?? undefined,\r\n        zoneName: row.zone_name ?? undefined,\r\n        lights: row.lights,\r\n        owner: row.owner ?? undefined,\r\n        recycle: row.recycle,\r\n        locked: row.locked,\r\n      }\r\n    }\r\n    return scenes\r\n  }\r\n\r\n  /**\r\n   * Get scenes for a specific zone\r\n   */\r\n  async getScenesForZone(zoneId: string): Promise<HueScene[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getScenesForZone(zoneId)\r\n    }\r\n\r\n    // Production mode - filter cached scenes\r\n    const scenes = await this.getScenes()\r\n    return Object.values(scenes).filter(scene => scene.group === zoneId)\r\n  }\r\n\r\n  /**\r\n   * Get a specific zone\r\n   */\r\n  async getZone(zoneId: string): Promise<HueZone | null> {\r\n    const zones = await this.getZones()\r\n    return zones[zoneId] ?? null\r\n  }\r\n\r\n  /**\r\n   * Get lights for a specific zone\r\n   */\r\n  async getLightsForZone(zoneId: string): Promise<HueLight[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getLightsForZone(zoneId)\r\n    }\r\n\r\n    // Production mode - get zone and filter lights\r\n    const [zone, allLights] = await Promise.all([\r\n      this.getZone(zoneId),\r\n      this.getLights(),\r\n    ])\r\n\r\n    if (!zone) return []\r\n\r\n    return zone.lights\r\n      .filter(lightId => allLights[lightId] !== undefined)\r\n      .map(lightId => {\r\n        const light = allLights[lightId]!\r\n        return { ...light, id: lightId }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Get entertainment areas\r\n   */\r\n  async getEntertainmentAreas(): Promise<HueZone[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getEntertainmentAreas()\r\n    }\r\n\r\n    // Production mode - filter cached zones\r\n    const zones = await this.getZones()\r\n    return Object.values(zones).filter(z => z.type === 'Entertainment')\r\n  }\r\n\r\n  /**\r\n   * Get entertainment status for an area\r\n   */\r\n  async getEntertainmentStatus(areaId: string): Promise<{ active: boolean; owner?: string; proxymode?: string }> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getEntertainmentStatus(areaId)\r\n    }\r\n\r\n    // Production mode - return inactive (can't know real status)\r\n    return { active: false }\r\n  }\r\n\r\n  // ==========================================\r\n  // Mutation methods (local mode only)\r\n  // Use isLocalSync() since by the time controls are enabled,\r\n  // the availability check has already been cached\r\n  // ==========================================\r\n\r\n  async toggleLight(lightId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.toggleLight(lightId, on)\r\n  }\r\n\r\n  async toggleZone(zoneId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.toggleZone(zoneId, on)\r\n  }\r\n\r\n  async toggleAllLights(on: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.toggleAllLights(on)\r\n  }\r\n\r\n  async setBrightness(lightId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setBrightness(lightId, brightness)\r\n  }\r\n\r\n  async setZoneBrightness(zoneId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setZoneBrightness(zoneId, brightness)\r\n  }\r\n\r\n  async setAllBrightness(brightness: number): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setAllBrightness(brightness)\r\n  }\r\n\r\n  async activateScene(zoneId: string, sceneId: string): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.activateScene(zoneId, sceneId)\r\n  }\r\n\r\n  async setLightState(lightId: string, state: Parameters<HueService['setLightState']>[1]): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setLightState(lightId, state)\r\n  }\r\n\r\n  async setZoneState(zoneId: string, state: Parameters<HueService['setZoneState']>[1]): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setZoneState(zoneId, state)\r\n  }\r\n\r\n  async setEntertainmentMode(areaId: string, active: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setEntertainmentMode(areaId, active)\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet hueAdapterInstance: HueAdapter | null = null\r\n\r\nexport function getHueAdapter(): HueAdapter {\r\n  if (!hueAdapterInstance) {\r\n    hueAdapterInstance = new HueAdapter()\r\n  }\r\n  return hueAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2536, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/spotify.adapter.ts"],"sourcesContent":["/**\r\n * Spotify Adapter\r\n * Handles Spotify playback data with write-through caching to Supabase\r\n * \r\n * Spotify requires OAuth authentication, so availability depends on\r\n * whether the user is authenticated. Supabase cache is used as fallback.\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp } from './base.adapter'\r\nimport { SpotifyService, loadSpotifyTokensFromCookies } from '@/lib/services/spotify.service'\r\nimport { cookies } from 'next/headers'\r\nimport { config } from '@/lib/config'\r\nimport type { \r\n  SpotifyPlaybackState, \r\n  SpotifyDevice, \r\n  SpotifyUser \r\n} from '@/lib/types/spotify.types'\r\nimport type { SpotifyStateRow, SpotifyStateInsert } from '@/lib/supabase/types'\r\n\r\nexport interface SpotifyFullState {\r\n  playbackState: SpotifyPlaybackState | null\r\n  devices: SpotifyDevice[]\r\n  user: SpotifyUser | null\r\n}\r\n\r\nexport interface SpotifyCachedState {\r\n  playbackState: SpotifyPlaybackState | null\r\n  devices: SpotifyDevice[]\r\n  user: SpotifyUser | null\r\n  isPlaying: boolean\r\n  currentTrack: {\r\n    name: string | null\r\n    artist: string | null\r\n    album: string | null\r\n    imageUrl: string | null\r\n    progressMs: number | null\r\n    durationMs: number | null\r\n  }\r\n  recordedAt: string\r\n}\r\n\r\n/**\r\n * Spotify Adapter - manages Spotify playback data\r\n */\r\nexport class SpotifyAdapter extends BaseAdapter<SpotifyFullState, SpotifyCachedState> {\r\n  private spotifyService: SpotifyService\r\n\r\n  constructor(debug: boolean = false) {\r\n    super({ serviceName: 'spotify', debug })\r\n    this.spotifyService = new SpotifyService()\r\n  }\r\n\r\n  /**\r\n   * Check if Spotify is configured\r\n   */\r\n  isConfigured(): boolean {\r\n    return config.spotify.isConfigured\r\n  }\r\n\r\n  /**\r\n   * Check if Spotify API is available\r\n   * Spotify is an external API that requires OAuth - we consider it \"available\"\r\n   * if the service is configured. Authentication is handled separately.\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    return this.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Initialize the service with tokens from cookies\r\n   * Must be called in server context before fetching data\r\n   */\r\n  async initializeWithTokens(): Promise<{ authenticated: boolean; needsRefresh: boolean }> {\r\n    if (!this.isConfigured()) {\r\n      return { authenticated: false, needsRefresh: false }\r\n    }\r\n\r\n    const cookieStore = await cookies()\r\n    const { accessToken, refreshToken, needsRefresh } = await loadSpotifyTokensFromCookies(\r\n      this.spotifyService,\r\n      cookieStore\r\n    )\r\n\r\n    return {\r\n      authenticated: Boolean(accessToken || refreshToken),\r\n      needsRefresh,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch all Spotify data from the API\r\n   */\r\n  protected async fetchFromService(): Promise<SpotifyFullState> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error('Spotify not configured')\r\n    }\r\n\r\n    // Get playback state and devices in parallel\r\n    const [playbackState, devices] = await Promise.all([\r\n      this.spotifyService.getPlaybackState().catch(() => null),\r\n      this.spotifyService.getDevices().catch(() => []),\r\n    ])\r\n\r\n    // Try to get user info (might fail if not authenticated)\r\n    let user: SpotifyUser | null = null\r\n    try {\r\n      user = await this.spotifyService.getCurrentUser()\r\n    } catch {\r\n      // User info is optional\r\n    }\r\n\r\n    return {\r\n      playbackState,\r\n      devices,\r\n      user,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch cached Spotify data from Supabase\r\n   */\r\n  protected async fetchFromCache(): Promise<SpotifyCachedState | null> {\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      const { data, error } = await client.rpc('get_latest_spotify_state')\r\n\r\n      if (error) throw error\r\n      if (!data) return null\r\n\r\n      const row = data as SpotifyStateRow\r\n\r\n      return {\r\n        playbackState: row.playback_state,\r\n        devices: row.devices ?? [],\r\n        user: row.user_info,\r\n        isPlaying: row.is_playing,\r\n        currentTrack: {\r\n          name: row.current_track_name,\r\n          artist: row.current_track_artist,\r\n          album: row.current_track_album,\r\n          imageUrl: row.current_track_image_url,\r\n          progressMs: row.progress_ms,\r\n          durationMs: row.duration_ms,\r\n        },\r\n        recordedAt: row.recorded_at,\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write Spotify data to Supabase\r\n   */\r\n  protected async writeToCache(data: SpotifyFullState): Promise<SyncResult> {\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    const timestamp = getCurrentTimestamp()\r\n\r\n    try {\r\n      const track = data.playbackState?.item\r\n      const insert: SpotifyStateInsert = {\r\n        playback_state: data.playbackState,\r\n        devices: data.devices,\r\n        user_info: data.user,\r\n        is_playing: data.playbackState?.is_playing ?? false,\r\n        current_track_name: track?.name ?? null,\r\n        current_track_artist: track?.artists?.map(a => a.name).join(', ') ?? null,\r\n        current_track_album: track?.album?.name ?? null,\r\n        current_track_image_url: track?.album?.images?.[0]?.url ?? null,\r\n        progress_ms: data.playbackState?.progress_ms ?? null,\r\n        duration_ms: track?.duration_ms ?? null,\r\n        recorded_at: timestamp,\r\n      }\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const { error } = await (client.from('spotify_state') as any).insert(insert)\r\n\r\n      if (error) throw error\r\n\r\n      return { success: true, recordsWritten: 1 }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error writing to cache', error)\r\n      return { success: false, recordsWritten: 0, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get current playback state\r\n   */\r\n  async getPlaybackState(): Promise<SpotifyPlaybackState | null> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      try {\r\n        const state = await this.spotifyService.getPlaybackState()\r\n        \r\n        // Write to cache in background\r\n        if (this.isSupabaseAvailable() && state) {\r\n          const devices = await this.spotifyService.getDevices().catch(() => [])\r\n          this.writeToCache({ playbackState: state, devices, user: null })\r\n            .catch(err => this.logError('Failed to cache playback state', err))\r\n        }\r\n\r\n        return state\r\n      } catch (error) {\r\n        this.logError('Error fetching playback state', error)\r\n        throw error\r\n      }\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    return cached?.playbackState ?? null\r\n  }\r\n\r\n  /**\r\n   * Get available devices\r\n   */\r\n  async getDevices(): Promise<SpotifyDevice[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.spotifyService.getDevices()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    return cached?.devices ?? []\r\n  }\r\n\r\n  /**\r\n   * Get current user info\r\n   */\r\n  async getCurrentUser(): Promise<SpotifyUser | null> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      try {\r\n        return await this.spotifyService.getCurrentUser()\r\n      } catch {\r\n        return null\r\n      }\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    return cached?.user ?? null\r\n  }\r\n\r\n  /**\r\n   * Get simplified \"now playing\" info\r\n   * Useful for display widgets\r\n   */\r\n  async getNowPlaying(): Promise<{\r\n    isPlaying: boolean\r\n    track: {\r\n      name: string\r\n      artist: string\r\n      album: string\r\n      imageUrl: string\r\n    } | null\r\n    progressMs: number\r\n    durationMs: number\r\n    recordedAt?: string\r\n  }> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      const state = await this.getPlaybackState()\r\n      \r\n      if (!state?.item) {\r\n        return { isPlaying: false, track: null, progressMs: 0, durationMs: 0 }\r\n      }\r\n\r\n      return {\r\n        isPlaying: state.is_playing,\r\n        track: {\r\n          name: state.item.name,\r\n          artist: state.item.artists.map(a => a.name).join(', '),\r\n          album: state.item.album.name,\r\n          imageUrl: state.item.album.images[0]?.url ?? '',\r\n        },\r\n        progressMs: state.progress_ms ?? 0,\r\n        durationMs: state.item.duration_ms,\r\n      }\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    \r\n    if (!cached) {\r\n      return { isPlaying: false, track: null, progressMs: 0, durationMs: 0 }\r\n    }\r\n\r\n    return {\r\n      isPlaying: cached.isPlaying,\r\n      track: cached.currentTrack.name ? {\r\n        name: cached.currentTrack.name,\r\n        artist: cached.currentTrack.artist ?? '',\r\n        album: cached.currentTrack.album ?? '',\r\n        imageUrl: cached.currentTrack.imageUrl ?? '',\r\n      } : null,\r\n      progressMs: cached.currentTrack.progressMs ?? 0,\r\n      durationMs: cached.currentTrack.durationMs ?? 0,\r\n      recordedAt: cached.recordedAt,\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // Mutation methods (local mode only)\r\n  // These delegate to the real service\r\n  // ==========================================\r\n\r\n  async play(options?: Parameters<SpotifyService['play']>[0]): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.play(options)\r\n  }\r\n\r\n  async pause(deviceId?: string): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.pause(deviceId)\r\n  }\r\n\r\n  async skipToNext(deviceId?: string): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.skipToNext(deviceId)\r\n  }\r\n\r\n  async skipToPrevious(deviceId?: string): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.skipToPrevious(deviceId)\r\n  }\r\n\r\n  async seek(positionMs: number, deviceId?: string): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.seek(positionMs, deviceId)\r\n  }\r\n\r\n  async setVolume(volumePercent: number, deviceId?: string): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.setVolume(volumePercent, deviceId)\r\n  }\r\n\r\n  async setShuffle(state: boolean, deviceId?: string): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.setShuffle(state, deviceId)\r\n  }\r\n\r\n  async transferPlayback(deviceId: string, play?: boolean): Promise<void> {\r\n    if (!this.isLocal()) throw new Error('Controls only available in local mode')\r\n    return this.spotifyService.transferPlayback(deviceId, play)\r\n  }\r\n\r\n  // Pass-through methods for auth (always work)\r\n  getAuthUrl(state?: string): string {\r\n    return this.spotifyService.getAuthUrl(state)\r\n  }\r\n\r\n  async exchangeCode(code: string) {\r\n    return this.spotifyService.exchangeCode(code)\r\n  }\r\n\r\n  async refreshAccessToken(refreshToken: string) {\r\n    return this.spotifyService.refreshAccessToken(refreshToken)\r\n  }\r\n\r\n  setCredentials(accessToken: string, refreshToken?: string) {\r\n    this.spotifyService.setCredentials(accessToken, refreshToken)\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet spotifyAdapterInstance: SpotifyAdapter | null = null\r\n\r\nexport function getSpotifyAdapter(): SpotifyAdapter {\r\n  if (!spotifyAdapterInstance) {\r\n    spotifyAdapterInstance = new SpotifyAdapter()\r\n  }\r\n  return spotifyAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2860, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/fitness.service.ts"],"sourcesContent":["/**\n * Fitness Service\n * Handles fitness routine storage and management\n * Based on workout.md - comprehensive fitness tracking system\n */\n\nimport type {\n  ConsistencyStats,\n  DayOfWeek,\n  FitnessProgress,\n  WeeklyRoutine,\n  Workout,\n} from '@/lib/types/fitness.types'\nimport { promises as fs } from 'fs'\nimport path from 'path'\n\nconst ROUTINE_FILE = path.join(process.cwd(), 'data', 'fitness-routine.json')\nconst WORKOUT_DEFINITIONS_FILE = path.join(\n  process.cwd(),\n  'data',\n  'workout-definitions.json'\n)\n\n// Export file paths for adapter use\nexport const ROUTINE_FILE_PATH = ROUTINE_FILE\nexport const WORKOUT_DEFINITIONS_FILE_PATH = WORKOUT_DEFINITIONS_FILE\n\nexport class FitnessService {\n  /**\n   * Ensure data directory exists\n   */\n  private async ensureDataDir(): Promise<void> {\n    const dataDir = path.dirname(ROUTINE_FILE)\n    try {\n      await fs.access(dataDir)\n    } catch {\n      await fs.mkdir(dataDir, { recursive: true })\n    }\n  }\n\n  /**\n   * Get workout definitions (public method)\n   */\n  async getWorkoutDefinitions(): Promise<Record<DayOfWeek, Workout>> {\n    try {\n      const data = await fs.readFile(WORKOUT_DEFINITIONS_FILE, 'utf-8')\n      return JSON.parse(data) as Record<DayOfWeek, Workout>\n    } catch {\n      return {} as Record<DayOfWeek, Workout>\n    }\n  }\n\n  /**\n   * Update all workout definitions\n   */\n  async updateWorkoutDefinitions(\n    definitions: Record<DayOfWeek, Workout>\n  ): Promise<Record<DayOfWeek, Workout>> {\n    await this.ensureDataDir()\n    await fs.writeFile(\n      WORKOUT_DEFINITIONS_FILE,\n      JSON.stringify(definitions, null, 2),\n      'utf-8'\n    )\n    return definitions\n  }\n\n  /**\n   * Update workout definition for a specific day\n   */\n  async updateWorkoutDefinition(\n    day: DayOfWeek,\n    workout: Workout\n  ): Promise<Workout> {\n    const definitions = await this.getWorkoutDefinitions()\n    definitions[day] = workout\n    await this.updateWorkoutDefinitions(definitions)\n    return workout\n  }\n\n  /**\n   * Get current week number (Monday start)\n   */\n  private getCurrentWeekNumber(): number {\n    const now = new Date()\n    const startOfYear = new Date(now.getFullYear(), 0, 1)\n    const days = Math.floor(\n      (now.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n    )\n    const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7)\n    return weekNumber\n  }\n\n  /**\n   * Get start date of week (Monday)\n   */\n  private getWeekStartDate(weekNumber: number): Date {\n    const now = new Date()\n    const startOfYear = new Date(now.getFullYear(), 0, 1)\n    const days = (weekNumber - 1) * 7\n    const weekStart = new Date(startOfYear)\n    weekStart.setDate(startOfYear.getDate() + days - startOfYear.getDay() + 1) // Monday\n    return weekStart\n  }\n\n  /**\n   * Get or create week routine\n   */\n  private async getOrCreateWeek(routine: WeeklyRoutine, weekNumber: number) {\n    let week = routine.weeks.find(w => w.weekNumber === weekNumber)\n    if (!week) {\n      const startDate = this.getWeekStartDate(weekNumber)\n      week = {\n        weekNumber,\n        startDate: startDate.toISOString(),\n        days: {},\n      }\n      routine.weeks.push(week)\n      routine.weeks.sort((a, b) => a.weekNumber - b.weekNumber)\n    }\n    return week\n  }\n\n  /**\n   * Get weekly routine with workout definitions\n   */\n  async getRoutine(): Promise<WeeklyRoutine | null> {\n    try {\n      await this.ensureDataDir()\n      const data = await fs.readFile(ROUTINE_FILE, 'utf-8')\n      const routine = JSON.parse(data) as WeeklyRoutine\n\n      // Ensure current week exists\n      const currentWeek = this.getCurrentWeekNumber()\n      await this.getOrCreateWeek(routine, currentWeek)\n\n      // Load workout definitions\n      const workoutDefinitions = await this.getWorkoutDefinitions()\n\n      // Ensure all days have workout definitions in current week\n      const week = routine.weeks.find(w => w.weekNumber === currentWeek)\n      if (week) {\n        const days: DayOfWeek[] = [\n          'monday',\n          'tuesday',\n          'wednesday',\n          'thursday',\n          'friday',\n          'saturday',\n          'sunday',\n        ]\n        days.forEach(day => {\n          if (!week.days[day]) {\n            week.days[day] = {}\n          }\n          // Add workout definition if it exists and not already set\n          if (workoutDefinitions[day] && !week.days[day]?.workout) {\n            // Workout will be loaded from definitions when needed\n          }\n        })\n        await this.updateRoutine(routine)\n      }\n\n      return routine\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get workout for a specific day\n   */\n  async getWorkoutForDay(\n    day: DayOfWeek,\n    weekNumber?: number\n  ): Promise<Workout | null> {\n    const workoutDefinitions = await this.getWorkoutDefinitions()\n    return workoutDefinitions[day] || null\n  }\n\n  /**\n   * Update weekly routine\n   */\n  async updateRoutine(routine: WeeklyRoutine): Promise<WeeklyRoutine> {\n    await this.ensureDataDir()\n    routine.updatedAt = new Date().toISOString()\n    await fs.writeFile(ROUTINE_FILE, JSON.stringify(routine, null, 2), 'utf-8')\n    return routine\n  }\n\n  /**\n   * Collect all exercise IDs from a workout (warmup, main, finisher, metabolic, mobility).\n   */\n  private getAllExerciseIdsFromWorkout(workout: Workout): string[] {\n    const ids: string[] = []\n    if (workout.warmup?.exercises?.length) {\n      ids.push(...workout.warmup.exercises.map(e => e.id))\n    }\n    if (workout.exercises?.length) {\n      ids.push(...workout.exercises.map(e => e.id))\n    }\n    if (workout.finisher?.length) {\n      ids.push(...workout.finisher.map(e => e.id))\n    }\n    if (workout.metabolicFlush?.exercises?.length) {\n      ids.push(...workout.metabolicFlush.exercises.map(e => e.id))\n    }\n    if (workout.mobility?.exercises?.length) {\n      ids.push(...workout.mobility.exercises.map(e => e.id))\n    }\n    return ids\n  }\n\n  /**\n   * Mark workout as complete. If exercisesCompleted is missing or empty, all exercises\n   * in the workout are auto-completed.\n   */\n  async markWorkoutComplete(\n    day: DayOfWeek,\n    weekNumber: number,\n    exercisesCompleted?: string[]\n  ): Promise<void> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, weekNumber)\n    if (!week.days[day]) {\n      week.days[day] = {}\n    }\n\n    const workoutDef = await this.getWorkoutForDay(day, weekNumber)\n    if (!workoutDef) {\n      throw new Error(`No workout definition found for ${day}`)\n    }\n\n    const allIds = this.getAllExerciseIdsFromWorkout(workoutDef)\n    const resolved = Array.from(\n      new Set([...allIds, ...(exercisesCompleted ?? [])])\n    )\n\n    week.days[day]!.workout = {\n      workoutId: workoutDef.id,\n      completed: true,\n      completedAt: new Date().toISOString(),\n      exercisesCompleted: resolved,\n    }\n\n    await this.updateRoutine(routine)\n  }\n\n  /**\n   * Mark daily routine as complete\n   */\n  async markRoutineComplete(\n    routineType: 'morning' | 'night',\n    day: DayOfWeek,\n    weekNumber: number\n  ): Promise<void> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, weekNumber)\n    if (!week.days[day]) {\n      week.days[day] = {}\n    }\n\n    const routineId = routine.dailyRoutines[routineType].id\n    week.days[day]![`${routineType}Routine`] = {\n      routineId,\n      completed: true,\n      completedAt: new Date().toISOString(),\n    }\n\n    await this.updateRoutine(routine)\n  }\n\n  /**\n   * Mark daily routine as incomplete (undo completion)\n   */\n  async markRoutineIncomplete(\n    routineType: 'morning' | 'night',\n    day: DayOfWeek,\n    weekNumber: number\n  ): Promise<void> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, weekNumber)\n    if (!week.days[day]) {\n      week.days[day] = {}\n    }\n\n    const routineId = routine.dailyRoutines[routineType].id\n    week.days[day]![`${routineType}Routine`] = {\n      routineId,\n      completed: false,\n      completedAt: undefined,\n    }\n\n    await this.updateRoutine(routine)\n  }\n\n  /**\n   * Get weekly progress\n   */\n  async getWeeklyProgress(weekNumber?: number): Promise<FitnessProgress> {\n    const targetWeek = weekNumber || this.getCurrentWeekNumber()\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, targetWeek)\n    const workoutsByDay: FitnessProgress['workoutsByDay'] = {}\n\n    let completedWorkouts = 0\n    let totalWorkouts = 0\n    let completedMorningRoutines = 0\n    let totalMorningRoutines = 0\n    let completedNightRoutines = 0\n    let totalNightRoutines = 0\n\n    const days: DayOfWeek[] = [\n      'monday',\n      'tuesday',\n      'wednesday',\n      'thursday',\n      'friday',\n      'saturday',\n      'sunday',\n    ]\n    const workoutDefinitions = await this.getWorkoutDefinitions()\n\n    days.forEach(day => {\n      const dayData = week.days[day]\n      const hasWorkout = !!workoutDefinitions[day]\n\n      if (hasWorkout) {\n        totalWorkouts++\n        if (dayData?.workout?.completed) {\n          completedWorkouts++\n        }\n      }\n\n      // Morning routine exists every day\n      totalMorningRoutines++\n      if (dayData?.morningRoutine?.completed) {\n        completedMorningRoutines++\n      }\n\n      // Night routine exists every day\n      totalNightRoutines++\n      if (dayData?.nightRoutine?.completed) {\n        completedNightRoutines++\n      }\n\n      workoutsByDay[day] = {\n        workout: dayData?.workout\n          ? {\n              completed: dayData.workout.completed || false,\n              completedAt: dayData.workout.completedAt,\n            }\n          : undefined,\n        morningRoutine: dayData?.morningRoutine\n          ? {\n              completed: dayData.morningRoutine.completed || false,\n              completedAt: dayData.morningRoutine.completedAt,\n            }\n          : undefined,\n        nightRoutine: dayData?.nightRoutine\n          ? {\n              completed: dayData.nightRoutine.completed || false,\n              completedAt: dayData.nightRoutine.completedAt,\n            }\n          : undefined,\n      }\n    })\n\n    const now = new Date()\n    return {\n      week: targetWeek,\n      year: now.getFullYear(),\n      completedWorkouts,\n      totalWorkouts,\n      completedMorningRoutines,\n      totalMorningRoutines,\n      completedNightRoutines,\n      totalNightRoutines,\n      workoutsByDay,\n    }\n  }\n\n  /**\n   * Get consistency stats for a given routine (and optional workout definitions).\n   * Used by the adapter when routine/defs come from Supabase.\n   */\n  async getConsistencyStatsForRoutine(\n    routine: WeeklyRoutine,\n    workoutDefinitions?: Record<DayOfWeek, Workout>\n  ): Promise<ConsistencyStats> {\n    const defs = workoutDefinitions ?? (await this.getWorkoutDefinitions())\n\n    const now = new Date()\n    let totalWorkoutDays = 0\n    let completedWorkoutDays = 0\n    let totalMorningDays = 0\n    let completedMorningDays = 0\n    let totalNightDays = 0\n    let completedNightDays = 0\n\n    let currentStreak = 0\n    let longestStreak = 0\n    let tempStreak = 0\n    let lastActiveDate: Date | undefined\n\n    // Check last 30 days\n    for (let i = 0; i < 30; i++) {\n      const checkDate = new Date(now)\n      checkDate.setDate(checkDate.getDate() - i)\n      const dayOfWeek = checkDate\n        .toLocaleDateString('en-US', { weekday: 'long' })\n        .toLowerCase() as DayOfWeek\n      const weekNum = this.getCurrentWeekNumber() - Math.floor(i / 7)\n\n      const week = routine.weeks.find(w => w.weekNumber === weekNum)\n      const dayData = week?.days[dayOfWeek]\n\n      // Check if any activity happened\n      const hasActivity =\n        dayData?.workout?.completed ||\n        dayData?.morningRoutine?.completed ||\n        dayData?.nightRoutine?.completed\n\n      if (hasActivity) {\n        if (i === 0 || tempStreak > 0) {\n          tempStreak++\n          currentStreak = i === 0 ? tempStreak : currentStreak\n        }\n        longestStreak = Math.max(longestStreak, tempStreak)\n        if (!lastActiveDate) {\n          lastActiveDate = checkDate\n        }\n      } else {\n        tempStreak = 0\n      }\n\n      totalMorningDays++\n      if (dayData?.morningRoutine?.completed) completedMorningDays++\n\n      totalNightDays++\n      if (dayData?.nightRoutine?.completed) completedNightDays++\n\n      if (defs[dayOfWeek]) {\n        totalWorkoutDays++\n        if (dayData?.workout?.completed) completedWorkoutDays++\n      }\n    }\n\n    const weeklyCompletion =\n      totalWorkoutDays > 0 ? (completedWorkoutDays / totalWorkoutDays) * 100 : 0\n\n    const monthlyCompletion =\n      totalWorkoutDays > 0 ? (completedWorkoutDays / totalWorkoutDays) * 100 : 0\n\n    return {\n      currentStreak,\n      longestStreak,\n      weeklyCompletion: Math.round(weeklyCompletion),\n      monthlyCompletion: Math.round(monthlyCompletion),\n      totalDaysActive:\n        completedWorkoutDays + completedMorningDays + completedNightDays,\n      lastActiveDate: lastActiveDate?.toISOString(),\n      streaks: {\n        workouts: currentStreak,\n        morningRoutines: completedMorningDays,\n        nightRoutines: completedNightDays,\n      },\n    }\n  }\n\n  /**\n   * Get consistency stats (uses local JSON routine only).\n   * Prefer using the adapter in production so routine/defs come from Supabase.\n   */\n  async getConsistencyStats(): Promise<ConsistencyStats> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n    return this.getConsistencyStatsForRoutine(routine)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3248, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/fitness.adapter.ts"],"sourcesContent":["/**\r\n * Fitness Adapter\r\n * Replaces JSON file storage with Supabase for fitness routines and progress\r\n * \r\n * Fitness data is primarily stored in Supabase. The local JSON file\r\n * serves as a fallback/seed when Supabase has no data or is unavailable.\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp } from './base.adapter'\r\nimport { FitnessService } from '@/lib/services/fitness.service'\r\nimport type {\r\n  WeeklyRoutine,\r\n  FitnessProgress,\r\n  ConsistencyStats,\r\n  DayOfWeek,\r\n  Workout,\r\n} from '@/lib/types/fitness.types'\r\nimport type {\r\n  RoutineVersion,\r\n  RoutineVersionSummary,\r\n  CreateVersionRequest,\r\n  UpdateVersionRequest,\r\n  VersionsListResponse,\r\n} from '@/lib/types/routine-editor.types'\r\nimport type {\r\n  FitnessRoutineVersionRow,\r\n  FitnessRoutineVersionInsert,\r\n  WorkoutDefinitionRow,\r\n  WorkoutDefinitionInsert,\r\n} from '@/lib/supabase/types'\r\nimport type {\r\n  FitnessRoutineRow,\r\n  FitnessRoutineInsert,\r\n  FitnessWeekRow,\r\n  FitnessWeekInsert,\r\n  FitnessProgressRow,\r\n  FitnessProgressInsert,\r\n} from '@/lib/supabase/types'\r\n\r\n/**\r\n * Fitness Adapter - manages fitness routines and progress\r\n * \r\n * This adapter uses Supabase as the primary data store.\r\n * The JSON file is used as a fallback/seed when Supabase has no data.\r\n */\r\nexport class FitnessAdapter extends BaseAdapter<WeeklyRoutine, WeeklyRoutine> {\r\n  private fitnessService: FitnessService\r\n  private currentRoutineId: string = 'climber-physique'\r\n\r\n  constructor(debug: boolean = false) {\r\n    super({ serviceName: 'fitness', debug })\r\n    this.fitnessService = new FitnessService()\r\n  }\r\n\r\n  /**\r\n   * Check if fitness service is available\r\n   * Fitness uses Supabase as primary storage, but local JSON as fallback.\r\n   * Always returns true since JSON fallback is always available.\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    // Fitness service is always \"available\" - we either use Supabase\r\n    // or fall back to local JSON files\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Fetch from service (JSON file) - used as fallback/seed\r\n   */\r\n  protected async fetchFromService(): Promise<WeeklyRoutine> {\r\n    const routine = await this.fitnessService.getRoutine()\r\n    if (!routine) {\r\n      throw new Error('No fitness routine found')\r\n    }\r\n    return routine\r\n  }\r\n\r\n  /**\r\n   * Fetch from Supabase cache\r\n   */\r\n  protected async fetchFromCache(): Promise<WeeklyRoutine | null> {\r\n    return this.getRoutineFromSupabase()\r\n  }\r\n\r\n  /**\r\n   * Write routine to Supabase\r\n   */\r\n  protected async writeToCache(data: WeeklyRoutine): Promise<SyncResult> {\r\n    return this.saveRoutineToSupabase(data)\r\n  }\r\n\r\n  // ==========================================\r\n  // Supabase Operations\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get routine from Supabase\r\n   */\r\n  private async getRoutineFromSupabase(): Promise<WeeklyRoutine | null> {\r\n    if (!this.isSupabaseAvailable()) return null\r\n\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n      \r\n      // Get the routine\r\n      const { data: routineData, error: routineError } = await clientAny\r\n        .from('fitness_routines')\r\n        .select('*')\r\n        .eq('id', this.currentRoutineId)\r\n        .single()\r\n\r\n      if (routineError || !routineData) {\r\n        this.log('No routine found in Supabase')\r\n        return null\r\n      }\r\n\r\n      // Get weeks for this routine\r\n      const { data: weeksData, error: weeksError } = await clientAny\r\n        .from('fitness_weeks')\r\n        .select('*')\r\n        .eq('routine_id', this.currentRoutineId)\r\n        .order('year', { ascending: false })\r\n        .order('week_number', { ascending: false })\r\n\r\n      if (weeksError) throw weeksError\r\n\r\n      const row = routineData as FitnessRoutineRow\r\n      const weeks = (weeksData ?? []) as FitnessWeekRow[]\r\n\r\n      // Reconstruct the WeeklyRoutine object\r\n      const routine: WeeklyRoutine = {\r\n        id: row.id,\r\n        name: row.name,\r\n        userProfile: row.user_profile,\r\n        injuryProtocol: row.injury_protocol ?? {\r\n          status: 'inactive',\r\n          name: '',\r\n          description: '',\r\n          dailyRehab: [],\r\n          rules: [],\r\n        },\r\n        schedule: row.schedule,\r\n        dailyRoutines: row.daily_routines,\r\n        weeks: weeks.map(w => ({\r\n          weekNumber: w.week_number,\r\n          startDate: w.start_date,\r\n          days: w.days as WeeklyRoutine['weeks'][0]['days'],\r\n        })),\r\n        createdAt: row.created_at,\r\n        updatedAt: row.updated_at,\r\n      }\r\n\r\n      return routine\r\n    } catch (error) {\r\n      this.logError('Error fetching routine from Supabase', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save routine to Supabase\r\n   */\r\n  private async saveRoutineToSupabase(routine: WeeklyRoutine): Promise<SyncResult> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    let recordsWritten = 0\r\n\r\n    try {\r\n      // Upsert the main routine\r\n      const routineInsert: FitnessRoutineInsert = {\r\n        id: routine.id,\r\n        name: routine.name,\r\n        user_profile: routine.userProfile,\r\n        injury_protocol: routine.injuryProtocol,\r\n        schedule: routine.schedule,\r\n        daily_routines: routine.dailyRoutines,\r\n        updated_at: getCurrentTimestamp(),\r\n      }\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n      \r\n      const { error: routineError } = await clientAny\r\n        .from('fitness_routines')\r\n        .upsert(routineInsert, { onConflict: 'id' })\r\n\r\n      if (routineError) throw routineError\r\n      recordsWritten++\r\n\r\n      // Upsert weeks\r\n      for (const week of routine.weeks) {\r\n        const weekInsert: FitnessWeekInsert = {\r\n          routine_id: routine.id,\r\n          week_number: week.weekNumber,\r\n          year: new Date(week.startDate).getFullYear(),\r\n          start_date: week.startDate.split('T')[0] ?? week.startDate,\r\n          days: week.days,\r\n          updated_at: getCurrentTimestamp(),\r\n        }\r\n\r\n        const { error: weekError } = await clientAny\r\n          .from('fitness_weeks')\r\n          .upsert(weekInsert, { onConflict: 'routine_id,week_number,year' })\r\n\r\n        if (weekError) throw weekError\r\n        recordsWritten++\r\n      }\r\n\r\n      return { success: true, recordsWritten }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error saving routine to Supabase', error)\r\n      return { success: false, recordsWritten, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get the current weekly routine\r\n   * Tries Supabase first, falls back to JSON file, then seeds Supabase\r\n   */\r\n  async getRoutine(): Promise<WeeklyRoutine | null> {\r\n    // Try Supabase first\r\n    if (this.isSupabaseAvailable()) {\r\n      const supabaseRoutine = await this.getRoutineFromSupabase()\r\n      if (supabaseRoutine) {\r\n        return supabaseRoutine\r\n      }\r\n\r\n      // No data in Supabase - try to seed from JSON file\r\n      this.log('No routine in Supabase, attempting to seed from JSON file')\r\n      try {\r\n        const fileRoutine = await this.fetchFromService()\r\n        await this.saveRoutineToSupabase(fileRoutine)\r\n        this.log('Seeded Supabase from JSON file')\r\n        return fileRoutine\r\n      } catch (error) {\r\n        this.logError('Failed to seed from JSON file', error)\r\n      }\r\n    }\r\n\r\n    // Fallback to JSON file\r\n    return this.fitnessService.getRoutine()\r\n  }\r\n\r\n  /**\r\n   * Get workout definition for a specific day\r\n   * Checks active version in Supabase first, falls back to JSON file\r\n   */\r\n  async getWorkoutForDay(day: DayOfWeek, weekNumber?: number): Promise<Workout | null> {\r\n    // Try to get from active version in Supabase first\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getReadClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          const { data, error } = await clientAny\r\n            .from('fitness_routine_versions')\r\n            .select('workout_definitions')\r\n            .eq('routine_id', this.currentRoutineId)\r\n            .eq('is_active', true)\r\n            .single()\r\n\r\n          if (!error && data?.workout_definitions?.[day]) {\r\n            return data.workout_definitions[day] as Workout\r\n          }\r\n        } catch {\r\n          // Fall back to JSON file\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to JSON file\r\n    return this.fitnessService.getWorkoutForDay(day, weekNumber)\r\n  }\r\n\r\n  /**\r\n   * Get weekly progress\r\n   */\r\n  async getWeeklyProgress(weekNumber?: number): Promise<FitnessProgress> {\r\n    // For now, delegate to the service which handles the logic\r\n    // In the future, we could read directly from fitness_progress table\r\n    return this.fitnessService.getWeeklyProgress(weekNumber)\r\n  }\r\n\r\n  /**\r\n   * Get consistency stats\r\n   * Uses routine and workout definitions from Supabase (or JSON fallback) so it works in production.\r\n   */\r\n  async getConsistencyStats(): Promise<ConsistencyStats> {\r\n    const routine = await this.getRoutine()\r\n    if (!routine) {\r\n      throw new Error('No routine found')\r\n    }\r\n    const workoutDefinitions = await this.getWorkoutDefinitions(this.currentRoutineId)\r\n    return this.fitnessService.getConsistencyStatsForRoutine(routine, workoutDefinitions)\r\n  }\r\n\r\n  /**\r\n   * Mark a workout as complete\r\n   */\r\n  async markWorkoutComplete(\r\n    day: DayOfWeek,\r\n    weekNumber: number,\r\n    exercisesCompleted?: string[]\r\n  ): Promise<void> {\r\n    // Update via the service (which updates JSON)\r\n    await this.fitnessService.markWorkoutComplete(day, weekNumber, exercisesCompleted)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        await this.saveRoutineToSupabase(routine)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a daily routine (morning/night) as complete\r\n   */\r\n  async markRoutineComplete(\r\n    routineType: 'morning' | 'night',\r\n    day: DayOfWeek,\r\n    weekNumber: number\r\n  ): Promise<void> {\r\n    // Update via the service (which updates JSON)\r\n    await this.fitnessService.markRoutineComplete(routineType, day, weekNumber)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        await this.saveRoutineToSupabase(routine)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a daily routine as incomplete (undo)\r\n   */\r\n  async markRoutineIncomplete(\r\n    routineType: 'morning' | 'night',\r\n    day: DayOfWeek,\r\n    weekNumber: number\r\n  ): Promise<void> {\r\n    // Update via the service (which updates JSON)\r\n    await this.fitnessService.markRoutineIncomplete(routineType, day, weekNumber)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        await this.saveRoutineToSupabase(routine)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the routine\r\n   */\r\n  async updateRoutine(routine: WeeklyRoutine): Promise<WeeklyRoutine> {\r\n    // Update JSON file\r\n    const updated = await this.fitnessService.updateRoutine(routine)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      await this.saveRoutineToSupabase(updated)\r\n    }\r\n    \r\n    return updated\r\n  }\r\n\r\n  /**\r\n   * Sync routine from JSON file to Supabase\r\n   * Useful for initial data migration\r\n   */\r\n  async syncFromJsonToSupabase(): Promise<SyncResult> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    try {\r\n      const routine = await this.fetchFromService()\r\n      return this.saveRoutineToSupabase(routine)\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      return { success: false, recordsWritten: 0, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current week number\r\n   */\r\n  getCurrentWeekNumber(): number {\r\n    const now = new Date()\r\n    const startOfYear = new Date(now.getFullYear(), 0, 1)\r\n    const days = Math.floor((now.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000))\r\n    return Math.ceil((days + startOfYear.getDay() + 1) / 7)\r\n  }\r\n\r\n  /**\r\n   * Get current day of week\r\n   */\r\n  getCurrentDayOfWeek(): DayOfWeek {\r\n    const days: DayOfWeek[] = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']\r\n    return days[new Date().getDay()] ?? 'monday'\r\n  }\r\n\r\n  // ==========================================\r\n  // Version Management Methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get all versions for a routine\r\n   * Falls back to creating a virtual version from JSON files if Supabase is unavailable\r\n   */\r\n  async getVersions(routineId: string): Promise<VersionsListResponse> {\r\n    // Try Supabase first\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getReadClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          const { data, error } = await clientAny\r\n            .from('fitness_routine_versions')\r\n            .select('id, version_number, name, change_summary, is_active, is_draft, created_at, activated_at')\r\n            .eq('routine_id', routineId)\r\n            .order('version_number', { ascending: false })\r\n\r\n          if (!error && data && data.length > 0) {\r\n            const versions: RoutineVersionSummary[] = data.map((row: Partial<FitnessRoutineVersionRow>) => ({\r\n              id: row.id!,\r\n              versionNumber: row.version_number!,\r\n              name: row.name!,\r\n              changeSummary: row.change_summary ?? undefined,\r\n              isActive: row.is_active!,\r\n              isDraft: row.is_draft!,\r\n              createdAt: row.created_at!,\r\n              activatedAt: row.activated_at ?? undefined,\r\n            }))\r\n\r\n            const activeVersion = versions.find(v => v.isActive)\r\n            \r\n            // Only consider drafts newer than active version as \"the draft\"\r\n            // (older drafts are orphaned and should be cleaned up)\r\n            const activeVersionNum = activeVersion?.versionNumber ?? 0\r\n            const validDrafts = versions.filter(v => v.isDraft && v.versionNumber > activeVersionNum)\r\n            const draftVersion = validDrafts[0] // Newest draft (already sorted desc)\r\n\r\n            return { versions, activeVersion, draftVersion }\r\n          }\r\n        } catch (error) {\r\n          this.logError('Error fetching versions from Supabase', error)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to JSON files - create a virtual \"active\" version\r\n    try {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        const virtualVersion: RoutineVersionSummary = {\r\n          id: 'json-fallback',\r\n          versionNumber: 1,\r\n          name: routine.name,\r\n          changeSummary: 'Loaded from local files',\r\n          isActive: true,\r\n          isDraft: false,\r\n          createdAt: routine.updatedAt ?? new Date().toISOString(),\r\n        }\r\n        return { \r\n          versions: [virtualVersion], \r\n          activeVersion: virtualVersion,\r\n          draftVersion: undefined \r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error creating virtual version from JSON', error)\r\n    }\r\n\r\n    return { versions: [] }\r\n  }\r\n\r\n  /**\r\n   * Get a specific version by ID\r\n   * Handles the special 'json-fallback' ID for local file data\r\n   */\r\n  async getVersion(versionId: string): Promise<RoutineVersion | null> {\r\n    // Handle JSON fallback version\r\n    if (versionId === 'json-fallback') {\r\n      try {\r\n        const routine = await this.fitnessService.getRoutine()\r\n        const workoutDefinitions = await this.fitnessService.getWorkoutDefinitions()\r\n        \r\n        if (!routine) return null\r\n\r\n        return {\r\n          id: 'json-fallback',\r\n          routineId: this.currentRoutineId,\r\n          versionNumber: 1,\r\n          name: routine.name,\r\n          changeSummary: 'Loaded from local files',\r\n          userProfile: routine.userProfile,\r\n          injuryProtocol: routine.injuryProtocol,\r\n          schedule: routine.schedule,\r\n          dailyRoutines: routine.dailyRoutines,\r\n          workoutDefinitions,\r\n          isActive: true,\r\n          isDraft: false,\r\n          createdAt: routine.updatedAt ?? new Date().toISOString(),\r\n          updatedAt: routine.updatedAt ?? new Date().toISOString(),\r\n        }\r\n      } catch (error) {\r\n        this.logError('Error loading version from JSON files', error)\r\n        return null\r\n      }\r\n    }\r\n\r\n    // Try Supabase\r\n    if (!this.isSupabaseAvailable()) {\r\n      return null\r\n    }\r\n\r\n    const client = this.getReadClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .select('*')\r\n        .eq('id', versionId)\r\n        .single()\r\n\r\n      if (error || !data) return null\r\n\r\n      const row = data as FitnessRoutineVersionRow\r\n      return this.rowToVersion(row)\r\n    } catch (error) {\r\n      this.logError('Error fetching version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new version (draft by default)\r\n   * Uses retry logic to handle race conditions with version numbers\r\n   */\r\n  async createVersion(request: CreateVersionRequest, retryCount = 0): Promise<RoutineVersion | null> {\r\n    const MAX_RETRIES = 3\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      // Create version from current JSON files if Supabase not available\r\n      const routine = await this.fitnessService.getRoutine()\r\n      const workoutDefinitions = await this.fitnessService.getWorkoutDefinitions()\r\n      \r\n      if (!routine) return null\r\n\r\n      // Return a mock version object\r\n      return {\r\n        id: crypto.randomUUID(),\r\n        routineId: request.routineId,\r\n        versionNumber: 1,\r\n        name: request.name ?? routine.name,\r\n        changeSummary: request.changeSummary,\r\n        userProfile: routine.userProfile,\r\n        injuryProtocol: routine.injuryProtocol,\r\n        schedule: routine.schedule,\r\n        dailyRoutines: routine.dailyRoutines,\r\n        workoutDefinitions,\r\n        isActive: false,\r\n        isDraft: true,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      }\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // Get the latest version number using MAX aggregate for accuracy\r\n      const { data: versionData } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .select('version_number')\r\n        .eq('routine_id', request.routineId)\r\n        .order('version_number', { ascending: false })\r\n        .limit(1)\r\n\r\n      const maxVersion = versionData?.[0]?.version_number ?? 0\r\n      const nextVersionNumber = maxVersion + 1\r\n\r\n      // Get base data - either from specified version or current active\r\n      let baseData: RoutineVersion | null = null\r\n      if (request.basedOnVersionId) {\r\n        baseData = await this.getVersion(request.basedOnVersionId)\r\n      }\r\n\r\n      if (!baseData) {\r\n        // Get current active version or fall back to JSON files\r\n        const { data: activeData } = await clientAny\r\n          .from('fitness_routine_versions')\r\n          .select('*')\r\n          .eq('routine_id', request.routineId)\r\n          .eq('is_active', true)\r\n          .single()\r\n\r\n        if (activeData) {\r\n          baseData = this.rowToVersion(activeData as FitnessRoutineVersionRow)\r\n        } else {\r\n          // Fall back to JSON files\r\n          const routine = await this.fitnessService.getRoutine()\r\n          const workoutDefinitions = await this.fitnessService.getWorkoutDefinitions()\r\n          \r\n          if (!routine) return null\r\n\r\n          baseData = {\r\n            id: '',\r\n            routineId: request.routineId,\r\n            versionNumber: 0,\r\n            name: routine.name,\r\n            userProfile: routine.userProfile,\r\n            injuryProtocol: routine.injuryProtocol,\r\n            schedule: routine.schedule,\r\n            dailyRoutines: routine.dailyRoutines,\r\n            workoutDefinitions,\r\n            isActive: false,\r\n            isDraft: false,\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create new version\r\n      const insert: FitnessRoutineVersionInsert = {\r\n        routine_id: request.routineId,\r\n        version_number: nextVersionNumber,\r\n        name: request.name ?? `Version ${nextVersionNumber}`,\r\n        change_summary: request.changeSummary ?? undefined,\r\n        user_profile: baseData.userProfile,\r\n        injury_protocol: baseData.injuryProtocol ?? undefined,\r\n        schedule: baseData.schedule,\r\n        daily_routines: baseData.dailyRoutines,\r\n        workout_definitions: baseData.workoutDefinitions,\r\n        is_active: false,\r\n        is_draft: true,\r\n        updated_at: getCurrentTimestamp(),\r\n      }\r\n\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .insert(insert)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return this.rowToVersion(data as FitnessRoutineVersionRow)\r\n    } catch (error: unknown) {\r\n      // Check if it's a duplicate key error (code 23505)\r\n      const pgError = error as { code?: string }\r\n      if (pgError.code === '23505' && retryCount < MAX_RETRIES) {\r\n        this.log(`Duplicate version number, retrying (attempt ${retryCount + 1}/${MAX_RETRIES})`)\r\n        // Small delay before retry to reduce collision chance\r\n        await new Promise(resolve => setTimeout(resolve, 100 * (retryCount + 1)))\r\n        return this.createVersion(request, retryCount + 1)\r\n      }\r\n      \r\n      this.logError('Error creating version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a draft version\r\n   * Handles json-fallback by saving directly to JSON files\r\n   */\r\n  async updateVersion(versionId: string, updates: UpdateVersionRequest): Promise<RoutineVersion | null> {\r\n    // Handle JSON fallback version - save directly to files\r\n    if (versionId === 'json-fallback') {\r\n      try {\r\n        const routine = await this.fitnessService.getRoutine()\r\n        if (!routine) return null\r\n\r\n        // Update routine\r\n        if (updates.name !== undefined) routine.name = updates.name\r\n        if (updates.userProfile !== undefined) routine.userProfile = updates.userProfile\r\n        if (updates.injuryProtocol !== undefined) routine.injuryProtocol = updates.injuryProtocol\r\n        if (updates.schedule !== undefined) routine.schedule = updates.schedule\r\n        if (updates.dailyRoutines !== undefined) {\r\n          routine.dailyRoutines = {\r\n            morning: updates.dailyRoutines.morning ?? routine.dailyRoutines.morning,\r\n            night: updates.dailyRoutines.night ?? routine.dailyRoutines.night,\r\n          }\r\n        }\r\n        \r\n        await this.fitnessService.updateRoutine(routine)\r\n\r\n        // Update workout definitions if provided\r\n        if (updates.workoutDefinitions !== undefined) {\r\n          const currentDefs = await this.fitnessService.getWorkoutDefinitions()\r\n          const updatedDefs = { ...currentDefs, ...updates.workoutDefinitions }\r\n          await this.fitnessService.updateWorkoutDefinitions(updatedDefs)\r\n        }\r\n\r\n        // Return updated version\r\n        return this.getVersion('json-fallback')\r\n      } catch (error) {\r\n        this.logError('Error updating JSON fallback version', error)\r\n        return null\r\n      }\r\n    }\r\n\r\n    // Supabase path\r\n    if (!this.isSupabaseAvailable()) {\r\n      return null\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // First get the existing version to check if it's a draft\r\n      const existing = await this.getVersion(versionId)\r\n      if (!existing || !existing.isDraft) {\r\n        return null // Can only update drafts\r\n      }\r\n\r\n      // Build update object\r\n      const updateData: Partial<FitnessRoutineVersionInsert> = {\r\n        updated_at: getCurrentTimestamp(),\r\n      }\r\n\r\n      if (updates.name !== undefined) updateData.name = updates.name\r\n      if (updates.changeSummary !== undefined) updateData.change_summary = updates.changeSummary\r\n      if (updates.userProfile !== undefined) updateData.user_profile = updates.userProfile\r\n      if (updates.injuryProtocol !== undefined) updateData.injury_protocol = updates.injuryProtocol\r\n      if (updates.schedule !== undefined) updateData.schedule = updates.schedule\r\n      if (updates.dailyRoutines !== undefined) {\r\n        updateData.daily_routines = {\r\n          morning: updates.dailyRoutines.morning ?? existing.dailyRoutines.morning,\r\n          night: updates.dailyRoutines.night ?? existing.dailyRoutines.night,\r\n        }\r\n      }\r\n      if (updates.workoutDefinitions !== undefined) {\r\n        updateData.workout_definitions = {\r\n          ...existing.workoutDefinitions,\r\n          ...updates.workoutDefinitions,\r\n        }\r\n      }\r\n\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .update(updateData)\r\n        .eq('id', versionId)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return this.rowToVersion(data as FitnessRoutineVersionRow)\r\n    } catch (error) {\r\n      this.logError('Error updating version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate a version\r\n   */\r\n  async activateVersion(versionId: string): Promise<RoutineVersion | null> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return null\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // Get the version to activate\r\n      const version = await this.getVersion(versionId)\r\n      if (!version) return null\r\n\r\n      // Update to active (trigger will deactivate others)\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .update({\r\n          is_active: true,\r\n          is_draft: false,\r\n          activated_at: getCurrentTimestamp(),\r\n          updated_at: getCurrentTimestamp(),\r\n        })\r\n        .eq('id', versionId)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      // Sync to JSON files and main routine table\r\n      const activatedVersion = this.rowToVersion(data as FitnessRoutineVersionRow)\r\n      await this.syncVersionToFiles(activatedVersion)\r\n      await this.syncVersionToRoutineTable(activatedVersion)\r\n\r\n      return activatedVersion\r\n    } catch (error) {\r\n      this.logError('Error activating version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a draft version\r\n   */\r\n  async deleteVersion(versionId: string): Promise<boolean> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return false\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return false\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // First check if it's a draft (only drafts can be deleted)\r\n      const version = await this.getVersion(versionId)\r\n      if (!version || !version.isDraft) {\r\n        return false\r\n      }\r\n\r\n      const { error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .delete()\r\n        .eq('id', versionId)\r\n\r\n      return !error\r\n    } catch (error) {\r\n      this.logError('Error deleting version', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up duplicate/orphaned versions\r\n   * Keeps the active version and optionally the newest draft if it's newer\r\n   * Returns summary of what was cleaned up\r\n   */\r\n  async cleanupVersions(routineId: string): Promise<{\r\n    kept: { active?: string; draft?: string }\r\n    deleted: number\r\n    versions: { id: string; versionNumber: number; status: string }[]\r\n  }> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { kept: {}, deleted: 0, versions: [] }\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { kept: {}, deleted: 0, versions: [] }\r\n    }\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // Get all versions sorted by version_number descending\r\n      const { data: allVersions, error: fetchError } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .select('id, version_number, is_active, is_draft, name')\r\n        .eq('routine_id', routineId)\r\n        .order('version_number', { ascending: false })\r\n\r\n      if (fetchError || !allVersions) {\r\n        throw fetchError || new Error('Failed to fetch versions')\r\n      }\r\n\r\n      // Find active version\r\n      const activeVersion = allVersions.find((v: { is_active: boolean }) => v.is_active)\r\n      \r\n      // Find newest draft that's newer than active (or any draft if no active)\r\n      const activeVersionNum = activeVersion?.version_number ?? 0\r\n      const newerDrafts = allVersions.filter((v: { is_draft: boolean; version_number: number }) => \r\n        v.is_draft && v.version_number > activeVersionNum\r\n      )\r\n      const newestDraft = newerDrafts[0] // Already sorted desc\r\n\r\n      // Determine what to keep\r\n      const keepIds = new Set<string>()\r\n      if (activeVersion) keepIds.add(activeVersion.id)\r\n      if (newestDraft) keepIds.add(newestDraft.id)\r\n\r\n      // If nothing to keep, keep the newest version\r\n      if (keepIds.size === 0 && allVersions.length > 0) {\r\n        keepIds.add(allVersions[0].id)\r\n      }\r\n\r\n      // Delete everything else\r\n      const toDelete = allVersions.filter((v: { id: string }) => !keepIds.has(v.id))\r\n      \r\n      if (toDelete.length > 0) {\r\n        const deleteIds = toDelete.map((v: { id: string }) => v.id)\r\n        const { error: deleteError } = await clientAny\r\n          .from('fitness_routine_versions')\r\n          .delete()\r\n          .in('id', deleteIds)\r\n\r\n        if (deleteError) {\r\n          this.logError('Error deleting versions during cleanup', deleteError)\r\n        }\r\n      }\r\n\r\n      // Return summary\r\n      const keptVersions = allVersions.filter((v: { id: string }) => keepIds.has(v.id))\r\n      return {\r\n        kept: {\r\n          active: activeVersion?.id,\r\n          draft: newestDraft?.id,\r\n        },\r\n        deleted: toDelete.length,\r\n        versions: keptVersions.map((v: { id: string; version_number: number; is_active: boolean; is_draft: boolean }) => ({\r\n          id: v.id,\r\n          versionNumber: v.version_number,\r\n          status: v.is_active ? 'active' : v.is_draft ? 'draft' : 'inactive',\r\n        })),\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error cleaning up versions', error)\r\n      return { kept: {}, deleted: 0, versions: [] }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // Workout Definitions Methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get workout definitions for a routine\r\n   */\r\n  async getWorkoutDefinitions(routineId: string): Promise<Record<DayOfWeek, Workout>> {\r\n    // First try to get from active version in Supabase\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getReadClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          const { data, error } = await clientAny\r\n            .from('fitness_routine_versions')\r\n            .select('workout_definitions')\r\n            .eq('routine_id', routineId)\r\n            .eq('is_active', true)\r\n            .single()\r\n\r\n          if (!error && data?.workout_definitions) {\r\n            return data.workout_definitions as Record<DayOfWeek, Workout>\r\n          }\r\n        } catch {\r\n          // Fall back to JSON files\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to JSON files\r\n    return this.fitnessService.getWorkoutDefinitions()\r\n  }\r\n\r\n  /**\r\n   * Update all workout definitions for a routine\r\n   */\r\n  async updateWorkoutDefinitions(\r\n    routineId: string,\r\n    definitions: Record<DayOfWeek, Workout>\r\n  ): Promise<Record<DayOfWeek, Workout>> {\r\n    // Update JSON file\r\n    await this.fitnessService.updateWorkoutDefinitions(definitions)\r\n\r\n    // Update active version if Supabase is available\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getWriteClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          await clientAny\r\n            .from('fitness_routine_versions')\r\n            .update({\r\n              workout_definitions: definitions,\r\n              updated_at: getCurrentTimestamp(),\r\n            })\r\n            .eq('routine_id', routineId)\r\n            .eq('is_active', true)\r\n        } catch (error) {\r\n          this.logError('Error updating workout definitions in Supabase', error)\r\n        }\r\n      }\r\n    }\r\n\r\n    return definitions\r\n  }\r\n\r\n  /**\r\n   * Update workout definition for a specific day\r\n   */\r\n  async updateWorkoutDefinition(\r\n    routineId: string,\r\n    day: DayOfWeek,\r\n    workout: Workout\r\n  ): Promise<Workout> {\r\n    const definitions = await this.getWorkoutDefinitions(routineId)\r\n    definitions[day] = workout\r\n    await this.updateWorkoutDefinitions(routineId, definitions)\r\n    return workout\r\n  }\r\n\r\n  // ==========================================\r\n  // Helper Methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Convert database row to RoutineVersion\r\n   */\r\n  private rowToVersion(row: FitnessRoutineVersionRow): RoutineVersion {\r\n    return {\r\n      id: row.id,\r\n      routineId: row.routine_id,\r\n      versionNumber: row.version_number,\r\n      name: row.name,\r\n      changeSummary: row.change_summary ?? undefined,\r\n      userProfile: row.user_profile,\r\n      injuryProtocol: row.injury_protocol ?? undefined,\r\n      schedule: row.schedule,\r\n      dailyRoutines: row.daily_routines,\r\n      workoutDefinitions: row.workout_definitions,\r\n      isActive: row.is_active,\r\n      isDraft: row.is_draft,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      activatedAt: row.activated_at ?? undefined,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sync activated version to JSON files\r\n   */\r\n  private async syncVersionToFiles(version: RoutineVersion): Promise<void> {\r\n    try {\r\n      // Update routine file\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        routine.name = version.name\r\n        routine.userProfile = version.userProfile\r\n        routine.injuryProtocol = version.injuryProtocol ?? routine.injuryProtocol\r\n        routine.schedule = version.schedule\r\n        routine.dailyRoutines = version.dailyRoutines\r\n        await this.fitnessService.updateRoutine(routine)\r\n      }\r\n\r\n      // Update workout definitions file\r\n      await this.fitnessService.updateWorkoutDefinitions(version.workoutDefinitions)\r\n    } catch (error) {\r\n      this.logError('Error syncing version to files', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sync activated version to fitness_routines table\r\n   */\r\n  private async syncVersionToRoutineTable(version: RoutineVersion): Promise<void> {\r\n    if (!this.isSupabaseAvailable()) return\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      await clientAny\r\n        .from('fitness_routines')\r\n        .upsert({\r\n          id: version.routineId,\r\n          name: version.name,\r\n          user_profile: version.userProfile,\r\n          injury_protocol: version.injuryProtocol,\r\n          schedule: version.schedule,\r\n          daily_routines: version.dailyRoutines,\r\n          updated_at: getCurrentTimestamp(),\r\n        }, { onConflict: 'id' })\r\n    } catch (error) {\r\n      this.logError('Error syncing version to routine table', error)\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet fitnessAdapterInstance: FitnessAdapter | null = null\r\n\r\nexport function getFitnessAdapter(): FitnessAdapter {\r\n  if (!fitnessAdapterInstance) {\r\n    fitnessAdapterInstance = new FitnessAdapter()\r\n  }\r\n  return fitnessAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4163, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/cta.service.ts"],"sourcesContent":["/**\r\n * CTA Transit Service\r\n * Handles communication with Chicago Transit Authority APIs\r\n */\r\n\r\nimport axios from \"axios\"\r\nimport { config } from \"@/lib/config\"\r\nimport type {\r\n  CTABusResponse,\r\n  CTATrainResponse,\r\n  CTARouteConfig,\r\n  CTABusStopsResponse,\r\n} from \"@/lib/types/cta.types\"\r\n\r\nexport class CTAService {\r\n  private busApiUrl = \"http://www.ctabustracker.com/bustime/api/v2\"\r\n  private trainApiUrl = \"http://lapi.transitchicago.com/api/1.0\"\r\n\r\n  isConfigured(): boolean {\r\n    return Boolean(config.cta.apiKey)\r\n  }\r\n\r\n  /**\r\n   * Get bus predictions for a route and stop\r\n   */\r\n  async getBusPredictions(route: string, stopId: string): Promise<CTABusResponse> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"CTA API key not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<CTABusResponse>(`${this.busApiUrl}/getpredictions`, {\r\n        params: {\r\n          key: config.cta.apiKey,\r\n          rt: route,\r\n          stpid: stopId,\r\n          format: \"json\",\r\n        },\r\n      })\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`CTA Bus API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get train predictions for a line and station\r\n   */\r\n  async getTrainPredictions(line: string, stationId: string): Promise<CTATrainResponse> {\r\n    if (!config.cta.isTrainConfigured) {\r\n      throw new Error(\"CTA Train API key not configured\")\r\n    }\r\n\r\n    try {\r\n      // Use mapid to get all trains at the station, then filter by route client-side\r\n      const response = await axios.get<CTATrainResponse>(`${this.trainApiUrl}/ttarrivals.aspx`, {\r\n        params: {\r\n          key: config.cta.trainApiKey,\r\n          mapid: stationId,\r\n          rt: line, // Filter by route (Brn for Brown, P for Purple)\r\n          outputType: \"JSON\",\r\n        },\r\n      })\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`CTA Train API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get stops for a route and direction\r\n   */\r\n  async getStops(route: string, direction: string): Promise<CTABusStopsResponse> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"CTA API key not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<CTABusStopsResponse>(`${this.busApiUrl}/getstops`, {\r\n        params: {\r\n          key: config.cta.apiKey,\r\n          rt: route,\r\n          dir: direction,\r\n          format: \"json\",\r\n        },\r\n      })\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`CTA Bus Stops API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find a stop ID by route, direction, and stop name (partial match)\r\n   */\r\n  async findStopId(route: string, direction: string, stopName: string): Promise<string | null> {\r\n    try {\r\n      const stopsResponse = await this.getStops(route, direction)\r\n      const stops = stopsResponse[\"bustime-response\"]?.stops || []\r\n\r\n      // Search for stop by name (case-insensitive, partial match)\r\n      const stopNameLower = stopName.toLowerCase()\r\n      const stop = stops.find((s) => s.stpnm.toLowerCase().includes(stopNameLower))\r\n\r\n      return stop?.stpid || null\r\n    } catch (error) {\r\n      console.error(`Error finding stop ID for ${route} ${direction} at ${stopName}:`, error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all configured routes at once\r\n   * Routes: 76, 36, 22 buses, Brown and Purple Lines southbound\r\n   */\r\n  async getAllRoutes(config: CTARouteConfig): Promise<{\r\n    bus: Record<string, CTABusResponse>\r\n    train: Record<string, CTATrainResponse>\r\n  }> {\r\n    const busPromises = config.bus.map(async (route) => {\r\n      try {\r\n        const predictions = await this.getBusPredictions(route.route, route.stopId)\r\n        // Check if the response contains an error\r\n        if (predictions[\"bustime-response\"]?.error) {\r\n          const errorMsg = predictions[\"bustime-response\"].error[0]?.msg || \"Unknown error\"\r\n          console.error(\r\n            `Route ${route.route} (${route.direction}) stop ${route.stopId}: ${errorMsg}. ` +\r\n              `Use /api/cta/bus/stops?route=${route.route}&direction=${route.direction} to find correct stop ID.`\r\n          )\r\n        }\r\n        return { route: route.route, data: predictions }\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : \"Unknown error\"\r\n        console.error(`Route ${route.route} (${route.direction}) stop ${route.stopId}: ${errorMsg}`)\r\n        return { route: route.route, data: null, error: errorMsg }\r\n      }\r\n    })\r\n\r\n    const busResults = await Promise.all(busPromises)\r\n    const busData: Record<string, CTABusResponse> = {}\r\n    busResults.forEach((result) => {\r\n      if (result.data) {\r\n        busData[result.route] = result.data\r\n      } else {\r\n        // Include error in response for debugging\r\n        busData[result.route] = {\r\n          \"bustime-response\": {\r\n            error: [\r\n              {\r\n                rt: result.route,\r\n                msg: result.error || \"Failed to fetch predictions\",\r\n              },\r\n            ],\r\n          },\r\n        }\r\n      }\r\n    })\r\n\r\n    const trainPromises = config.train.map(async (trainConfig) => {\r\n      try {\r\n        const predictions = await this.getTrainPredictions(trainConfig.line, trainConfig.stationId)\r\n        return { line: trainConfig.line, data: predictions }\r\n      } catch (error) {\r\n        const errorMsg = error instanceof Error ? error.message : \"Unknown error\"\r\n        console.error(`Train ${trainConfig.line} station ${trainConfig.stationId}: ${errorMsg}`)\r\n        return { line: trainConfig.line, data: null, error: errorMsg }\r\n      }\r\n    })\r\n\r\n    const trainResults = await Promise.all(trainPromises)\r\n    const trainData: Record<string, CTATrainResponse> = {}\r\n    trainResults.forEach((result) => {\r\n      if (result.data) {\r\n        trainData[result.line] = result.data\r\n      } else {\r\n        // Include error in response for debugging\r\n        trainData[result.line] = {\r\n          ctatt: {\r\n            tmst: new Date().toISOString(),\r\n            errCd: \"1\",\r\n            errNm: result.error || \"Failed to fetch predictions\",\r\n            eta: [],\r\n          },\r\n        }\r\n      }\r\n    })\r\n\r\n    return { bus: busData, train: trainData }\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED;AACA;;;AAQO,MAAM;IACH,YAAY,8CAA6C;IACzD,cAAc,yCAAwC;IAE9D,eAAwB;QACtB,OAAO,QAAQ,yHAAM,CAAC,GAAG,CAAC,MAAM;IAClC;IAEA;;GAEC,GACD,MAAM,kBAAkB,KAAa,EAAE,MAAc,EAA2B;QAC9E,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI;YACxB,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI;YACF,MAAM,WAAW,MAAM,kJAAK,CAAC,GAAG,CAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,EAAE;gBACnF,QAAQ;oBACN,KAAK,yHAAM,CAAC,GAAG,CAAC,MAAM;oBACtB,IAAI;oBACJ,OAAO;oBACP,QAAQ;gBACV;YACF;YACA,OAAO,SAAS,IAAI;QACtB,EAAE,OAAO,OAAO;YACd,IAAI,kJAAK,CAAC,YAAY,CAAC,QAAQ;gBAC7B,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE,MAAM,OAAO,EAAE;YACvD;YACA,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,oBAAoB,IAAY,EAAE,SAAiB,EAA6B;QACpF,IAAI,CAAC,yHAAM,CAAC,GAAG,CAAC,iBAAiB,EAAE;YACjC,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI;YACF,+EAA+E;YAC/E,MAAM,WAAW,MAAM,kJAAK,CAAC,GAAG,CAAmB,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,EAAE;gBACxF,QAAQ;oBACN,KAAK,yHAAM,CAAC,GAAG,CAAC,WAAW;oBAC3B,OAAO;oBACP,IAAI;oBACJ,YAAY;gBACd;YACF;YACA,OAAO,SAAS,IAAI;QACtB,EAAE,OAAO,OAAO;YACd,IAAI,kJAAK,CAAC,YAAY,CAAC,QAAQ;gBAC7B,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,MAAM,OAAO,EAAE;YACzD;YACA,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,SAAS,KAAa,EAAE,SAAiB,EAAgC;QAC7E,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI;YACxB,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI;YACF,MAAM,WAAW,MAAM,kJAAK,CAAC,GAAG,CAAsB,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE;gBAClF,QAAQ;oBACN,KAAK,yHAAM,CAAC,GAAG,CAAC,MAAM;oBACtB,IAAI;oBACJ,KAAK;oBACL,QAAQ;gBACV;YACF;YACA,OAAO,SAAS,IAAI;QACtB,EAAE,OAAO,OAAO;YACd,IAAI,kJAAK,CAAC,YAAY,CAAC,QAAQ;gBAC7B,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,MAAM,OAAO,EAAE;YAC7D;YACA,MAAM;QACR;IACF;IAEA;;GAEC,GACD,MAAM,WAAW,KAAa,EAAE,SAAiB,EAAE,QAAgB,EAA0B;QAC3F,IAAI;YACF,MAAM,gBAAgB,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO;YACjD,MAAM,QAAQ,aAAa,CAAC,mBAAmB,EAAE,SAAS,EAAE;YAE5D,4DAA4D;YAC5D,MAAM,gBAAgB,SAAS,WAAW;YAC1C,MAAM,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,CAAC,WAAW,GAAG,QAAQ,CAAC;YAE9D,OAAO,MAAM,SAAS;QACxB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,MAAM,CAAC,EAAE,UAAU,IAAI,EAAE,SAAS,CAAC,CAAC,EAAE;YACjF,OAAO;QACT;IACF;IAEA;;;GAGC,GACD,MAAM,aAAa,MAAsB,EAGtC;QACD,MAAM,cAAc,OAAO,GAAG,CAAC,GAAG,CAAC,OAAO;YACxC,IAAI;gBACF,MAAM,cAAc,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,KAAK,EAAE,MAAM,MAAM;gBAC1E,0CAA0C;gBAC1C,IAAI,WAAW,CAAC,mBAAmB,EAAE,OAAO;oBAC1C,MAAM,WAAW,WAAW,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAE,EAAE,OAAO;oBAClE,QAAQ,KAAK,CACX,CAAC,MAAM,EAAE,MAAM,KAAK,CAAC,EAAE,EAAE,MAAM,SAAS,CAAC,OAAO,EAAE,MAAM,MAAM,CAAC,EAAE,EAAE,SAAS,EAAE,CAAC,GAC7E,CAAC,6BAA6B,EAAE,MAAM,KAAK,CAAC,WAAW,EAAE,MAAM,SAAS,CAAC,yBAAyB,CAAC;gBAEzG;gBACA,OAAO;oBAAE,OAAO,MAAM,KAAK;oBAAE,MAAM;gBAAY;YACjD,EAAE,OAAO,OAAO;gBACd,MAAM,WAAW,iBAAiB,QAAQ,MAAM,OAAO,GAAG;gBAC1D,QAAQ,KAAK,CAAC,CAAC,MAAM,EAAE,MAAM,KAAK,CAAC,EAAE,EAAE,MAAM,SAAS,CAAC,OAAO,EAAE,MAAM,MAAM,CAAC,EAAE,EAAE,UAAU;gBAC3F,OAAO;oBAAE,OAAO,MAAM,KAAK;oBAAE,MAAM;oBAAM,OAAO;gBAAS;YAC3D;QACF;QAEA,MAAM,aAAa,MAAM,QAAQ,GAAG,CAAC;QACrC,MAAM,UAA0C,CAAC;QACjD,WAAW,OAAO,CAAC,CAAC;YAClB,IAAI,OAAO,IAAI,EAAE;gBACf,OAAO,CAAC,OAAO,KAAK,CAAC,GAAG,OAAO,IAAI;YACrC,OAAO;gBACL,0CAA0C;gBAC1C,OAAO,CAAC,OAAO,KAAK,CAAC,GAAG;oBACtB,oBAAoB;wBAClB,OAAO;4BACL;gCACE,IAAI,OAAO,KAAK;gCAChB,KAAK,OAAO,KAAK,IAAI;4BACvB;yBACD;oBACH;gBACF;YACF;QACF;QAEA,MAAM,gBAAgB,OAAO,KAAK,CAAC,GAAG,CAAC,OAAO;YAC5C,IAAI;gBACF,MAAM,cAAc,MAAM,IAAI,CAAC,mBAAmB,CAAC,YAAY,IAAI,EAAE,YAAY,SAAS;gBAC1F,OAAO;oBAAE,MAAM,YAAY,IAAI;oBAAE,MAAM;gBAAY;YACrD,EAAE,OAAO,OAAO;gBACd,MAAM,WAAW,iBAAiB,QAAQ,MAAM,OAAO,GAAG;gBAC1D,QAAQ,KAAK,CAAC,CAAC,MAAM,EAAE,YAAY,IAAI,CAAC,SAAS,EAAE,YAAY,SAAS,CAAC,EAAE,EAAE,UAAU;gBACvF,OAAO;oBAAE,MAAM,YAAY,IAAI;oBAAE,MAAM;oBAAM,OAAO;gBAAS;YAC/D;QACF;QAEA,MAAM,eAAe,MAAM,QAAQ,GAAG,CAAC;QACvC,MAAM,YAA8C,CAAC;QACrD,aAAa,OAAO,CAAC,CAAC;YACpB,IAAI,OAAO,IAAI,EAAE;gBACf,SAAS,CAAC,OAAO,IAAI,CAAC,GAAG,OAAO,IAAI;YACtC,OAAO;gBACL,0CAA0C;gBAC1C,SAAS,CAAC,OAAO,IAAI,CAAC,GAAG;oBACvB,OAAO;wBACL,MAAM,IAAI,OAAO,WAAW;wBAC5B,OAAO;wBACP,OAAO,OAAO,KAAK,IAAI;wBACvB,KAAK,EAAE;oBACT;gBACF;YACF;QACF;QAEA,OAAO;YAAE,KAAK;YAAS,OAAO;QAAU;IAC1C;AACF"}},
    {"offset": {"line": 4354, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/cta.adapter.ts"],"sourcesContent":["/**\r\n * CTA Adapter\r\n * Handles Chicago Transit Authority data with historical recording\r\n * \r\n * CTA data is always fetched from the real API when available (public API).\r\n * Supabase is used for historical data storage and as a fallback.\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp, AVAILABILITY_CHECK_TIMEOUT } from './base.adapter'\r\nimport { CTAService } from '@/lib/services/cta.service'\r\nimport type {\r\n  CTABusResponse,\r\n  CTATrainResponse,\r\n  CTARouteConfig,\r\n  CTABusPrediction,\r\n} from '@/lib/types/cta.types'\r\nimport type { CTAHistoryRow, CTAHistoryInsert } from '@/lib/supabase/types'\r\n\r\nexport interface CTAFullState {\r\n  bus: Record<string, CTABusResponse>\r\n  train: Record<string, CTATrainResponse>\r\n}\r\n\r\nexport interface CTACachedState {\r\n  bus: Record<string, CTABusResponse>\r\n  train: Record<string, CTATrainResponse>\r\n  recordedAt: string\r\n}\r\n\r\n// Default route configuration\r\nconst DEFAULT_ROUTE_CONFIG: CTARouteConfig = {\r\n  bus: [\r\n    { route: '76', stopId: '11031', direction: 'Eastbound' },\r\n    { route: '22', stopId: '18173', direction: 'Southbound' },\r\n    { route: '36', stopId: '18173', direction: 'Southbound' },\r\n  ],\r\n  train: [\r\n    { line: 'Brn', stationId: '40530', direction: 'Southbound' },\r\n    { line: 'P', stationId: '40530', direction: 'Southbound' },\r\n  ],\r\n}\r\n\r\n/**\r\n * CTA Adapter - manages transit prediction data\r\n * \r\n * Note: CTA is a public API, so we always try to fetch from it\r\n * regardless of \"local mode\". Supabase is used for historical\r\n * data storage and as a fallback.\r\n */\r\nexport class CTAAdapter extends BaseAdapter<CTAFullState, CTACachedState> {\r\n  private ctaService: CTAService\r\n  private routeConfig: CTARouteConfig\r\n\r\n  constructor(routeConfig?: CTARouteConfig, debug: boolean = false) {\r\n    super({ serviceName: 'cta', debug })\r\n    this.ctaService = new CTAService()\r\n    this.routeConfig = routeConfig ?? DEFAULT_ROUTE_CONFIG\r\n  }\r\n\r\n  /**\r\n   * Check if CTA service is configured (has API key)\r\n   */\r\n  isConfigured(): boolean {\r\n    return this.ctaService.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Check if CTA API is reachable\r\n   * Since CTA is a public API, this always returns true if configured\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    // CTA is a public API - always available if configured\r\n    // The actual reachability is handled per-request with fallback to cache\r\n    return this.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Update the route configuration\r\n   */\r\n  setRouteConfig(config: CTARouteConfig): void {\r\n    this.routeConfig = config\r\n  }\r\n\r\n  /**\r\n   * Fetch all CTA data from the API\r\n   */\r\n  protected async fetchFromService(): Promise<CTAFullState> {\r\n    return this.ctaService.getAllRoutes(this.routeConfig)\r\n  }\r\n\r\n  /**\r\n   * Fetch cached CTA data from Supabase (historical)\r\n   */\r\n  protected async fetchFromCache(): Promise<CTACachedState | null> {\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      // Get the most recent records for each route\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const { data, error } = await (client.from('cta_history') as any)\r\n        .select('*')\r\n        .order('recorded_at', { ascending: false })\r\n        .limit(20) // Get recent history\r\n\r\n      if (error) throw error\r\n      if (!data || data.length === 0) return null\r\n\r\n      const rows = data as CTAHistoryRow[]\r\n\r\n      // Group by route and take the latest for each\r\n      const busMap = new Map<string, CTAHistoryRow>()\r\n      const trainMap = new Map<string, CTAHistoryRow>()\r\n\r\n      for (const row of rows) {\r\n        if (row.route_type === 'bus' && !busMap.has(row.route)) {\r\n          busMap.set(row.route, row)\r\n        } else if (row.route_type === 'train' && !trainMap.has(row.route)) {\r\n          trainMap.set(row.route, row)\r\n        }\r\n      }\r\n\r\n      // Convert to response format\r\n      const bus: Record<string, CTABusResponse> = {}\r\n      for (const [route, row] of busMap) {\r\n        if (row.error_message) {\r\n          bus[route] = {\r\n            'bustime-response': {\r\n              error: [{ rt: route, msg: row.error_message }],\r\n            },\r\n          }\r\n        } else {\r\n          bus[route] = {\r\n            'bustime-response': {\r\n              prd: row.predictions as CTABusPrediction[] ?? [],\r\n            },\r\n          }\r\n        }\r\n      }\r\n\r\n      const train: Record<string, CTATrainResponse> = {}\r\n      for (const [line, row] of trainMap) {\r\n        if (row.error_message) {\r\n          train[line] = {\r\n            ctatt: {\r\n              tmst: row.recorded_at,\r\n              errCd: '1',\r\n              errNm: row.error_message,\r\n              eta: [],\r\n            },\r\n          }\r\n        } else {\r\n          train[line] = {\r\n            ctatt: {\r\n              tmst: row.recorded_at,\r\n              errCd: '0',\r\n              errNm: null,\r\n              eta: (row.predictions as CTATrainResponse['ctatt']['eta']) ?? [],\r\n            },\r\n          }\r\n        }\r\n      }\r\n\r\n      const recordedAt = rows[0]?.recorded_at ?? new Date().toISOString()\r\n\r\n      return { bus, train, recordedAt }\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write CTA data to Supabase history\r\n   */\r\n  protected async writeToCache(data: CTAFullState): Promise<SyncResult> {\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    const timestamp = getCurrentTimestamp()\r\n    let recordsWritten = 0\r\n\r\n    try {\r\n      const inserts: CTAHistoryInsert[] = []\r\n\r\n      // Add bus predictions\r\n      for (const [route, response] of Object.entries(data.bus)) {\r\n        const config = this.routeConfig.bus.find(b => b.route === route)\r\n        const error = response['bustime-response']?.error?.[0]\r\n        \r\n        inserts.push({\r\n          route_type: 'bus',\r\n          route,\r\n          stop_id: config?.stopId ?? null,\r\n          station_id: null,\r\n          direction: config?.direction ?? null,\r\n          predictions: error ? null : response['bustime-response']?.prd ?? [],\r\n          error_message: error?.msg ?? null,\r\n          recorded_at: timestamp,\r\n        })\r\n      }\r\n\r\n      // Add train predictions\r\n      for (const [line, response] of Object.entries(data.train)) {\r\n        const config = this.routeConfig.train.find(t => t.line === line)\r\n        const hasError = response.ctatt?.errCd !== '0'\r\n        \r\n        inserts.push({\r\n          route_type: 'train',\r\n          route: line,\r\n          stop_id: null,\r\n          station_id: config?.stationId ?? null,\r\n          direction: config?.direction ?? null,\r\n          predictions: hasError ? null : response.ctatt?.eta ?? [],\r\n          error_message: hasError ? response.ctatt?.errNm : null,\r\n          recorded_at: timestamp,\r\n        })\r\n      }\r\n\r\n      if (inserts.length > 0) {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const { error } = await (client.from('cta_history') as any).insert(inserts)\r\n        if (error) throw error\r\n        recordsWritten = inserts.length\r\n      }\r\n\r\n      return { success: true, recordsWritten }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error writing to cache', error)\r\n      return { success: false, recordsWritten, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get all routes data\r\n   * Always tries to fetch from CTA API first (it's a public API)\r\n   */\r\n  async getAllRoutes(config?: CTARouteConfig): Promise<CTAFullState> {\r\n    const routeConfig = config ?? this.routeConfig\r\n\r\n    try {\r\n      // Always try to fetch from real API first\r\n      const data = await this.ctaService.getAllRoutes(routeConfig)\r\n      \r\n      // Write to history in background\r\n      if (this.isSupabaseAvailable()) {\r\n        this.writeToCache(data)\r\n          .catch(err => this.logError('Failed to record CTA history', err))\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from CTA API', error)\r\n      \r\n      // Fall back to cached data if available\r\n      if (this.isSupabaseAvailable()) {\r\n        const cached = await this.fetchFromCache()\r\n        if (cached) {\r\n          this.log('Using cached CTA data')\r\n          return { bus: cached.bus, train: cached.train }\r\n        }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get bus predictions for a specific route\r\n   */\r\n  async getBusPredictions(route: string, stopId: string): Promise<CTABusResponse> {\r\n    try {\r\n      const response = await this.ctaService.getBusPredictions(route, stopId)\r\n      \r\n      // Record in history (only if Supabase is configured)\r\n      if (this.isSupabaseAvailable()) {\r\n        const client = this.getWriteClient()\r\n        if (client) {\r\n          const timestamp = getCurrentTimestamp()\r\n          const error = response['bustime-response']?.error?.[0]\r\n          \r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          ;(client.from('cta_history') as any).insert({\r\n            route_type: 'bus',\r\n            route,\r\n            stop_id: stopId,\r\n            predictions: error ? null : response['bustime-response']?.prd ?? [],\r\n            error_message: error?.msg ?? null,\r\n            recorded_at: timestamp,\r\n          }).then(({ error: insertError }: { error: unknown }) => {\r\n            if (insertError) this.logError('Failed to record bus prediction', insertError)\r\n          })\r\n        }\r\n      }\r\n\r\n      return response\r\n    } catch (error) {\r\n      this.logError('Error fetching bus predictions', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get train predictions for a specific line\r\n   */\r\n  async getTrainPredictions(line: string, stationId: string): Promise<CTATrainResponse> {\r\n    try {\r\n      const response = await this.ctaService.getTrainPredictions(line, stationId)\r\n      \r\n      // Record in history (only if Supabase is configured)\r\n      if (this.isSupabaseAvailable()) {\r\n        const client = this.getWriteClient()\r\n        if (client) {\r\n          const timestamp = getCurrentTimestamp()\r\n          const hasError = response.ctatt?.errCd !== '0'\r\n          \r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          ;(client.from('cta_history') as any).insert({\r\n            route_type: 'train',\r\n            route: line,\r\n            station_id: stationId,\r\n            predictions: hasError ? null : response.ctatt?.eta ?? [],\r\n            error_message: hasError ? response.ctatt?.errNm : null,\r\n            recorded_at: timestamp,\r\n          }).then(({ error: insertError }: { error: unknown }) => {\r\n            if (insertError) this.logError('Failed to record train prediction', insertError)\r\n          })\r\n        }\r\n      }\r\n\r\n      return response\r\n    } catch (error) {\r\n      this.logError('Error fetching train predictions', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get historical CTA data for analysis\r\n   */\r\n  async getHistory(options?: {\r\n    route?: string\r\n    routeType?: 'bus' | 'train'\r\n    limit?: number\r\n    startDate?: Date\r\n    endDate?: Date\r\n  }): Promise<CTAHistoryRow[]> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return []\r\n    }\r\n\r\n    const client = this.getReadClient()\r\n    if (!client) return [] // Supabase not configured\r\n    \r\n    let query = client\r\n      .from('cta_history')\r\n      .select('*')\r\n      .order('recorded_at', { ascending: false })\r\n\r\n    if (options?.route) {\r\n      query = query.eq('route', options.route)\r\n    }\r\n    if (options?.routeType) {\r\n      query = query.eq('route_type', options.routeType)\r\n    }\r\n    if (options?.startDate) {\r\n      query = query.gte('recorded_at', options.startDate.toISOString())\r\n    }\r\n    if (options?.endDate) {\r\n      query = query.lte('recorded_at', options.endDate.toISOString())\r\n    }\r\n\r\n    query = query.limit(options?.limit ?? 100)\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) {\r\n      this.logError('Error fetching CTA history', error)\r\n      return []\r\n    }\r\n\r\n    return (data ?? []) as CTAHistoryRow[]\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet ctaAdapterInstance: CTAAdapter | null = null\r\n\r\nexport function getCTAAdapter(): CTAAdapter {\r\n  if (!ctaAdapterInstance) {\r\n    ctaAdapterInstance = new CTAAdapter()\r\n  }\r\n  return ctaAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4777, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/calendar.service.ts"],"sourcesContent":["/**\n * Google Calendar Service\n * Handles communication with Google Calendar API\n */\n\nimport { google } from \"googleapis\"\nimport { cookies } from \"next/headers\"\nimport { config } from \"@/lib/config\"\nimport type { CalendarEvent, CalendarEventsResponse } from \"@/lib/types/calendar.types\"\nimport { getGoogleCalendarTokens, setGoogleCalendarTokens, clearGoogleCalendarTokens } from \"./token-storage\"\n\n/**\n * Helper function to load tokens and set them on the calendar service\n * First checks file-based storage (for cross-origin requests from pete.sh)\n * Falls back to cookies (for same-origin requests)\n * Proactively refreshes access token if missing or expired but refresh token exists\n */\nexport async function loadCalendarTokensFromCookies(\n  calendarService: CalendarService\n): Promise<{ accessToken: string | null; refreshToken: string | null }> {\n  // First try file-based storage (works for cross-origin requests)\n  const fileTokens = getGoogleCalendarTokens()\n  \n  // Fall back to cookies if file storage is empty\n  const cookieStore = await cookies()\n  const cookieAccessToken = cookieStore.get(\"google_calendar_access_token\")?.value || null\n  const cookieRefreshToken = cookieStore.get(\"google_calendar_refresh_token\")?.value || null\n  \n  // Use file tokens if available, otherwise use cookies\n  let accessToken = fileTokens.accessToken || cookieAccessToken\n  const refreshToken = fileTokens.refreshToken || cookieRefreshToken\n\n  // Debug logging disabled - uncomment if needed\n  // console.log(\"[CalendarService] Loading tokens:\", {\n  //   fromFile: { hasAccessToken: !!fileTokens.accessToken, hasRefreshToken: !!fileTokens.refreshToken },\n  //   fromCookies: { hasAccessToken: !!cookieAccessToken, hasRefreshToken: !!cookieRefreshToken },\n  //   using: { hasAccessToken: !!accessToken, hasRefreshToken: !!refreshToken },\n  // })\n\n  // If we have a refresh token but no access token (or access token expired), refresh it\n  if (refreshToken && !accessToken) {\n    // console.log(\"[CalendarService] Access token missing, attempting to refresh\")\n    try {\n      // Set just the refresh token first\n      calendarService.setCredentials({\n        access_token: \"placeholder\", // Needs something to initialize\n        refresh_token: refreshToken,\n      })\n\n      // Refresh the access token using the public method\n      const updatedCredentials = await calendarService.refreshAccessToken()\n      accessToken = updatedCredentials.access_token || null\n\n      // console.log(\"[CalendarService] Refresh result:\", { gotAccessToken: !!accessToken })\n\n      // Update tokens in both file storage and cookies\n      if (accessToken) {\n        const expiresIn = updatedCredentials.expiry_date\n          ? new Date(updatedCredentials.expiry_date)\n          : new Date(Date.now() + 3600 * 1000) // 1 hour fallback\n        const newRefreshToken = updatedCredentials.refresh_token || refreshToken\n\n        // console.log(\"[CalendarService] Storing refreshed access token\")\n\n        // Save to file storage (for cross-origin requests)\n        setGoogleCalendarTokens({\n          access_token: accessToken,\n          refresh_token: newRefreshToken,\n          expiry_date: updatedCredentials.expiry_date,\n        })\n\n        // Also save to cookies (for same-origin requests as backup)\n        cookieStore.set(\"google_calendar_access_token\", accessToken, {\n          httpOnly: true,\n          secure: process.env.NODE_ENV === \"production\",\n          sameSite: \"lax\",\n          expires: expiresIn,\n          path: \"/\",\n        })\n\n        cookieStore.set(\"google_calendar_refresh_token\", newRefreshToken, {\n          httpOnly: true,\n          secure: process.env.NODE_ENV === \"production\",\n          sameSite: \"lax\",\n          expires: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year\n          path: \"/\",\n        })\n\n        // console.log(\"[CalendarService] Token refreshed successfully\")\n      }\n    } catch (refreshError: any) {\n      console.error(\"[CalendarService] Failed to refresh access token:\", {\n        error: refreshError?.message || refreshError,\n        code: refreshError?.code,\n      })\n\n      // Only clear tokens if it's an auth error (invalid_grant means refresh token is revoked)\n      if (refreshError?.message?.includes(\"invalid_grant\") ||\n          refreshError?.code === 400 ||\n          refreshError?.code === 401) {\n        // console.log(\"[CalendarService] Clearing invalid tokens\")\n        clearGoogleCalendarTokens()\n        cookieStore.delete(\"google_calendar_refresh_token\")\n        cookieStore.delete(\"google_calendar_access_token\")\n        return { accessToken: null, refreshToken: null }\n      }\n\n      // For other errors, keep the refresh token (might be a temporary issue)\n      return { accessToken: null, refreshToken }\n    }\n  }\n\n  if (accessToken) {\n    calendarService.setCredentials({\n      access_token: accessToken,\n      refresh_token: refreshToken || undefined,\n    })\n  }\n\n  return { accessToken, refreshToken }\n}\n\n/**\n * Helper function to update cookies if token was refreshed\n * Also updates cookies if we have credentials but no original token (token was refreshed proactively)\n */\nexport async function updateCalendarTokenCookies(\n  calendarService: CalendarService,\n  originalAccessToken: string | null\n): Promise<void> {\n  const currentCredentials = calendarService.getCredentials()\n\n  // Update cookie if:\n  // 1. Token was refreshed (different access token)\n  // 2. We have credentials but no original token (token was refreshed proactively in loadCalendarTokensFromCookies)\n  if (currentCredentials.access_token) {\n    const shouldUpdate =\n      !originalAccessToken || // No original token means it was refreshed proactively\n      currentCredentials.access_token !== originalAccessToken // Token changed\n\n    if (shouldUpdate) {\n      const cookieStore = await cookies()\n      const expiresIn = currentCredentials.expiry_date\n        ? new Date(currentCredentials.expiry_date)\n        : new Date(Date.now() + 3600 * 1000) // 1 hour fallback\n\n      cookieStore.set(\"google_calendar_access_token\", currentCredentials.access_token, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: \"lax\",\n        expires: expiresIn,\n        path: \"/\",\n      })\n\n      // Update refresh token if it exists\n      if (currentCredentials.refresh_token) {\n        cookieStore.set(\"google_calendar_refresh_token\", currentCredentials.refresh_token, {\n          httpOnly: true,\n          secure: process.env.NODE_ENV === \"production\",\n          sameSite: \"lax\",\n          expires: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year\n          path: \"/\",\n        })\n      }\n    }\n  }\n}\n\nexport class CalendarService {\n  private oauth2Client: any\n  private calendar: any\n\n  constructor() {\n    if (config.google.isConfigured) {\n      // Use GOOGLE_REDIRECT_URI env var, or fallback to localhost\n      // IMPORTANT: Private IPs (192.168.x.x, 10.x.x.x) don't work with Google OAuth\n      // You must use localhost for development\n      const redirectUri = process.env.GOOGLE_REDIRECT_URI || \"http://localhost:3000/api/calendar/callback\"\n\n      this.oauth2Client = new google.auth.OAuth2(\n        config.google.clientId,\n        config.google.clientSecret,\n        redirectUri\n      )\n      this.calendar = google.calendar({ version: \"v3\", auth: this.oauth2Client })\n    }\n  }\n\n  isConfigured(): boolean {\n    return config.google.isConfigured\n  }\n\n  /**\n   * Get authorization URL\n   * @param forceConsent - If true, forces consent screen to ensure refresh token is obtained\n   */\n  getAuthUrl(forceConsent: boolean = false): string {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    const scopes = [\"https://www.googleapis.com/auth/calendar.readonly\"]\n\n    const authOptions: any = {\n      access_type: \"offline\",\n      scope: scopes,\n    }\n\n    // Force consent screen to ensure we get a refresh token\n    // This is important for the first authorization\n    if (forceConsent) {\n      authOptions.prompt = \"consent\"\n    }\n\n    return this.oauth2Client.generateAuthUrl(authOptions)\n  }\n\n  /**\n   * Set access token (after OAuth callback)\n   */\n  setAccessToken(token: string, refreshToken?: string): void {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    this.oauth2Client.setCredentials({\n      access_token: token,\n      refresh_token: refreshToken,\n    })\n  }\n\n  /**\n   * Set credentials from tokens object\n   */\n  setCredentials(tokens: { access_token: string; refresh_token?: string }): void {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    // console.log(\"[CalendarService] Setting credentials\")\n\n    this.oauth2Client.setCredentials(tokens)\n\n    // Ensure calendar client uses the updated credentials\n    // The calendar client should automatically use the oauth2Client, but let's verify\n    if (this.calendar) {\n      this.calendar = google.calendar({ version: \"v3\", auth: this.oauth2Client })\n    }\n  }\n\n  /**\n   * Get current credentials (useful for checking if token was refreshed)\n   */\n  getCredentials(): { access_token?: string; refresh_token?: string; expiry_date?: number } {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    return this.oauth2Client.credentials || {}\n  }\n\n  /**\n   * Refresh access token using refresh token\n   * Returns the new credentials if successful\n   */\n  async refreshAccessToken(): Promise<{ access_token: string; refresh_token?: string; expiry_date?: number }> {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    if (!this.oauth2Client.credentials?.refresh_token) {\n      throw new Error(\"No refresh token available\")\n    }\n\n    const { credentials } = await this.oauth2Client.refreshAccessToken()\n\n    // Preserve refresh token if not returned in new credentials\n    const updatedCredentials = {\n      ...credentials,\n      refresh_token: credentials.refresh_token || this.oauth2Client.credentials.refresh_token,\n    }\n\n    this.oauth2Client.setCredentials(updatedCredentials)\n\n    return updatedCredentials\n  }\n\n  /**\n   * Get calendar events\n   */\n  async getEvents(calendarId: string = \"primary\", maxResults: number = 10): Promise<CalendarEvent[]> {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    try {\n      const response = await this.calendar.events.list({\n        calendarId,\n        timeMin: new Date().toISOString(),\n        maxResults,\n        singleEvents: true,\n        orderBy: \"startTime\",\n      })\n\n      return response.data.items || []\n    } catch (error: any) {\n      // Handle token refresh if needed\n      if (error.code === 401 && this.oauth2Client.credentials?.refresh_token) {\n        try {\n          const { credentials } = await this.oauth2Client.refreshAccessToken()\n          // Preserve refresh token if not returned in new credentials\n          const updatedCredentials = {\n            ...credentials,\n            refresh_token: credentials.refresh_token || this.oauth2Client.credentials.refresh_token,\n          }\n          this.oauth2Client.setCredentials(updatedCredentials)\n          // Retry the request\n          const response = await this.calendar.events.list({\n            calendarId,\n            timeMin: new Date().toISOString(),\n            maxResults,\n            singleEvents: true,\n            orderBy: \"startTime\",\n          })\n          return response.data.items || []\n        } catch (refreshError) {\n          throw new Error(`Google Calendar API error: Token refresh failed. Please re-authenticate.`)\n        }\n      }\n      throw new Error(`Google Calendar API error: ${error instanceof Error ? error.message : \"Unknown error\"}`)\n    }\n  }\n\n  /**\n   * Get upcoming events\n   * Returns the next N upcoming events regardless of how far in the future\n   */\n  async getUpcomingEvents(calendarId: string = \"primary\", maxResults: number = 10): Promise<CalendarEvent[]> {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    if (!this.calendar) {\n      throw new Error(\"Calendar client not initialized\")\n    }\n\n    if (!this.oauth2Client.credentials?.access_token) {\n      throw new Error(\"No access token available. Please authenticate.\")\n    }\n\n    try {\n      const now = new Date()\n\n      // Verbose logging disabled\n      // console.log(\"[CalendarService] Fetching upcoming events:\", { calendarId, maxResults })\n\n      const response = await this.calendar.events.list({\n        calendarId,\n        timeMin: now.toISOString(),\n        // No timeMax - get all future events\n        maxResults,\n        singleEvents: true,\n        orderBy: \"startTime\",\n        showDeleted: false, // Don't show deleted events\n      })\n\n      // Verbose logging disabled\n      // console.log(\"[CalendarService] Got\", response.data.items?.length || 0, \"events\")\n\n      const events = response.data.items || []\n\n      // Filter out cancelled events\n      const activeEvents = events.filter((e: CalendarEvent) => e.status !== \"cancelled\")\n\n      // Verbose logging disabled\n      // console.log(\"[CalendarService] Returning\", activeEvents.length, \"active events\")\n\n      return activeEvents\n    } catch (error: any) {\n      console.error(\"[CalendarService] Error in getUpcomingEvents:\", {\n        error: error.message,\n        code: error.code,\n        response: error.response?.data,\n        hasRefreshToken: !!this.oauth2Client.credentials?.refresh_token,\n      })\n\n      // Handle token refresh if needed\n      if (error.code === 401 && this.oauth2Client.credentials?.refresh_token) {\n        // console.log(\"[CalendarService] Attempting token refresh\")\n        try {\n          const { credentials } = await this.oauth2Client.refreshAccessToken()\n          // Preserve refresh token if not returned in new credentials\n          const updatedCredentials = {\n            ...credentials,\n            refresh_token: credentials.refresh_token || this.oauth2Client.credentials.refresh_token,\n          }\n          this.oauth2Client.setCredentials(updatedCredentials)\n          // console.log(\"[CalendarService] Token refreshed, retrying\")\n          // Retry the request\n          const now = new Date()\n          const response = await this.calendar.events.list({\n            calendarId,\n            timeMin: now.toISOString(),\n            // No timeMax - get all future events\n            maxResults,\n            singleEvents: true,\n            orderBy: \"startTime\",\n          })\n          const events = response.data.items || []\n          return events.filter((e: CalendarEvent) => e.status !== \"cancelled\")\n        } catch (refreshError: any) {\n          console.error(\"[CalendarService] Token refresh failed:\", refreshError)\n          throw new Error(`Google Calendar API error: Token refresh failed. Please re-authenticate.`)\n        }\n      }\n      throw new Error(`Google Calendar API error: ${error instanceof Error ? error.message : \"Unknown error\"}`)\n    }\n  }\n\n  /**\n   * Create a calendar event\n   */\n  async createEvent(event: Partial<CalendarEvent>, calendarId: string = \"primary\"): Promise<CalendarEvent> {\n    if (!this.isConfigured()) {\n      throw new Error(\"Google Calendar not configured\")\n    }\n\n    try {\n      const response = await this.calendar.events.insert({\n        calendarId,\n        resource: event,\n      })\n\n      return response.data\n    } catch (error) {\n      throw new Error(`Google Calendar API error: ${error instanceof Error ? error.message : \"Unknown error\"}`)\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5152, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/calendar.adapter.ts"],"sourcesContent":["/**\r\n * Calendar Adapter\r\n * Handles Google Calendar data with event snapshots to Supabase\r\n * \r\n * Google Calendar requires OAuth authentication, so availability depends on\r\n * whether the user is authenticated. Supabase cache is used as fallback.\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp } from './base.adapter'\r\nimport { \r\n  CalendarService, \r\n  loadCalendarTokensFromCookies, \r\n  updateCalendarTokenCookies \r\n} from '@/lib/services/calendar.service'\r\nimport type { CalendarEvent } from '@/lib/types/calendar.types'\r\nimport type { CalendarEventRow, CalendarEventInsert } from '@/lib/supabase/types'\r\n\r\nexport interface CalendarFullState {\r\n  events: CalendarEvent[]\r\n  calendarId: string\r\n}\r\n\r\nexport interface CalendarCachedState {\r\n  events: CalendarEvent[]\r\n  recordedAt: string\r\n}\r\n\r\n/**\r\n * Calendar Adapter - manages Google Calendar events\r\n */\r\nexport class CalendarAdapter extends BaseAdapter<CalendarFullState, CalendarCachedState> {\r\n  private calendarService: CalendarService\r\n  private defaultCalendarId: string = 'primary'\r\n\r\n  constructor(debug: boolean = false) {\r\n    super({ serviceName: 'calendar', debug })\r\n    this.calendarService = new CalendarService()\r\n  }\r\n\r\n  /**\r\n   * Check if Calendar is configured\r\n   */\r\n  isConfigured(): boolean {\r\n    return this.calendarService.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Check if Google Calendar API is available\r\n   * Calendar is an external API that requires OAuth - we consider it \"available\"\r\n   * if the service is configured. Authentication is handled separately.\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    return this.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Initialize the service with tokens from cookies\r\n   * Must be called in server context before fetching data\r\n   */\r\n  async initializeWithTokens(): Promise<{ authenticated: boolean }> {\r\n    if (!this.isConfigured()) {\r\n      return { authenticated: false }\r\n    }\r\n\r\n    const { accessToken, refreshToken } = await loadCalendarTokensFromCookies(this.calendarService)\r\n    return {\r\n      authenticated: Boolean(accessToken || refreshToken),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update cookies after API call (if token was refreshed)\r\n   */\r\n  async updateCookiesIfNeeded(originalAccessToken: string | null): Promise<void> {\r\n    await updateCalendarTokenCookies(this.calendarService, originalAccessToken)\r\n  }\r\n\r\n  /**\r\n   * Fetch calendar events from Google API\r\n   */\r\n  protected async fetchFromService(): Promise<CalendarFullState> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error('Google Calendar not configured')\r\n    }\r\n\r\n    const events = await this.calendarService.getUpcomingEvents(this.defaultCalendarId, 20)\r\n    return { events, calendarId: this.defaultCalendarId }\r\n  }\r\n\r\n  /**\r\n   * Fetch cached calendar events from Supabase\r\n   */\r\n  protected async fetchFromCache(): Promise<CalendarCachedState | null> {\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      // Get the most recent event snapshots\r\n      // Use DISTINCT ON event_id to get the latest snapshot for each event\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const { data, error } = await (client.from('calendar_events') as any)\r\n        .select('*')\r\n        .gte('start_time', new Date().toISOString()) // Only future events\r\n        .order('recorded_at', { ascending: false })\r\n        .limit(50)\r\n\r\n      if (error) throw error\r\n      if (!data || data.length === 0) return null\r\n\r\n      const rows = data as CalendarEventRow[]\r\n\r\n      // Deduplicate by event_id (keep most recent snapshot)\r\n      const eventMap = new Map<string, CalendarEventRow>()\r\n      for (const row of rows) {\r\n        if (!eventMap.has(row.event_id)) {\r\n          eventMap.set(row.event_id, row)\r\n        }\r\n      }\r\n\r\n      // Convert to CalendarEvent array and sort by start time\r\n      const events = Array.from(eventMap.values())\r\n        .map(row => row.event_data)\r\n        .sort((a, b) => {\r\n          const aTime = a.start.dateTime ?? a.start.date ?? ''\r\n          const bTime = b.start.dateTime ?? b.start.date ?? ''\r\n          return aTime.localeCompare(bTime)\r\n        })\r\n\r\n      const recordedAt = rows[0]?.recorded_at ?? new Date().toISOString()\r\n\r\n      return { events, recordedAt }\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write calendar events to Supabase\r\n   */\r\n  protected async writeToCache(data: CalendarFullState): Promise<SyncResult> {\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    const timestamp = getCurrentTimestamp()\r\n    let recordsWritten = 0\r\n\r\n    try {\r\n      const inserts: CalendarEventInsert[] = data.events.map(event => {\r\n        const startDateTime = event.start.dateTime\r\n        const endDateTime = event.end.dateTime\r\n        const isAllDay = !startDateTime && Boolean(event.start.date)\r\n\r\n        return {\r\n          event_id: event.id,\r\n          calendar_id: data.calendarId,\r\n          summary: event.summary ?? null,\r\n          description: event.description ?? null,\r\n          location: event.location ?? null,\r\n          start_time: startDateTime ?? null,\r\n          end_time: endDateTime ?? null,\r\n          start_date: event.start.date ?? null,\r\n          end_date: event.end.date ?? null,\r\n          is_all_day: isAllDay,\r\n          status: event.status ?? null,\r\n          html_link: event.htmlLink ?? null,\r\n          attendees: event.attendees ?? null,\r\n          recurrence: event.recurrence ?? null,\r\n          event_data: event,\r\n          recorded_at: timestamp,\r\n        }\r\n      })\r\n\r\n      if (inserts.length > 0) {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const { error } = await (client.from('calendar_events') as any).insert(inserts)\r\n        if (error) throw error\r\n        recordsWritten = inserts.length\r\n      }\r\n\r\n      return { success: true, recordsWritten }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error writing to cache', error)\r\n      return { success: false, recordsWritten, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get upcoming calendar events\r\n   */\r\n  async getUpcomingEvents(\r\n    calendarId?: string,\r\n    maxResults: number = 10\r\n  ): Promise<CalendarEvent[]> {\r\n    const targetCalendarId = calendarId ?? this.defaultCalendarId\r\n    const isLocal = await this.isLocal()\r\n\r\n    if (isLocal) {\r\n      try {\r\n        const events = await this.calendarService.getUpcomingEvents(targetCalendarId, maxResults)\r\n        \r\n        // Write to cache in background\r\n        if (this.isSupabaseAvailable()) {\r\n          this.writeToCache({ events, calendarId: targetCalendarId })\r\n            .catch(err => this.logError('Failed to cache events', err))\r\n        }\r\n\r\n        return events\r\n      } catch (error) {\r\n        this.logError('Error fetching events', error)\r\n        throw error\r\n      }\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) {\r\n      this.log('No cached events available')\r\n      return []\r\n    }\r\n\r\n    // Limit results\r\n    return cached.events.slice(0, maxResults)\r\n  }\r\n\r\n  /**\r\n   * Get events (alias for getUpcomingEvents)\r\n   */\r\n  async getEvents(calendarId?: string, maxResults: number = 10): Promise<CalendarEvent[]> {\r\n    return this.getUpcomingEvents(calendarId, maxResults)\r\n  }\r\n\r\n  /**\r\n   * Get simplified event data for display\r\n   */\r\n  async getUpcomingEventsSimple(maxResults: number = 10): Promise<Array<{\r\n    id: string\r\n    title: string\r\n    description: string | null\r\n    location: string | null\r\n    startTime: Date | null\r\n    endTime: Date | null\r\n    isAllDay: boolean\r\n    status: string\r\n    recordedAt?: string\r\n  }>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      const events = await this.getUpcomingEvents(undefined, maxResults)\r\n      \r\n      return events.map(event => ({\r\n        id: event.id,\r\n        title: event.summary ?? 'Untitled Event',\r\n        description: event.description ?? null,\r\n        location: event.location ?? null,\r\n        startTime: event.start.dateTime ? new Date(event.start.dateTime) : null,\r\n        endTime: event.end.dateTime ? new Date(event.end.dateTime) : null,\r\n        isAllDay: !event.start.dateTime && Boolean(event.start.date),\r\n        status: event.status,\r\n      }))\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return []\r\n\r\n    return cached.events.slice(0, maxResults).map(event => ({\r\n      id: event.id,\r\n      title: event.summary ?? 'Untitled Event',\r\n      description: event.description ?? null,\r\n      location: event.location ?? null,\r\n      startTime: event.start.dateTime ? new Date(event.start.dateTime) : null,\r\n      endTime: event.end.dateTime ? new Date(event.end.dateTime) : null,\r\n      isAllDay: !event.start.dateTime && Boolean(event.start.date),\r\n      status: event.status,\r\n      recordedAt: cached.recordedAt,\r\n    }))\r\n  }\r\n\r\n  /**\r\n   * Get today's events\r\n   */\r\n  async getTodaysEvents(): Promise<CalendarEvent[]> {\r\n    const events = await this.getUpcomingEvents(undefined, 50)\r\n    \r\n    const today = new Date()\r\n    today.setHours(0, 0, 0, 0)\r\n    const tomorrow = new Date(today)\r\n    tomorrow.setDate(tomorrow.getDate() + 1)\r\n\r\n    return events.filter(event => {\r\n      const startStr = event.start.dateTime ?? event.start.date\r\n      if (!startStr) return false\r\n      \r\n      const start = new Date(startStr)\r\n      return start >= today && start < tomorrow\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get the next event\r\n   */\r\n  async getNextEvent(): Promise<CalendarEvent | null> {\r\n    const events = await this.getUpcomingEvents(undefined, 1)\r\n    return events[0] ?? null\r\n  }\r\n\r\n  // ==========================================\r\n  // Auth pass-through methods\r\n  // ==========================================\r\n\r\n  getAuthUrl(forceConsent: boolean = false): string {\r\n    return this.calendarService.getAuthUrl(forceConsent)\r\n  }\r\n\r\n  setCredentials(tokens: { access_token: string; refresh_token?: string }): void {\r\n    this.calendarService.setCredentials(tokens)\r\n  }\r\n\r\n  getCredentials() {\r\n    return this.calendarService.getCredentials()\r\n  }\r\n\r\n  async refreshAccessToken() {\r\n    return this.calendarService.refreshAccessToken()\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet calendarAdapterInstance: CalendarAdapter | null = null\r\n\r\nexport function getCalendarAdapter(): CalendarAdapter {\r\n  if (!calendarAdapterInstance) {\r\n    calendarAdapterInstance = new CalendarAdapter()\r\n  }\r\n  return calendarAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5437, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/index.ts"],"sourcesContent":["/**\r\n * Adapters Index\r\n * Export all adapters for easy importing\r\n */\r\n\r\n// Base adapter\r\nexport { BaseAdapter, parseJsonSafe, getCurrentTimestamp } from './base.adapter'\r\nexport type { AdapterConfig, SyncResult } from './base.adapter'\r\n\r\n// Hue adapter\r\nexport { HueAdapter, getHueAdapter } from './hue.adapter'\r\nexport type { HueFullState, HueCachedState } from './hue.adapter'\r\n\r\n// Spotify adapter\r\nexport { SpotifyAdapter, getSpotifyAdapter } from './spotify.adapter'\r\nexport type { SpotifyFullState, SpotifyCachedState } from './spotify.adapter'\r\n\r\n// Fitness adapter\r\nexport { FitnessAdapter, getFitnessAdapter } from './fitness.adapter'\r\n\r\n// CTA adapter\r\nexport { CTAAdapter, getCTAAdapter } from './cta.adapter'\r\nexport type { CTAFullState, CTACachedState } from './cta.adapter'\r\n\r\n// Calendar adapter\r\nexport { CalendarAdapter, getCalendarAdapter } from './calendar.adapter'\r\nexport type { CalendarFullState, CalendarCachedState } from './calendar.adapter'\r\n"],"names":[],"mappings":";AAAA;;;CAGC,GAED,eAAe;AACf;AAGA,cAAc;AACd;AAGA,kBAAkB;AAClB;AAGA,kBAAkB;AAClB;AAEA,cAAc;AACd;AAGA,mBAAmB;AACnB"}},
    {"offset": {"line": 5463, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/utils/mode.ts"],"sourcesContent":["/**\n * Mode Detection Utilities\n * Determines whether the app is running in local or production mode\n *\n * Mode is auto-detected based on service reachability:\n * - Local mode: Local services (like Hue bridge) are reachable\n * - Production mode: Local services are not reachable, read from cache\n *\n * DEPLOYMENT_MODE env var is no longer required - mode is auto-detected.\n */\n\nimport { isAnyLocalServiceAvailable, getServiceAvailabilityStatus } from '@/lib/adapters/base.adapter'\n\nexport type DeploymentMode = 'local' | 'production'\n\n/**\n * Get the current deployment mode based on service availability\n *\n * This is now auto-detected:\n * - If any local service is reachable: 'local'\n * - If no local services are reachable: 'production'\n */\nexport function getDeploymentMode(): DeploymentMode {\n  // Check if any local service is available based on cached checks\n  if (isAnyLocalServiceAvailable()) {\n    return 'local'\n  }\n  return 'production'\n}\n\n/**\n * Check if any local service is available\n * This uses cached results from service availability checks\n */\nexport function isLocalMode(): boolean {\n  return isAnyLocalServiceAvailable()\n}\n\n/**\n * Check if running in production mode (no local services available)\n */\nexport function isProductionMode(): boolean {\n  return !isAnyLocalServiceAvailable()\n}\n\n/**\n * Check if controls should be enabled\n * Controls are only enabled when local services are reachable\n */\nexport function areControlsEnabled(): boolean {\n  return isLocalMode()\n}\n\n/**\n * Require local mode for an operation\n * Throws an error if no local services are available\n */\nexport function requireLocalMode(operation: string = 'This action'): void {\n  if (!isLocalMode()) {\n    throw new Error(`${operation} is only available when local services are reachable`)\n  }\n}\n\n/**\n * Guard decorator for mutations - throws if not in local mode\n * Use this to protect mutation endpoints in API routes\n */\nexport function localModeGuard(): { allowed: boolean; error?: string } {\n  if (isLocalMode()) {\n    return { allowed: true }\n  }\n\n  return {\n    allowed: false,\n    error: 'This action is only available when local services are reachable. The web version is read-only.'\n  }\n}\n\n/**\n * Get mode info for client-side display\n */\nexport function getModeInfo(): {\n  mode: DeploymentMode\n  isLocal: boolean\n  isProduction: boolean\n  controlsEnabled: boolean\n  displayName: string\n  description: string\n  serviceStatus: ReturnType<typeof getServiceAvailabilityStatus>\n} {\n  const isLocal = isLocalMode()\n  const mode = isLocal ? 'local' : 'production'\n\n  return {\n    mode,\n    isLocal,\n    isProduction: !isLocal,\n    controlsEnabled: isLocal,\n    displayName: isLocal ? 'Local Mode' : 'Live View',\n    description: isLocal\n      ? 'Connected to real devices'\n      : \"Live from Pete's apartment\",\n    serviceStatus: getServiceAvailabilityStatus(),\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;;;;CASC,GAED;;AAWO,SAAS;IACd,iEAAiE;IACjE,IAAI,IAAA,kKAA0B,KAAI;QAChC,OAAO;IACT;IACA,OAAO;AACT;AAMO,SAAS;IACd,OAAO,IAAA,kKAA0B;AACnC;AAKO,SAAS;IACd,OAAO,CAAC,IAAA,kKAA0B;AACpC;AAMO,SAAS;IACd,OAAO;AACT;AAMO,SAAS,iBAAiB,YAAoB,aAAa;IAChE,IAAI,CAAC,eAAe;QAClB,MAAM,IAAI,MAAM,GAAG,UAAU,oDAAoD,CAAC;IACpF;AACF;AAMO,SAAS;IACd,IAAI,eAAe;QACjB,OAAO;YAAE,SAAS;QAAK;IACzB;IAEA,OAAO;QACL,SAAS;QACT,OAAO;IACT;AACF;AAKO,SAAS;IASd,MAAM,UAAU;IAChB,MAAM,OAAO,UAAU,UAAU;IAEjC,OAAO;QACL;QACA;QACA,cAAc,CAAC;QACf,iBAAiB;QACjB,aAAa,UAAU,eAAe;QACtC,aAAa,UACT,8BACA;QACJ,eAAe,IAAA,oKAA4B;IAC7C;AACF"}},
    {"offset": {"line": 5539, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/app/api/spotify/me/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { getAuthenticatedSpotifyService, isSpotifyConfigured } from \"@/lib/spotify-auth\"\nimport { successResponse, handleApiError } from \"@/lib/api/utils\"\nimport { getSpotifyAdapter } from \"@/lib/adapters\"\nimport { isProductionMode, isLocalMode } from \"@/lib/utils/mode\"\n\n/**\n * Get current Spotify user profile\n */\nexport async function GET() {\n  try {\n    const adapter = getSpotifyAdapter()\n\n    // In production mode (no local services), return cached user info\n    if (isProductionMode()) {\n      const cachedUser = await adapter.getCurrentUser()\n      return successResponse({\n        user: cachedUser,\n        source: 'cache',\n        authenticated: false,\n        authAvailable: false,\n      })\n    }\n\n    // Local mode - try to authenticate\n    if (!isSpotifyConfigured()) {\n      // Not configured - return cached data if available\n      try {\n        const cachedUser = await adapter.getCurrentUser()\n        return successResponse({\n          user: cachedUser,\n          source: 'cache',\n          authenticated: false,\n          authAvailable: false,\n          message: 'Spotify not configured',\n        })\n      } catch {\n        return successResponse({\n          user: null,\n          source: 'none',\n          authenticated: false,\n          authAvailable: false,\n          message: 'Spotify not configured',\n        })\n      }\n    }\n\n    const { service, authenticated } = await getAuthenticatedSpotifyService()\n\n    if (!authenticated) {\n      // Not authenticated in local mode - return cached data with auth prompt\n      try {\n        const cachedUser = await adapter.getCurrentUser()\n        return NextResponse.json({\n          success: true,\n          data: {\n            user: cachedUser,\n            source: 'cache',\n            authenticated: false,\n            authAvailable: isLocalMode(),\n            authUrl: '/api/spotify/auth',\n            message: 'Using cached data. Authenticate to get real-time updates.',\n          },\n        })\n      } catch {\n        return NextResponse.json({\n          success: true,\n          data: {\n            user: null,\n            source: 'none',\n            authenticated: false,\n            authAvailable: isLocalMode(),\n            authUrl: '/api/spotify/auth',\n            message: 'Please authenticate to access Spotify.',\n          },\n        })\n      }\n    }\n\n    // Authenticated - get live data\n    const user = await service.getCurrentUser()\n    return successResponse({\n      user,\n      source: 'live',\n      authenticated: true,\n      authAvailable: true,\n    })\n  } catch (error) {\n    console.error(\"[Spotify Me] Error:\", error)\n    return handleApiError(error)\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;AAKO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU,IAAA,4JAAiB;QAEjC,kEAAkE;QAClE,IAAI,IAAA,0IAAgB,KAAI;YACtB,MAAM,aAAa,MAAM,QAAQ,cAAc;YAC/C,OAAO,IAAA,wIAAe,EAAC;gBACrB,MAAM;gBACN,QAAQ;gBACR,eAAe;gBACf,eAAe;YACjB;QACF;QAEA,mCAAmC;QACnC,IAAI,CAAC,IAAA,+IAAmB,KAAI;YAC1B,mDAAmD;YACnD,IAAI;gBACF,MAAM,aAAa,MAAM,QAAQ,cAAc;gBAC/C,OAAO,IAAA,wIAAe,EAAC;oBACrB,MAAM;oBACN,QAAQ;oBACR,eAAe;oBACf,eAAe;oBACf,SAAS;gBACX;YACF,EAAE,OAAM;gBACN,OAAO,IAAA,wIAAe,EAAC;oBACrB,MAAM;oBACN,QAAQ;oBACR,eAAe;oBACf,eAAe;oBACf,SAAS;gBACX;YACF;QACF;QAEA,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,GAAG,MAAM,IAAA,0JAA8B;QAEvE,IAAI,CAAC,eAAe;YAClB,wEAAwE;YACxE,IAAI;gBACF,MAAM,aAAa,MAAM,QAAQ,cAAc;gBAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;oBACvB,SAAS;oBACT,MAAM;wBACJ,MAAM;wBACN,QAAQ;wBACR,eAAe;wBACf,eAAe,IAAA,qIAAW;wBAC1B,SAAS;wBACT,SAAS;oBACX;gBACF;YACF,EAAE,OAAM;gBACN,OAAO,gJAAY,CAAC,IAAI,CAAC;oBACvB,SAAS;oBACT,MAAM;wBACJ,MAAM;wBACN,QAAQ;wBACR,eAAe;wBACf,eAAe,IAAA,qIAAW;wBAC1B,SAAS;wBACT,SAAS;oBACX;gBACF;YACF;QACF;QAEA,gCAAgC;QAChC,MAAM,OAAO,MAAM,QAAQ,cAAc;QACzC,OAAO,IAAA,wIAAe,EAAC;YACrB;YACA,QAAQ;YACR,eAAe;YACf,eAAe;QACjB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,IAAA,uIAAc,EAAC;IACxB;AACF"}}]
}