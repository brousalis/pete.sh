{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/api/utils.ts"],"sourcesContent":["/**\n * API utility functions for Next.js API routes\n */\n\nimport { NextResponse } from \"next/server\"\nimport type { ApiResponse, ApiError } from \"@/lib/types/api.types\"\n\n/**\n * Create a successful API response\n */\nexport function successResponse<T>(data: T, status = 200): NextResponse<ApiResponse<T>> {\n  return NextResponse.json(\n    {\n      success: true,\n      data,\n    },\n    { status }\n  )\n}\n\n/**\n * Create an error API response\n */\nexport function errorResponse(\n  error: string | ApiError,\n  status = 500\n): NextResponse<ApiResponse> {\n  const errorObj = typeof error === \"string\" ? { code: \"UNKNOWN\", message: error } : error\n\n  const response: ApiResponse = {\n    success: false,\n    error: errorObj.message,\n  }\n  \n  if (errorObj.code) {\n    response.code = errorObj.code\n  }\n  \n  if (errorObj.details) {\n    response.details = errorObj.details\n  }\n\n  return NextResponse.json(response, { status })\n}\n\n/**\n * Handle API route errors\n */\nexport function handleApiError(error: unknown): NextResponse<ApiResponse> {\n  console.error(\"API Error:\", error)\n\n  if (error instanceof Error) {\n    return errorResponse(error.message, 500)\n  }\n\n  return errorResponse(\"An unexpected error occurred\", 500)\n}\n\n/**\n * Validate request method\n */\nexport function validateMethod(request: Request, allowedMethods: string[]): boolean {\n  return allowedMethods.includes(request.method)\n}\n\n/**\n * Get JSON body from request\n */\nexport async function getJsonBody<T = unknown>(request: Request): Promise<T> {\n  try {\n    return await request.json()\n  } catch {\n    throw new Error(\"Invalid JSON body\")\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;CAEC,GAED;;AAMO,SAAS,gBAAmB,IAAO,EAAE,SAAS,GAAG;IACtD,OAAO,gJAAY,CAAC,IAAI,CACtB;QACE,SAAS;QACT;IACF,GACA;QAAE;IAAO;AAEb;AAKO,SAAS,cACd,KAAwB,EACxB,SAAS,GAAG;IAEZ,MAAM,WAAW,OAAO,UAAU,WAAW;QAAE,MAAM;QAAW,SAAS;IAAM,IAAI;IAEnF,MAAM,WAAwB;QAC5B,SAAS;QACT,OAAO,SAAS,OAAO;IACzB;IAEA,IAAI,SAAS,IAAI,EAAE;QACjB,SAAS,IAAI,GAAG,SAAS,IAAI;IAC/B;IAEA,IAAI,SAAS,OAAO,EAAE;QACpB,SAAS,OAAO,GAAG,SAAS,OAAO;IACrC;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,UAAU;QAAE;IAAO;AAC9C;AAKO,SAAS,eAAe,KAAc;IAC3C,QAAQ,KAAK,CAAC,cAAc;IAE5B,IAAI,iBAAiB,OAAO;QAC1B,OAAO,cAAc,MAAM,OAAO,EAAE;IACtC;IAEA,OAAO,cAAc,gCAAgC;AACvD;AAKO,SAAS,eAAe,OAAgB,EAAE,cAAwB;IACvE,OAAO,eAAe,QAAQ,CAAC,QAAQ,MAAM;AAC/C;AAKO,eAAe,YAAyB,OAAgB;IAC7D,IAAI;QACF,OAAO,MAAM,QAAQ,IAAI;IAC3B,EAAE,OAAM;QACN,MAAM,IAAI,MAAM;IAClB;AACF"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/supabase/client.ts"],"sourcesContent":["/**\r\n * Supabase Client\r\n * Initializes and exports Supabase clients for the application\r\n */\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\r\nimport type { Database } from './types'\r\n\r\n// Environment variables\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n/**\r\n * Check if a string is a valid HTTP/HTTPS URL\r\n */\r\nfunction isValidUrl(urlString: string | undefined): boolean {\r\n  if (!urlString) return false\r\n  try {\r\n    const url = new URL(urlString)\r\n    return url.protocol === 'http:' || url.protocol === 'https:'\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Supabase is properly configured with valid credentials\r\n */\r\nexport function isSupabaseConfigured(): boolean {\r\n  // Check that URL exists and is a valid HTTP/HTTPS URL\r\n  if (!isValidUrl(supabaseUrl)) return false\r\n  // Check that anon key exists and isn't a placeholder\r\n  if (!supabaseAnonKey || supabaseAnonKey.includes('your-') || supabaseAnonKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n/**\r\n * Check if service role key is available and valid (for writes)\r\n */\r\nexport function hasServiceRoleKey(): boolean {\r\n  if (!supabaseServiceKey) return false\r\n  // Check it's not a placeholder\r\n  if (supabaseServiceKey.includes('your-') || supabaseServiceKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n// Singleton instances\r\nlet anonClient: SupabaseClient<Database> | null = null\r\nlet serviceClient: SupabaseClient<Database> | null = null\r\n\r\n/**\r\n * Get the public Supabase client (anon key)\r\n * Use this for read operations and client-side queries\r\n * Returns null if not configured (call isSupabaseConfigured() first)\r\n */\r\nexport function getSupabaseClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!anonClient) {\r\n    try {\r\n      anonClient = createClient<Database>(supabaseUrl!, supabaseAnonKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return anonClient\r\n}\r\n\r\n/**\r\n * Get the service role Supabase client\r\n * Use this for server-side write operations (local mode only)\r\n * Returns null if not configured\r\n * WARNING: Never expose this in client-side code\r\n */\r\nexport function getSupabaseServiceClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!hasServiceRoleKey()) {\r\n    return null\r\n  }\r\n\r\n  if (!serviceClient) {\r\n    try {\r\n      serviceClient = createClient<Database>(supabaseUrl!, supabaseServiceKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return serviceClient\r\n}\r\n\r\n/**\r\n * Get the appropriate client based on operation type\r\n * - For reads: use anon client\r\n * - For writes: use service client (if available) or anon client\r\n * Returns null if Supabase is not configured\r\n */\r\nexport function getSupabaseClientForOperation(operation: 'read' | 'write'): SupabaseClient<Database> | null {\r\n  if (operation === 'write' && hasServiceRoleKey()) {\r\n    return getSupabaseServiceClient()\r\n  }\r\n  return getSupabaseClient()\r\n}\r\n\r\n// Export types for convenience\r\nexport type { Database }\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGC,GAED;;AAGA,wBAAwB;AACxB,MAAM;AACN,MAAM;AACN,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;AAEhE;;CAEC,GACD,SAAS,WAAW,SAA6B;IAC/C,IAAI,CAAC,WAAW,OAAO;IACvB,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;IACtD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,SAAS;IACd,sDAAsD;IACtD,IAAI,CAAC,WAAW,cAAc,OAAO;IACrC,qDAAqD;IACrD,IAAI,CAAC,mBAAmB,gBAAgB,QAAQ,CAAC,YAAY,gBAAgB,MAAM,GAAG,IAAI,OAAO;IACjG,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,oBAAoB,OAAO;IAChC,+BAA+B;IAC/B,IAAI,mBAAmB,QAAQ,CAAC,YAAY,mBAAmB,MAAM,GAAG,IAAI,OAAO;IACnF,OAAO;AACT;AAEA,sBAAsB;AACtB,IAAI,aAA8C;AAClD,IAAI,gBAAiD;AAO9C,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,YAAY;QACf,IAAI;YACF,aAAa,IAAA,gMAAY,EAAW,aAAc,iBAAkB;gBAClE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,eAAe;QAClB,IAAI;YACF,gBAAgB,IAAA,gMAAY,EAAW,aAAc,oBAAqB;gBACxE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,8BAA8B,SAA2B;IACvE,IAAI,cAAc,WAAW,qBAAqB;QAChD,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/base.adapter.ts"],"sourcesContent":["/**\r\n * Base Adapter\r\n * Provides common functionality for all service adapters\r\n * \r\n * The adapter pattern allows seamless switching between:\r\n * - Local mode: Fetch from real service + write to Supabase (auto-detected)\r\n * - Production mode: Read from Supabase cache (fallback when services unreachable)\r\n * \r\n * Mode is auto-detected by attempting to reach local services.\r\n * No DEPLOYMENT_MODE env var required.\r\n */\r\n\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\nimport { getSupabaseClient, getSupabaseServiceClient, isSupabaseConfigured, hasServiceRoleKey } from '@/lib/supabase/client'\r\nimport type { Database, ServiceName } from '@/lib/supabase/types'\r\n\r\n// ============================================\r\n// Server-side Connectivity Detection\r\n// ============================================\r\n\r\ninterface ServiceAvailability {\r\n  available: boolean\r\n  checkedAt: Date\r\n  error?: string\r\n}\r\n\r\n/** Cache of service availability checks */\r\nconst serviceAvailabilityCache = new Map<ServiceName, ServiceAvailability>()\r\n\r\n/** How long to cache availability results (ms) */\r\nconst AVAILABILITY_CACHE_TTL = 5 * 60 * 1000 // 5 minutes\r\n\r\n/** Timeout for availability checks (ms) */\r\nexport const AVAILABILITY_CHECK_TIMEOUT = 2000 // 2 seconds\r\n\r\n/**\r\n * Check if a cached availability result is still valid\r\n */\r\nfunction isAvailabilityCacheValid(serviceName: ServiceName): boolean {\r\n  const cached = serviceAvailabilityCache.get(serviceName)\r\n  if (!cached) return false\r\n  \r\n  const age = Date.now() - cached.checkedAt.getTime()\r\n  return age < AVAILABILITY_CACHE_TTL\r\n}\r\n\r\n/**\r\n * Get global service availability status (for health endpoint)\r\n */\r\nexport function getServiceAvailabilityStatus(): Record<ServiceName, ServiceAvailability | null> {\r\n  const result: Record<string, ServiceAvailability | null> = {}\r\n  const services: ServiceName[] = ['hue', 'spotify', 'cta', 'calendar', 'fitness']\r\n  \r\n  for (const service of services) {\r\n    result[service] = serviceAvailabilityCache.get(service) ?? null\r\n  }\r\n  \r\n  return result as Record<ServiceName, ServiceAvailability | null>\r\n}\r\n\r\n/**\r\n * Check if any local service is available (for mode detection)\r\n */\r\nexport function isAnyLocalServiceAvailable(): boolean {\r\n  for (const [, status] of serviceAvailabilityCache) {\r\n    if (status.available) return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Clear the availability cache (for testing or manual refresh)\r\n */\r\nexport function clearAvailabilityCache(): void {\r\n  serviceAvailabilityCache.clear()\r\n}\r\n\r\n// ============================================\r\n// Adapter Types\r\n// ============================================\r\n\r\nexport interface AdapterConfig {\r\n  /** Service name for logging and sync tracking */\r\n  serviceName: ServiceName\r\n  /** Whether to log operations */\r\n  debug?: boolean\r\n}\r\n\r\nexport interface SyncResult {\r\n  success: boolean\r\n  recordsWritten: number\r\n  error?: string\r\n}\r\n\r\n/**\r\n * Base adapter class that all service adapters extend\r\n */\r\nexport abstract class BaseAdapter<TServiceData, TCachedData> {\r\n  protected serviceName: ServiceName\r\n  protected debug: boolean\r\n  \r\n  /** Cached availability status for this adapter instance */\r\n  private localAvailable: boolean | null = null\r\n\r\n  constructor(config: AdapterConfig) {\r\n    this.serviceName = config.serviceName\r\n    this.debug = config.debug ?? false\r\n  }\r\n\r\n  /**\r\n   * Get the Supabase client for read operations\r\n   * Returns null if Supabase is not configured\r\n   */\r\n  protected getReadClient(): SupabaseClient<Database> | null {\r\n    return getSupabaseClient()\r\n  }\r\n\r\n  /**\r\n   * Get the Supabase client for write operations\r\n   * Uses service role key if available (for local mode writes)\r\n   * Returns null if Supabase is not configured\r\n   */\r\n  protected getWriteClient(): SupabaseClient<Database> | null {\r\n    if (hasServiceRoleKey()) {\r\n      return getSupabaseServiceClient()\r\n    }\r\n    return getSupabaseClient()\r\n  }\r\n\r\n  /**\r\n   * Check if Supabase is available for caching\r\n   */\r\n  protected isSupabaseAvailable(): boolean {\r\n    return isSupabaseConfigured()\r\n  }\r\n\r\n  // ============================================\r\n  // Auto-Detection Methods\r\n  // ============================================\r\n\r\n  /**\r\n   * Abstract method to check if the local service is reachable\r\n   * Each adapter implements this with a quick ping to their service\r\n   * Should timeout quickly (< 2 seconds)\r\n   */\r\n  protected abstract checkServiceAvailability(): Promise<boolean>\r\n\r\n  /**\r\n   * Check if local service is available (with caching)\r\n   */\r\n  protected async isLocalServiceAvailable(): Promise<boolean> {\r\n    // Check instance cache first (for multiple calls in same request)\r\n    if (this.localAvailable !== null) {\r\n      return this.localAvailable\r\n    }\r\n\r\n    // Check global cache\r\n    if (isAvailabilityCacheValid(this.serviceName)) {\r\n      const cached = serviceAvailabilityCache.get(this.serviceName)!\r\n      this.localAvailable = cached.available\r\n      return cached.available\r\n    }\r\n\r\n    // Perform actual check\r\n    this.log('Checking local service availability...')\r\n    \r\n    try {\r\n      const available = await this.checkServiceAvailability()\r\n      \r\n      // Cache the result\r\n      serviceAvailabilityCache.set(this.serviceName, {\r\n        available,\r\n        checkedAt: new Date(),\r\n      })\r\n      this.localAvailable = available\r\n      \r\n      this.log(`Local service ${available ? 'available' : 'unavailable'}`)\r\n      return available\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      \r\n      // Cache the failure\r\n      serviceAvailabilityCache.set(this.serviceName, {\r\n        available: false,\r\n        checkedAt: new Date(),\r\n        error: errorMessage,\r\n      })\r\n      this.localAvailable = false\r\n      \r\n      this.log(`Local service check failed: ${errorMessage}`)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if running in local mode (service available)\r\n   * Auto-detects based on service reachability\r\n   */\r\n  protected async isLocal(): Promise<boolean> {\r\n    return this.isLocalServiceAvailable()\r\n  }\r\n\r\n  /**\r\n   * Check if running in production mode (service unavailable)\r\n   * Auto-detects based on service reachability\r\n   */\r\n  protected async isProduction(): Promise<boolean> {\r\n    return !(await this.isLocalServiceAvailable())\r\n  }\r\n\r\n  /**\r\n   * Synchronous check if local - uses cached value\r\n   * Returns false if no cached value (assumes production until proven otherwise)\r\n   */\r\n  protected isLocalSync(): boolean {\r\n    if (this.localAvailable !== null) {\r\n      return this.localAvailable\r\n    }\r\n    \r\n    const cached = serviceAvailabilityCache.get(this.serviceName)\r\n    if (cached && isAvailabilityCacheValid(this.serviceName)) {\r\n      return cached.available\r\n    }\r\n    \r\n    // Default to false (production) if not yet checked\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Log a message if debug is enabled\r\n   */\r\n  protected log(message: string, data?: unknown): void {\r\n    if (this.debug) {\r\n      console.log(`[${this.serviceName.toUpperCase()} Adapter] ${message}`, data ?? '')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log an error\r\n   * Silently ignores Supabase configuration errors to avoid console spam\r\n   */\r\n  protected logError(message: string, error?: unknown): void {\r\n    // Suppress errors related to missing tables or unconfigured Supabase\r\n    if (error && typeof error === 'object') {\r\n      const errObj = error as Record<string, unknown>\r\n      // Suppress table not found errors (migration not run yet)\r\n      if (errObj.code === 'PGRST205' || errObj.code === '42P01') return\r\n      // Suppress connection errors when Supabase isn't properly configured  \r\n      if (errObj.message && String(errObj.message).includes('not configured')) return\r\n    }\r\n    console.error(`[${this.serviceName.toUpperCase()} Adapter] ${message}`, error ?? '')\r\n  }\r\n\r\n  /**\r\n   * Record a sync operation in the sync_log table\r\n   */\r\n  protected async logSync(status: 'success' | 'error', recordsSynced: number = 0, errorMessage?: string): Promise<void> {\r\n    if (!this.isSupabaseAvailable()) return\r\n\r\n    try {\r\n      const client = this.getWriteClient()\r\n      if (!client) return // Supabase not configured\r\n      \r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      await (client.from('sync_log') as any).insert({\r\n        service: this.serviceName,\r\n        status,\r\n        records_synced: recordsSynced,\r\n        error_message: errorMessage ?? null,\r\n        synced_at: new Date().toISOString(),\r\n      })\r\n    } catch (error) {\r\n      // Silently ignore - logging sync shouldn't break the app\r\n      if (this.debug) {\r\n        this.logError('Failed to log sync', error)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the last sync time for this service\r\n   */\r\n  async getLastSyncTime(): Promise<Date | null> {\r\n    if (!this.isSupabaseAvailable()) return null\r\n\r\n    try {\r\n      const client = this.getReadClient()\r\n      if (!client) return null // Supabase not configured\r\n      \r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const { data, error } = await (client.from('sync_log') as any)\r\n        .select('synced_at')\r\n        .eq('service', this.serviceName)\r\n        .eq('status', 'success')\r\n        .order('synced_at', { ascending: false })\r\n        .limit(1)\r\n        .single()\r\n\r\n      if (error || !data) return null\r\n      return new Date((data as { synced_at: string }).synced_at)\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Abstract method to fetch data from the real service\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract fetchFromService(): Promise<TServiceData>\r\n\r\n  /**\r\n   * Abstract method to fetch cached data from Supabase\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract fetchFromCache(): Promise<TCachedData | null>\r\n\r\n  /**\r\n   * Abstract method to write data to Supabase cache\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract writeToCache(data: TServiceData): Promise<SyncResult>\r\n\r\n  /**\r\n   * Main method to get data\r\n   * Auto-detects mode:\r\n   * - If local service reachable: fetches from service and writes to cache\r\n   * - If local service unreachable: reads from cache\r\n   */\r\n  async getData(): Promise<TServiceData | TCachedData | null> {\r\n    const isLocalAvailable = await this.isLocal()\r\n    \r\n    if (isLocalAvailable) {\r\n      return this.getDataLocal()\r\n    }\r\n    return this.getDataProduction()\r\n  }\r\n\r\n  /**\r\n   * Get data in local mode\r\n   * Fetches from real service and writes to Supabase\r\n   */\r\n  protected async getDataLocal(): Promise<TServiceData | null> {\r\n    this.log('Fetching from real service (local mode)')\r\n\r\n    try {\r\n      const data = await this.fetchFromService()\r\n      \r\n      // Write to cache in background (don't block the response)\r\n      if (this.isSupabaseAvailable()) {\r\n        this.writeToCache(data)\r\n          .then((result) => {\r\n            if (result.success) {\r\n              this.log(`Cached ${result.recordsWritten} records`)\r\n            } else {\r\n              this.logError('Failed to cache data', result.error)\r\n            }\r\n          })\r\n          .catch((error) => {\r\n            this.logError('Error writing to cache', error)\r\n          })\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from service', error)\r\n      \r\n      // On service error, try falling back to cache\r\n      this.log('Service error, attempting cache fallback...')\r\n      if (this.isSupabaseAvailable()) {\r\n        try {\r\n          const cached = await this.fetchFromCache()\r\n          if (cached) {\r\n            this.log('Using cached data as fallback')\r\n            return cached as TServiceData\r\n          }\r\n        } catch {\r\n          // Cache fallback also failed\r\n        }\r\n      }\r\n      \r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get data in production mode\r\n   * Reads from Supabase cache\r\n   */\r\n  protected async getDataProduction(): Promise<TCachedData | null> {\r\n    this.log('Fetching from cache (production mode)')\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      this.logError('Supabase not configured')\r\n      return null\r\n    }\r\n\r\n    try {\r\n      const data = await this.fetchFromCache()\r\n      \r\n      if (!data) {\r\n        this.log('No cached data available')\r\n        return null\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force refresh the cache (local mode only)\r\n   * Fetches from service and writes to cache, waiting for write to complete\r\n   */\r\n  async refreshCache(): Promise<SyncResult> {\r\n    const isLocalAvailable = await this.isLocal()\r\n    \r\n    if (!isLocalAvailable) {\r\n      return { success: false, recordsWritten: 0, error: 'Cache refresh only available when local services are reachable' }\r\n    }\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    this.log('Force refreshing cache')\r\n\r\n    try {\r\n      const data = await this.fetchFromService()\r\n      const result = await this.writeToCache(data)\r\n      \r\n      await this.logSync(result.success ? 'success' : 'error', result.recordsWritten, result.error)\r\n      \r\n      return result\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      await this.logSync('error', 0, errorMessage)\r\n      return { success: false, recordsWritten: 0, error: errorMessage }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to safely parse JSON from Supabase\r\n */\r\nexport function parseJsonSafe<T>(data: unknown, fallback: T): T {\r\n  if (data === null || data === undefined) return fallback\r\n  if (typeof data === 'object') return data as T\r\n  if (typeof data === 'string') {\r\n    try {\r\n      return JSON.parse(data) as T\r\n    } catch {\r\n      return fallback\r\n    }\r\n  }\r\n  return fallback\r\n}\r\n\r\n/**\r\n * Utility function to get current timestamp in ISO format\r\n */\r\nexport function getCurrentTimestamp(): string {\r\n  return new Date().toISOString()\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/fitness.service.ts"],"sourcesContent":["/**\n * Fitness Service\n * Handles fitness routine storage and management\n * Based on workout.md - comprehensive fitness tracking system\n */\n\nimport type {\n  ConsistencyStats,\n  DayOfWeek,\n  FitnessProgress,\n  WeeklyRoutine,\n  Workout,\n} from '@/lib/types/fitness.types'\nimport { promises as fs } from 'fs'\nimport path from 'path'\n\nconst ROUTINE_FILE = path.join(process.cwd(), 'data', 'fitness-routine.json')\nconst WORKOUT_DEFINITIONS_FILE = path.join(\n  process.cwd(),\n  'data',\n  'workout-definitions.json'\n)\n\n// Export file paths for adapter use\nexport const ROUTINE_FILE_PATH = ROUTINE_FILE\nexport const WORKOUT_DEFINITIONS_FILE_PATH = WORKOUT_DEFINITIONS_FILE\n\nexport class FitnessService {\n  /**\n   * Ensure data directory exists\n   */\n  private async ensureDataDir(): Promise<void> {\n    const dataDir = path.dirname(ROUTINE_FILE)\n    try {\n      await fs.access(dataDir)\n    } catch {\n      await fs.mkdir(dataDir, { recursive: true })\n    }\n  }\n\n  /**\n   * Get workout definitions (public method)\n   */\n  async getWorkoutDefinitions(): Promise<Record<DayOfWeek, Workout>> {\n    try {\n      const data = await fs.readFile(WORKOUT_DEFINITIONS_FILE, 'utf-8')\n      return JSON.parse(data) as Record<DayOfWeek, Workout>\n    } catch {\n      return {} as Record<DayOfWeek, Workout>\n    }\n  }\n\n  /**\n   * Update all workout definitions\n   */\n  async updateWorkoutDefinitions(\n    definitions: Record<DayOfWeek, Workout>\n  ): Promise<Record<DayOfWeek, Workout>> {\n    await this.ensureDataDir()\n    await fs.writeFile(\n      WORKOUT_DEFINITIONS_FILE,\n      JSON.stringify(definitions, null, 2),\n      'utf-8'\n    )\n    return definitions\n  }\n\n  /**\n   * Update workout definition for a specific day\n   */\n  async updateWorkoutDefinition(\n    day: DayOfWeek,\n    workout: Workout\n  ): Promise<Workout> {\n    const definitions = await this.getWorkoutDefinitions()\n    definitions[day] = workout\n    await this.updateWorkoutDefinitions(definitions)\n    return workout\n  }\n\n  /**\n   * Get current week number (Monday start)\n   */\n  private getCurrentWeekNumber(): number {\n    const now = new Date()\n    const startOfYear = new Date(now.getFullYear(), 0, 1)\n    const days = Math.floor(\n      (now.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000)\n    )\n    const weekNumber = Math.ceil((days + startOfYear.getDay() + 1) / 7)\n    return weekNumber\n  }\n\n  /**\n   * Get start date of week (Monday)\n   */\n  private getWeekStartDate(weekNumber: number): Date {\n    const now = new Date()\n    const startOfYear = new Date(now.getFullYear(), 0, 1)\n    const days = (weekNumber - 1) * 7\n    const weekStart = new Date(startOfYear)\n    weekStart.setDate(startOfYear.getDate() + days - startOfYear.getDay() + 1) // Monday\n    return weekStart\n  }\n\n  /**\n   * Get or create week routine\n   */\n  private async getOrCreateWeek(routine: WeeklyRoutine, weekNumber: number) {\n    let week = routine.weeks.find(w => w.weekNumber === weekNumber)\n    if (!week) {\n      const startDate = this.getWeekStartDate(weekNumber)\n      week = {\n        weekNumber,\n        startDate: startDate.toISOString(),\n        days: {},\n      }\n      routine.weeks.push(week)\n      routine.weeks.sort((a, b) => a.weekNumber - b.weekNumber)\n    }\n    return week\n  }\n\n  /**\n   * Get weekly routine with workout definitions\n   */\n  async getRoutine(): Promise<WeeklyRoutine | null> {\n    try {\n      await this.ensureDataDir()\n      const data = await fs.readFile(ROUTINE_FILE, 'utf-8')\n      const routine = JSON.parse(data) as WeeklyRoutine\n\n      // Ensure current week exists\n      const currentWeek = this.getCurrentWeekNumber()\n      await this.getOrCreateWeek(routine, currentWeek)\n\n      // Load workout definitions\n      const workoutDefinitions = await this.getWorkoutDefinitions()\n\n      // Ensure all days have workout definitions in current week\n      const week = routine.weeks.find(w => w.weekNumber === currentWeek)\n      if (week) {\n        const days: DayOfWeek[] = [\n          'monday',\n          'tuesday',\n          'wednesday',\n          'thursday',\n          'friday',\n          'saturday',\n          'sunday',\n        ]\n        days.forEach(day => {\n          if (!week.days[day]) {\n            week.days[day] = {}\n          }\n          // Add workout definition if it exists and not already set\n          if (workoutDefinitions[day] && !week.days[day]?.workout) {\n            // Workout will be loaded from definitions when needed\n          }\n        })\n        await this.updateRoutine(routine)\n      }\n\n      return routine\n    } catch (error) {\n      return null\n    }\n  }\n\n  /**\n   * Get workout for a specific day\n   */\n  async getWorkoutForDay(\n    day: DayOfWeek,\n    weekNumber?: number\n  ): Promise<Workout | null> {\n    const workoutDefinitions = await this.getWorkoutDefinitions()\n    return workoutDefinitions[day] || null\n  }\n\n  /**\n   * Update weekly routine\n   */\n  async updateRoutine(routine: WeeklyRoutine): Promise<WeeklyRoutine> {\n    await this.ensureDataDir()\n    routine.updatedAt = new Date().toISOString()\n    await fs.writeFile(ROUTINE_FILE, JSON.stringify(routine, null, 2), 'utf-8')\n    return routine\n  }\n\n  /**\n   * Collect all exercise IDs from a workout (warmup, main, finisher, metabolic, mobility).\n   */\n  private getAllExerciseIdsFromWorkout(workout: Workout): string[] {\n    const ids: string[] = []\n    if (workout.warmup?.exercises?.length) {\n      ids.push(...workout.warmup.exercises.map(e => e.id))\n    }\n    if (workout.exercises?.length) {\n      ids.push(...workout.exercises.map(e => e.id))\n    }\n    if (workout.finisher?.length) {\n      ids.push(...workout.finisher.map(e => e.id))\n    }\n    if (workout.metabolicFlush?.exercises?.length) {\n      ids.push(...workout.metabolicFlush.exercises.map(e => e.id))\n    }\n    if (workout.mobility?.exercises?.length) {\n      ids.push(...workout.mobility.exercises.map(e => e.id))\n    }\n    return ids\n  }\n\n  /**\n   * Mark workout as complete. If exercisesCompleted is missing or empty, all exercises\n   * in the workout are auto-completed.\n   */\n  async markWorkoutComplete(\n    day: DayOfWeek,\n    weekNumber: number,\n    exercisesCompleted?: string[]\n  ): Promise<void> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, weekNumber)\n    if (!week.days[day]) {\n      week.days[day] = {}\n    }\n\n    const workoutDef = await this.getWorkoutForDay(day, weekNumber)\n    if (!workoutDef) {\n      throw new Error(`No workout definition found for ${day}`)\n    }\n\n    const allIds = this.getAllExerciseIdsFromWorkout(workoutDef)\n    const resolved = Array.from(\n      new Set([...allIds, ...(exercisesCompleted ?? [])])\n    )\n\n    week.days[day]!.workout = {\n      workoutId: workoutDef.id,\n      completed: true,\n      completedAt: new Date().toISOString(),\n      exercisesCompleted: resolved,\n    }\n\n    await this.updateRoutine(routine)\n  }\n\n  /**\n   * Mark daily routine as complete\n   */\n  async markRoutineComplete(\n    routineType: 'morning' | 'night',\n    day: DayOfWeek,\n    weekNumber: number\n  ): Promise<void> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, weekNumber)\n    if (!week.days[day]) {\n      week.days[day] = {}\n    }\n\n    const routineId = routine.dailyRoutines[routineType].id\n    week.days[day]![`${routineType}Routine`] = {\n      routineId,\n      completed: true,\n      completedAt: new Date().toISOString(),\n    }\n\n    await this.updateRoutine(routine)\n  }\n\n  /**\n   * Mark daily routine as incomplete (undo completion)\n   */\n  async markRoutineIncomplete(\n    routineType: 'morning' | 'night',\n    day: DayOfWeek,\n    weekNumber: number\n  ): Promise<void> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, weekNumber)\n    if (!week.days[day]) {\n      week.days[day] = {}\n    }\n\n    const routineId = routine.dailyRoutines[routineType].id\n    week.days[day]![`${routineType}Routine`] = {\n      routineId,\n      completed: false,\n      completedAt: undefined,\n    }\n\n    await this.updateRoutine(routine)\n  }\n\n  /**\n   * Get weekly progress\n   */\n  async getWeeklyProgress(weekNumber?: number): Promise<FitnessProgress> {\n    const targetWeek = weekNumber || this.getCurrentWeekNumber()\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n\n    const week = await this.getOrCreateWeek(routine, targetWeek)\n    const workoutsByDay: FitnessProgress['workoutsByDay'] = {}\n\n    let completedWorkouts = 0\n    let totalWorkouts = 0\n    let completedMorningRoutines = 0\n    let totalMorningRoutines = 0\n    let completedNightRoutines = 0\n    let totalNightRoutines = 0\n\n    const days: DayOfWeek[] = [\n      'monday',\n      'tuesday',\n      'wednesday',\n      'thursday',\n      'friday',\n      'saturday',\n      'sunday',\n    ]\n    const workoutDefinitions = await this.getWorkoutDefinitions()\n\n    days.forEach(day => {\n      const dayData = week.days[day]\n      const hasWorkout = !!workoutDefinitions[day]\n\n      if (hasWorkout) {\n        totalWorkouts++\n        if (dayData?.workout?.completed) {\n          completedWorkouts++\n        }\n      }\n\n      // Morning routine exists every day\n      totalMorningRoutines++\n      if (dayData?.morningRoutine?.completed) {\n        completedMorningRoutines++\n      }\n\n      // Night routine exists every day\n      totalNightRoutines++\n      if (dayData?.nightRoutine?.completed) {\n        completedNightRoutines++\n      }\n\n      workoutsByDay[day] = {\n        workout: dayData?.workout\n          ? {\n              completed: dayData.workout.completed || false,\n              completedAt: dayData.workout.completedAt,\n            }\n          : undefined,\n        morningRoutine: dayData?.morningRoutine\n          ? {\n              completed: dayData.morningRoutine.completed || false,\n              completedAt: dayData.morningRoutine.completedAt,\n            }\n          : undefined,\n        nightRoutine: dayData?.nightRoutine\n          ? {\n              completed: dayData.nightRoutine.completed || false,\n              completedAt: dayData.nightRoutine.completedAt,\n            }\n          : undefined,\n      }\n    })\n\n    const now = new Date()\n    return {\n      week: targetWeek,\n      year: now.getFullYear(),\n      completedWorkouts,\n      totalWorkouts,\n      completedMorningRoutines,\n      totalMorningRoutines,\n      completedNightRoutines,\n      totalNightRoutines,\n      workoutsByDay,\n    }\n  }\n\n  /**\n   * Get consistency stats for a given routine (and optional workout definitions).\n   * Used by the adapter when routine/defs come from Supabase.\n   */\n  async getConsistencyStatsForRoutine(\n    routine: WeeklyRoutine,\n    workoutDefinitions?: Record<DayOfWeek, Workout>\n  ): Promise<ConsistencyStats> {\n    const defs = workoutDefinitions ?? (await this.getWorkoutDefinitions())\n\n    const now = new Date()\n    let totalWorkoutDays = 0\n    let completedWorkoutDays = 0\n    let totalMorningDays = 0\n    let completedMorningDays = 0\n    let totalNightDays = 0\n    let completedNightDays = 0\n\n    let currentStreak = 0\n    let longestStreak = 0\n    let tempStreak = 0\n    let lastActiveDate: Date | undefined\n\n    // Check last 30 days\n    for (let i = 0; i < 30; i++) {\n      const checkDate = new Date(now)\n      checkDate.setDate(checkDate.getDate() - i)\n      const dayOfWeek = checkDate\n        .toLocaleDateString('en-US', { weekday: 'long' })\n        .toLowerCase() as DayOfWeek\n      const weekNum = this.getCurrentWeekNumber() - Math.floor(i / 7)\n\n      const week = routine.weeks.find(w => w.weekNumber === weekNum)\n      const dayData = week?.days[dayOfWeek]\n\n      // Check if any activity happened\n      const hasActivity =\n        dayData?.workout?.completed ||\n        dayData?.morningRoutine?.completed ||\n        dayData?.nightRoutine?.completed\n\n      if (hasActivity) {\n        if (i === 0 || tempStreak > 0) {\n          tempStreak++\n          currentStreak = i === 0 ? tempStreak : currentStreak\n        }\n        longestStreak = Math.max(longestStreak, tempStreak)\n        if (!lastActiveDate) {\n          lastActiveDate = checkDate\n        }\n      } else {\n        tempStreak = 0\n      }\n\n      totalMorningDays++\n      if (dayData?.morningRoutine?.completed) completedMorningDays++\n\n      totalNightDays++\n      if (dayData?.nightRoutine?.completed) completedNightDays++\n\n      if (defs[dayOfWeek]) {\n        totalWorkoutDays++\n        if (dayData?.workout?.completed) completedWorkoutDays++\n      }\n    }\n\n    const weeklyCompletion =\n      totalWorkoutDays > 0 ? (completedWorkoutDays / totalWorkoutDays) * 100 : 0\n\n    const monthlyCompletion =\n      totalWorkoutDays > 0 ? (completedWorkoutDays / totalWorkoutDays) * 100 : 0\n\n    return {\n      currentStreak,\n      longestStreak,\n      weeklyCompletion: Math.round(weeklyCompletion),\n      monthlyCompletion: Math.round(monthlyCompletion),\n      totalDaysActive:\n        completedWorkoutDays + completedMorningDays + completedNightDays,\n      lastActiveDate: lastActiveDate?.toISOString(),\n      streaks: {\n        workouts: currentStreak,\n        morningRoutines: completedMorningDays,\n        nightRoutines: completedNightDays,\n      },\n    }\n  }\n\n  /**\n   * Get consistency stats (uses local JSON routine only).\n   * Prefer using the adapter in production so routine/defs come from Supabase.\n   */\n  async getConsistencyStats(): Promise<ConsistencyStats> {\n    const routine = await this.getRoutine()\n    if (!routine) {\n      throw new Error('No routine found')\n    }\n    return this.getConsistencyStatsForRoutine(routine)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/fitness.adapter.ts"],"sourcesContent":["/**\r\n * Fitness Adapter\r\n * Replaces JSON file storage with Supabase for fitness routines and progress\r\n * \r\n * Fitness data is primarily stored in Supabase. The local JSON file\r\n * serves as a fallback/seed when Supabase has no data or is unavailable.\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp } from './base.adapter'\r\nimport { FitnessService } from '@/lib/services/fitness.service'\r\nimport type {\r\n  WeeklyRoutine,\r\n  FitnessProgress,\r\n  ConsistencyStats,\r\n  DayOfWeek,\r\n  Workout,\r\n} from '@/lib/types/fitness.types'\r\nimport type {\r\n  RoutineVersion,\r\n  RoutineVersionSummary,\r\n  CreateVersionRequest,\r\n  UpdateVersionRequest,\r\n  VersionsListResponse,\r\n} from '@/lib/types/routine-editor.types'\r\nimport type {\r\n  FitnessRoutineVersionRow,\r\n  FitnessRoutineVersionInsert,\r\n  WorkoutDefinitionRow,\r\n  WorkoutDefinitionInsert,\r\n} from '@/lib/supabase/types'\r\nimport type {\r\n  FitnessRoutineRow,\r\n  FitnessRoutineInsert,\r\n  FitnessWeekRow,\r\n  FitnessWeekInsert,\r\n  FitnessProgressRow,\r\n  FitnessProgressInsert,\r\n} from '@/lib/supabase/types'\r\n\r\n/**\r\n * Fitness Adapter - manages fitness routines and progress\r\n * \r\n * This adapter uses Supabase as the primary data store.\r\n * The JSON file is used as a fallback/seed when Supabase has no data.\r\n */\r\nexport class FitnessAdapter extends BaseAdapter<WeeklyRoutine, WeeklyRoutine> {\r\n  private fitnessService: FitnessService\r\n  private currentRoutineId: string = 'climber-physique'\r\n\r\n  constructor(debug: boolean = false) {\r\n    super({ serviceName: 'fitness', debug })\r\n    this.fitnessService = new FitnessService()\r\n  }\r\n\r\n  /**\r\n   * Check if fitness service is available\r\n   * Fitness uses Supabase as primary storage, but local JSON as fallback.\r\n   * Always returns true since JSON fallback is always available.\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    // Fitness service is always \"available\" - we either use Supabase\r\n    // or fall back to local JSON files\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Fetch from service (JSON file) - used as fallback/seed\r\n   */\r\n  protected async fetchFromService(): Promise<WeeklyRoutine> {\r\n    const routine = await this.fitnessService.getRoutine()\r\n    if (!routine) {\r\n      throw new Error('No fitness routine found')\r\n    }\r\n    return routine\r\n  }\r\n\r\n  /**\r\n   * Fetch from Supabase cache\r\n   */\r\n  protected async fetchFromCache(): Promise<WeeklyRoutine | null> {\r\n    return this.getRoutineFromSupabase()\r\n  }\r\n\r\n  /**\r\n   * Write routine to Supabase\r\n   */\r\n  protected async writeToCache(data: WeeklyRoutine): Promise<SyncResult> {\r\n    return this.saveRoutineToSupabase(data)\r\n  }\r\n\r\n  // ==========================================\r\n  // Supabase Operations\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get routine from Supabase\r\n   */\r\n  private async getRoutineFromSupabase(): Promise<WeeklyRoutine | null> {\r\n    if (!this.isSupabaseAvailable()) return null\r\n\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n      \r\n      // Get the routine\r\n      const { data: routineData, error: routineError } = await clientAny\r\n        .from('fitness_routines')\r\n        .select('*')\r\n        .eq('id', this.currentRoutineId)\r\n        .single()\r\n\r\n      if (routineError || !routineData) {\r\n        this.log('No routine found in Supabase')\r\n        return null\r\n      }\r\n\r\n      // Get weeks for this routine\r\n      const { data: weeksData, error: weeksError } = await clientAny\r\n        .from('fitness_weeks')\r\n        .select('*')\r\n        .eq('routine_id', this.currentRoutineId)\r\n        .order('year', { ascending: false })\r\n        .order('week_number', { ascending: false })\r\n\r\n      if (weeksError) throw weeksError\r\n\r\n      const row = routineData as FitnessRoutineRow\r\n      const weeks = (weeksData ?? []) as FitnessWeekRow[]\r\n\r\n      // Reconstruct the WeeklyRoutine object\r\n      const routine: WeeklyRoutine = {\r\n        id: row.id,\r\n        name: row.name,\r\n        userProfile: row.user_profile,\r\n        injuryProtocol: row.injury_protocol ?? {\r\n          status: 'inactive',\r\n          name: '',\r\n          description: '',\r\n          dailyRehab: [],\r\n          rules: [],\r\n        },\r\n        schedule: row.schedule,\r\n        dailyRoutines: row.daily_routines,\r\n        weeks: weeks.map(w => ({\r\n          weekNumber: w.week_number,\r\n          startDate: w.start_date,\r\n          days: w.days as WeeklyRoutine['weeks'][0]['days'],\r\n        })),\r\n        createdAt: row.created_at,\r\n        updatedAt: row.updated_at,\r\n      }\r\n\r\n      return routine\r\n    } catch (error) {\r\n      this.logError('Error fetching routine from Supabase', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save routine to Supabase\r\n   */\r\n  private async saveRoutineToSupabase(routine: WeeklyRoutine): Promise<SyncResult> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    let recordsWritten = 0\r\n\r\n    try {\r\n      // Upsert the main routine\r\n      const routineInsert: FitnessRoutineInsert = {\r\n        id: routine.id,\r\n        name: routine.name,\r\n        user_profile: routine.userProfile,\r\n        injury_protocol: routine.injuryProtocol,\r\n        schedule: routine.schedule,\r\n        daily_routines: routine.dailyRoutines,\r\n        updated_at: getCurrentTimestamp(),\r\n      }\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n      \r\n      const { error: routineError } = await clientAny\r\n        .from('fitness_routines')\r\n        .upsert(routineInsert, { onConflict: 'id' })\r\n\r\n      if (routineError) throw routineError\r\n      recordsWritten++\r\n\r\n      // Upsert weeks\r\n      for (const week of routine.weeks) {\r\n        const weekInsert: FitnessWeekInsert = {\r\n          routine_id: routine.id,\r\n          week_number: week.weekNumber,\r\n          year: new Date(week.startDate).getFullYear(),\r\n          start_date: week.startDate.split('T')[0] ?? week.startDate,\r\n          days: week.days,\r\n          updated_at: getCurrentTimestamp(),\r\n        }\r\n\r\n        const { error: weekError } = await clientAny\r\n          .from('fitness_weeks')\r\n          .upsert(weekInsert, { onConflict: 'routine_id,week_number,year' })\r\n\r\n        if (weekError) throw weekError\r\n        recordsWritten++\r\n      }\r\n\r\n      return { success: true, recordsWritten }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error saving routine to Supabase', error)\r\n      return { success: false, recordsWritten, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get the current weekly routine\r\n   * Tries Supabase first, falls back to JSON file, then seeds Supabase\r\n   */\r\n  async getRoutine(): Promise<WeeklyRoutine | null> {\r\n    // Try Supabase first\r\n    if (this.isSupabaseAvailable()) {\r\n      const supabaseRoutine = await this.getRoutineFromSupabase()\r\n      if (supabaseRoutine) {\r\n        return supabaseRoutine\r\n      }\r\n\r\n      // No data in Supabase - try to seed from JSON file\r\n      this.log('No routine in Supabase, attempting to seed from JSON file')\r\n      try {\r\n        const fileRoutine = await this.fetchFromService()\r\n        await this.saveRoutineToSupabase(fileRoutine)\r\n        this.log('Seeded Supabase from JSON file')\r\n        return fileRoutine\r\n      } catch (error) {\r\n        this.logError('Failed to seed from JSON file', error)\r\n      }\r\n    }\r\n\r\n    // Fallback to JSON file\r\n    return this.fitnessService.getRoutine()\r\n  }\r\n\r\n  /**\r\n   * Get workout definition for a specific day\r\n   * Checks active version in Supabase first, falls back to JSON file\r\n   */\r\n  async getWorkoutForDay(day: DayOfWeek, weekNumber?: number): Promise<Workout | null> {\r\n    // Try to get from active version in Supabase first\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getReadClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          const { data, error } = await clientAny\r\n            .from('fitness_routine_versions')\r\n            .select('workout_definitions')\r\n            .eq('routine_id', this.currentRoutineId)\r\n            .eq('is_active', true)\r\n            .single()\r\n\r\n          if (!error && data?.workout_definitions?.[day]) {\r\n            return data.workout_definitions[day] as Workout\r\n          }\r\n        } catch {\r\n          // Fall back to JSON file\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to JSON file\r\n    return this.fitnessService.getWorkoutForDay(day, weekNumber)\r\n  }\r\n\r\n  /**\r\n   * Get weekly progress\r\n   */\r\n  async getWeeklyProgress(weekNumber?: number): Promise<FitnessProgress> {\r\n    // For now, delegate to the service which handles the logic\r\n    // In the future, we could read directly from fitness_progress table\r\n    return this.fitnessService.getWeeklyProgress(weekNumber)\r\n  }\r\n\r\n  /**\r\n   * Get consistency stats\r\n   * Uses routine and workout definitions from Supabase (or JSON fallback) so it works in production.\r\n   */\r\n  async getConsistencyStats(): Promise<ConsistencyStats> {\r\n    const routine = await this.getRoutine()\r\n    if (!routine) {\r\n      throw new Error('No routine found')\r\n    }\r\n    const workoutDefinitions = await this.getWorkoutDefinitions(this.currentRoutineId)\r\n    return this.fitnessService.getConsistencyStatsForRoutine(routine, workoutDefinitions)\r\n  }\r\n\r\n  /**\r\n   * Mark a workout as complete\r\n   */\r\n  async markWorkoutComplete(\r\n    day: DayOfWeek,\r\n    weekNumber: number,\r\n    exercisesCompleted?: string[]\r\n  ): Promise<void> {\r\n    // Update via the service (which updates JSON)\r\n    await this.fitnessService.markWorkoutComplete(day, weekNumber, exercisesCompleted)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        await this.saveRoutineToSupabase(routine)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a daily routine (morning/night) as complete\r\n   */\r\n  async markRoutineComplete(\r\n    routineType: 'morning' | 'night',\r\n    day: DayOfWeek,\r\n    weekNumber: number\r\n  ): Promise<void> {\r\n    // Update via the service (which updates JSON)\r\n    await this.fitnessService.markRoutineComplete(routineType, day, weekNumber)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        await this.saveRoutineToSupabase(routine)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark a daily routine as incomplete (undo)\r\n   */\r\n  async markRoutineIncomplete(\r\n    routineType: 'morning' | 'night',\r\n    day: DayOfWeek,\r\n    weekNumber: number\r\n  ): Promise<void> {\r\n    // Update via the service (which updates JSON)\r\n    await this.fitnessService.markRoutineIncomplete(routineType, day, weekNumber)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        await this.saveRoutineToSupabase(routine)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the routine\r\n   */\r\n  async updateRoutine(routine: WeeklyRoutine): Promise<WeeklyRoutine> {\r\n    // Update JSON file\r\n    const updated = await this.fitnessService.updateRoutine(routine)\r\n    \r\n    // Also update Supabase if available\r\n    if (this.isSupabaseAvailable()) {\r\n      await this.saveRoutineToSupabase(updated)\r\n    }\r\n    \r\n    return updated\r\n  }\r\n\r\n  /**\r\n   * Sync routine from JSON file to Supabase\r\n   * Useful for initial data migration\r\n   */\r\n  async syncFromJsonToSupabase(): Promise<SyncResult> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    try {\r\n      const routine = await this.fetchFromService()\r\n      return this.saveRoutineToSupabase(routine)\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      return { success: false, recordsWritten: 0, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current week number\r\n   */\r\n  getCurrentWeekNumber(): number {\r\n    const now = new Date()\r\n    const startOfYear = new Date(now.getFullYear(), 0, 1)\r\n    const days = Math.floor((now.getTime() - startOfYear.getTime()) / (24 * 60 * 60 * 1000))\r\n    return Math.ceil((days + startOfYear.getDay() + 1) / 7)\r\n  }\r\n\r\n  /**\r\n   * Get current day of week\r\n   */\r\n  getCurrentDayOfWeek(): DayOfWeek {\r\n    const days: DayOfWeek[] = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']\r\n    return days[new Date().getDay()] ?? 'monday'\r\n  }\r\n\r\n  // ==========================================\r\n  // Version Management Methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get all versions for a routine\r\n   * Falls back to creating a virtual version from JSON files if Supabase is unavailable\r\n   */\r\n  async getVersions(routineId: string): Promise<VersionsListResponse> {\r\n    // Try Supabase first\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getReadClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          const { data, error } = await clientAny\r\n            .from('fitness_routine_versions')\r\n            .select('id, version_number, name, change_summary, is_active, is_draft, created_at, activated_at')\r\n            .eq('routine_id', routineId)\r\n            .order('version_number', { ascending: false })\r\n\r\n          if (!error && data && data.length > 0) {\r\n            const versions: RoutineVersionSummary[] = data.map((row: Partial<FitnessRoutineVersionRow>) => ({\r\n              id: row.id!,\r\n              versionNumber: row.version_number!,\r\n              name: row.name!,\r\n              changeSummary: row.change_summary ?? undefined,\r\n              isActive: row.is_active!,\r\n              isDraft: row.is_draft!,\r\n              createdAt: row.created_at!,\r\n              activatedAt: row.activated_at ?? undefined,\r\n            }))\r\n\r\n            const activeVersion = versions.find(v => v.isActive)\r\n            \r\n            // Only consider drafts newer than active version as \"the draft\"\r\n            // (older drafts are orphaned and should be cleaned up)\r\n            const activeVersionNum = activeVersion?.versionNumber ?? 0\r\n            const validDrafts = versions.filter(v => v.isDraft && v.versionNumber > activeVersionNum)\r\n            const draftVersion = validDrafts[0] // Newest draft (already sorted desc)\r\n\r\n            return { versions, activeVersion, draftVersion }\r\n          }\r\n        } catch (error) {\r\n          this.logError('Error fetching versions from Supabase', error)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to JSON files - create a virtual \"active\" version\r\n    try {\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        const virtualVersion: RoutineVersionSummary = {\r\n          id: 'json-fallback',\r\n          versionNumber: 1,\r\n          name: routine.name,\r\n          changeSummary: 'Loaded from local files',\r\n          isActive: true,\r\n          isDraft: false,\r\n          createdAt: routine.updatedAt ?? new Date().toISOString(),\r\n        }\r\n        return { \r\n          versions: [virtualVersion], \r\n          activeVersion: virtualVersion,\r\n          draftVersion: undefined \r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error creating virtual version from JSON', error)\r\n    }\r\n\r\n    return { versions: [] }\r\n  }\r\n\r\n  /**\r\n   * Get a specific version by ID\r\n   * Handles the special 'json-fallback' ID for local file data\r\n   */\r\n  async getVersion(versionId: string): Promise<RoutineVersion | null> {\r\n    // Handle JSON fallback version\r\n    if (versionId === 'json-fallback') {\r\n      try {\r\n        const routine = await this.fitnessService.getRoutine()\r\n        const workoutDefinitions = await this.fitnessService.getWorkoutDefinitions()\r\n        \r\n        if (!routine) return null\r\n\r\n        return {\r\n          id: 'json-fallback',\r\n          routineId: this.currentRoutineId,\r\n          versionNumber: 1,\r\n          name: routine.name,\r\n          changeSummary: 'Loaded from local files',\r\n          userProfile: routine.userProfile,\r\n          injuryProtocol: routine.injuryProtocol,\r\n          schedule: routine.schedule,\r\n          dailyRoutines: routine.dailyRoutines,\r\n          workoutDefinitions,\r\n          isActive: true,\r\n          isDraft: false,\r\n          createdAt: routine.updatedAt ?? new Date().toISOString(),\r\n          updatedAt: routine.updatedAt ?? new Date().toISOString(),\r\n        }\r\n      } catch (error) {\r\n        this.logError('Error loading version from JSON files', error)\r\n        return null\r\n      }\r\n    }\r\n\r\n    // Try Supabase\r\n    if (!this.isSupabaseAvailable()) {\r\n      return null\r\n    }\r\n\r\n    const client = this.getReadClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .select('*')\r\n        .eq('id', versionId)\r\n        .single()\r\n\r\n      if (error || !data) return null\r\n\r\n      const row = data as FitnessRoutineVersionRow\r\n      return this.rowToVersion(row)\r\n    } catch (error) {\r\n      this.logError('Error fetching version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new version (draft by default)\r\n   * Uses retry logic to handle race conditions with version numbers\r\n   */\r\n  async createVersion(request: CreateVersionRequest, retryCount = 0): Promise<RoutineVersion | null> {\r\n    const MAX_RETRIES = 3\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      // Create version from current JSON files if Supabase not available\r\n      const routine = await this.fitnessService.getRoutine()\r\n      const workoutDefinitions = await this.fitnessService.getWorkoutDefinitions()\r\n      \r\n      if (!routine) return null\r\n\r\n      // Return a mock version object\r\n      return {\r\n        id: crypto.randomUUID(),\r\n        routineId: request.routineId,\r\n        versionNumber: 1,\r\n        name: request.name ?? routine.name,\r\n        changeSummary: request.changeSummary,\r\n        userProfile: routine.userProfile,\r\n        injuryProtocol: routine.injuryProtocol,\r\n        schedule: routine.schedule,\r\n        dailyRoutines: routine.dailyRoutines,\r\n        workoutDefinitions,\r\n        isActive: false,\r\n        isDraft: true,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      }\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // Get the latest version number using MAX aggregate for accuracy\r\n      const { data: versionData } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .select('version_number')\r\n        .eq('routine_id', request.routineId)\r\n        .order('version_number', { ascending: false })\r\n        .limit(1)\r\n\r\n      const maxVersion = versionData?.[0]?.version_number ?? 0\r\n      const nextVersionNumber = maxVersion + 1\r\n\r\n      // Get base data - either from specified version or current active\r\n      let baseData: RoutineVersion | null = null\r\n      if (request.basedOnVersionId) {\r\n        baseData = await this.getVersion(request.basedOnVersionId)\r\n      }\r\n\r\n      if (!baseData) {\r\n        // Get current active version or fall back to JSON files\r\n        const { data: activeData } = await clientAny\r\n          .from('fitness_routine_versions')\r\n          .select('*')\r\n          .eq('routine_id', request.routineId)\r\n          .eq('is_active', true)\r\n          .single()\r\n\r\n        if (activeData) {\r\n          baseData = this.rowToVersion(activeData as FitnessRoutineVersionRow)\r\n        } else {\r\n          // Fall back to JSON files\r\n          const routine = await this.fitnessService.getRoutine()\r\n          const workoutDefinitions = await this.fitnessService.getWorkoutDefinitions()\r\n          \r\n          if (!routine) return null\r\n\r\n          baseData = {\r\n            id: '',\r\n            routineId: request.routineId,\r\n            versionNumber: 0,\r\n            name: routine.name,\r\n            userProfile: routine.userProfile,\r\n            injuryProtocol: routine.injuryProtocol,\r\n            schedule: routine.schedule,\r\n            dailyRoutines: routine.dailyRoutines,\r\n            workoutDefinitions,\r\n            isActive: false,\r\n            isDraft: false,\r\n            createdAt: new Date().toISOString(),\r\n            updatedAt: new Date().toISOString(),\r\n          }\r\n        }\r\n      }\r\n\r\n      // Create new version\r\n      const insert: FitnessRoutineVersionInsert = {\r\n        routine_id: request.routineId,\r\n        version_number: nextVersionNumber,\r\n        name: request.name ?? `Version ${nextVersionNumber}`,\r\n        change_summary: request.changeSummary ?? undefined,\r\n        user_profile: baseData.userProfile,\r\n        injury_protocol: baseData.injuryProtocol ?? undefined,\r\n        schedule: baseData.schedule,\r\n        daily_routines: baseData.dailyRoutines,\r\n        workout_definitions: baseData.workoutDefinitions,\r\n        is_active: false,\r\n        is_draft: true,\r\n        updated_at: getCurrentTimestamp(),\r\n      }\r\n\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .insert(insert)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return this.rowToVersion(data as FitnessRoutineVersionRow)\r\n    } catch (error: unknown) {\r\n      // Check if it's a duplicate key error (code 23505)\r\n      const pgError = error as { code?: string }\r\n      if (pgError.code === '23505' && retryCount < MAX_RETRIES) {\r\n        this.log(`Duplicate version number, retrying (attempt ${retryCount + 1}/${MAX_RETRIES})`)\r\n        // Small delay before retry to reduce collision chance\r\n        await new Promise(resolve => setTimeout(resolve, 100 * (retryCount + 1)))\r\n        return this.createVersion(request, retryCount + 1)\r\n      }\r\n      \r\n      this.logError('Error creating version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a draft version\r\n   * Handles json-fallback by saving directly to JSON files\r\n   */\r\n  async updateVersion(versionId: string, updates: UpdateVersionRequest): Promise<RoutineVersion | null> {\r\n    // Handle JSON fallback version - save directly to files\r\n    if (versionId === 'json-fallback') {\r\n      try {\r\n        const routine = await this.fitnessService.getRoutine()\r\n        if (!routine) return null\r\n\r\n        // Update routine\r\n        if (updates.name !== undefined) routine.name = updates.name\r\n        if (updates.userProfile !== undefined) routine.userProfile = updates.userProfile\r\n        if (updates.injuryProtocol !== undefined) routine.injuryProtocol = updates.injuryProtocol\r\n        if (updates.schedule !== undefined) routine.schedule = updates.schedule\r\n        if (updates.dailyRoutines !== undefined) {\r\n          routine.dailyRoutines = {\r\n            morning: updates.dailyRoutines.morning ?? routine.dailyRoutines.morning,\r\n            night: updates.dailyRoutines.night ?? routine.dailyRoutines.night,\r\n          }\r\n        }\r\n        \r\n        await this.fitnessService.updateRoutine(routine)\r\n\r\n        // Update workout definitions if provided\r\n        if (updates.workoutDefinitions !== undefined) {\r\n          const currentDefs = await this.fitnessService.getWorkoutDefinitions()\r\n          const updatedDefs = { ...currentDefs, ...updates.workoutDefinitions }\r\n          await this.fitnessService.updateWorkoutDefinitions(updatedDefs)\r\n        }\r\n\r\n        // Return updated version\r\n        return this.getVersion('json-fallback')\r\n      } catch (error) {\r\n        this.logError('Error updating JSON fallback version', error)\r\n        return null\r\n      }\r\n    }\r\n\r\n    // Supabase path\r\n    if (!this.isSupabaseAvailable()) {\r\n      return null\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // First get the existing version to check if it's a draft\r\n      const existing = await this.getVersion(versionId)\r\n      if (!existing || !existing.isDraft) {\r\n        return null // Can only update drafts\r\n      }\r\n\r\n      // Build update object\r\n      const updateData: Partial<FitnessRoutineVersionInsert> = {\r\n        updated_at: getCurrentTimestamp(),\r\n      }\r\n\r\n      if (updates.name !== undefined) updateData.name = updates.name\r\n      if (updates.changeSummary !== undefined) updateData.change_summary = updates.changeSummary\r\n      if (updates.userProfile !== undefined) updateData.user_profile = updates.userProfile\r\n      if (updates.injuryProtocol !== undefined) updateData.injury_protocol = updates.injuryProtocol\r\n      if (updates.schedule !== undefined) updateData.schedule = updates.schedule\r\n      if (updates.dailyRoutines !== undefined) {\r\n        updateData.daily_routines = {\r\n          morning: updates.dailyRoutines.morning ?? existing.dailyRoutines.morning,\r\n          night: updates.dailyRoutines.night ?? existing.dailyRoutines.night,\r\n        }\r\n      }\r\n      if (updates.workoutDefinitions !== undefined) {\r\n        updateData.workout_definitions = {\r\n          ...existing.workoutDefinitions,\r\n          ...updates.workoutDefinitions,\r\n        }\r\n      }\r\n\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .update(updateData)\r\n        .eq('id', versionId)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return this.rowToVersion(data as FitnessRoutineVersionRow)\r\n    } catch (error) {\r\n      this.logError('Error updating version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate a version\r\n   */\r\n  async activateVersion(versionId: string): Promise<RoutineVersion | null> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return null\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return null\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // Get the version to activate\r\n      const version = await this.getVersion(versionId)\r\n      if (!version) return null\r\n\r\n      // Update to active (trigger will deactivate others)\r\n      const { data, error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .update({\r\n          is_active: true,\r\n          is_draft: false,\r\n          activated_at: getCurrentTimestamp(),\r\n          updated_at: getCurrentTimestamp(),\r\n        })\r\n        .eq('id', versionId)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      // Sync to JSON files and main routine table\r\n      const activatedVersion = this.rowToVersion(data as FitnessRoutineVersionRow)\r\n      await this.syncVersionToFiles(activatedVersion)\r\n      await this.syncVersionToRoutineTable(activatedVersion)\r\n\r\n      return activatedVersion\r\n    } catch (error) {\r\n      this.logError('Error activating version', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a draft version\r\n   */\r\n  async deleteVersion(versionId: string): Promise<boolean> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return false\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return false\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // First check if it's a draft (only drafts can be deleted)\r\n      const version = await this.getVersion(versionId)\r\n      if (!version || !version.isDraft) {\r\n        return false\r\n      }\r\n\r\n      const { error } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .delete()\r\n        .eq('id', versionId)\r\n\r\n      return !error\r\n    } catch (error) {\r\n      this.logError('Error deleting version', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up duplicate/orphaned versions\r\n   * Keeps the active version and optionally the newest draft if it's newer\r\n   * Returns summary of what was cleaned up\r\n   */\r\n  async cleanupVersions(routineId: string): Promise<{\r\n    kept: { active?: string; draft?: string }\r\n    deleted: number\r\n    versions: { id: string; versionNumber: number; status: string }[]\r\n  }> {\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { kept: {}, deleted: 0, versions: [] }\r\n    }\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { kept: {}, deleted: 0, versions: [] }\r\n    }\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      // Get all versions sorted by version_number descending\r\n      const { data: allVersions, error: fetchError } = await clientAny\r\n        .from('fitness_routine_versions')\r\n        .select('id, version_number, is_active, is_draft, name')\r\n        .eq('routine_id', routineId)\r\n        .order('version_number', { ascending: false })\r\n\r\n      if (fetchError || !allVersions) {\r\n        throw fetchError || new Error('Failed to fetch versions')\r\n      }\r\n\r\n      // Find active version\r\n      const activeVersion = allVersions.find((v: { is_active: boolean }) => v.is_active)\r\n      \r\n      // Find newest draft that's newer than active (or any draft if no active)\r\n      const activeVersionNum = activeVersion?.version_number ?? 0\r\n      const newerDrafts = allVersions.filter((v: { is_draft: boolean; version_number: number }) => \r\n        v.is_draft && v.version_number > activeVersionNum\r\n      )\r\n      const newestDraft = newerDrafts[0] // Already sorted desc\r\n\r\n      // Determine what to keep\r\n      const keepIds = new Set<string>()\r\n      if (activeVersion) keepIds.add(activeVersion.id)\r\n      if (newestDraft) keepIds.add(newestDraft.id)\r\n\r\n      // If nothing to keep, keep the newest version\r\n      if (keepIds.size === 0 && allVersions.length > 0) {\r\n        keepIds.add(allVersions[0].id)\r\n      }\r\n\r\n      // Delete everything else\r\n      const toDelete = allVersions.filter((v: { id: string }) => !keepIds.has(v.id))\r\n      \r\n      if (toDelete.length > 0) {\r\n        const deleteIds = toDelete.map((v: { id: string }) => v.id)\r\n        const { error: deleteError } = await clientAny\r\n          .from('fitness_routine_versions')\r\n          .delete()\r\n          .in('id', deleteIds)\r\n\r\n        if (deleteError) {\r\n          this.logError('Error deleting versions during cleanup', deleteError)\r\n        }\r\n      }\r\n\r\n      // Return summary\r\n      const keptVersions = allVersions.filter((v: { id: string }) => keepIds.has(v.id))\r\n      return {\r\n        kept: {\r\n          active: activeVersion?.id,\r\n          draft: newestDraft?.id,\r\n        },\r\n        deleted: toDelete.length,\r\n        versions: keptVersions.map((v: { id: string; version_number: number; is_active: boolean; is_draft: boolean }) => ({\r\n          id: v.id,\r\n          versionNumber: v.version_number,\r\n          status: v.is_active ? 'active' : v.is_draft ? 'draft' : 'inactive',\r\n        })),\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error cleaning up versions', error)\r\n      return { kept: {}, deleted: 0, versions: [] }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // Workout Definitions Methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get workout definitions for a routine\r\n   */\r\n  async getWorkoutDefinitions(routineId: string): Promise<Record<DayOfWeek, Workout>> {\r\n    // First try to get from active version in Supabase\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getReadClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          const { data, error } = await clientAny\r\n            .from('fitness_routine_versions')\r\n            .select('workout_definitions')\r\n            .eq('routine_id', routineId)\r\n            .eq('is_active', true)\r\n            .single()\r\n\r\n          if (!error && data?.workout_definitions) {\r\n            return data.workout_definitions as Record<DayOfWeek, Workout>\r\n          }\r\n        } catch {\r\n          // Fall back to JSON files\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to JSON files\r\n    return this.fitnessService.getWorkoutDefinitions()\r\n  }\r\n\r\n  /**\r\n   * Update all workout definitions for a routine\r\n   */\r\n  async updateWorkoutDefinitions(\r\n    routineId: string,\r\n    definitions: Record<DayOfWeek, Workout>\r\n  ): Promise<Record<DayOfWeek, Workout>> {\r\n    // Update JSON file\r\n    await this.fitnessService.updateWorkoutDefinitions(definitions)\r\n\r\n    // Update active version if Supabase is available\r\n    if (this.isSupabaseAvailable()) {\r\n      const client = this.getWriteClient()\r\n      if (client) {\r\n        try {\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n          const clientAny = client as any\r\n\r\n          await clientAny\r\n            .from('fitness_routine_versions')\r\n            .update({\r\n              workout_definitions: definitions,\r\n              updated_at: getCurrentTimestamp(),\r\n            })\r\n            .eq('routine_id', routineId)\r\n            .eq('is_active', true)\r\n        } catch (error) {\r\n          this.logError('Error updating workout definitions in Supabase', error)\r\n        }\r\n      }\r\n    }\r\n\r\n    return definitions\r\n  }\r\n\r\n  /**\r\n   * Update workout definition for a specific day\r\n   */\r\n  async updateWorkoutDefinition(\r\n    routineId: string,\r\n    day: DayOfWeek,\r\n    workout: Workout\r\n  ): Promise<Workout> {\r\n    const definitions = await this.getWorkoutDefinitions(routineId)\r\n    definitions[day] = workout\r\n    await this.updateWorkoutDefinitions(routineId, definitions)\r\n    return workout\r\n  }\r\n\r\n  // ==========================================\r\n  // Helper Methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Convert database row to RoutineVersion\r\n   */\r\n  private rowToVersion(row: FitnessRoutineVersionRow): RoutineVersion {\r\n    return {\r\n      id: row.id,\r\n      routineId: row.routine_id,\r\n      versionNumber: row.version_number,\r\n      name: row.name,\r\n      changeSummary: row.change_summary ?? undefined,\r\n      userProfile: row.user_profile,\r\n      injuryProtocol: row.injury_protocol ?? undefined,\r\n      schedule: row.schedule,\r\n      dailyRoutines: row.daily_routines,\r\n      workoutDefinitions: row.workout_definitions,\r\n      isActive: row.is_active,\r\n      isDraft: row.is_draft,\r\n      createdAt: row.created_at,\r\n      updatedAt: row.updated_at,\r\n      activatedAt: row.activated_at ?? undefined,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sync activated version to JSON files\r\n   */\r\n  private async syncVersionToFiles(version: RoutineVersion): Promise<void> {\r\n    try {\r\n      // Update routine file\r\n      const routine = await this.fitnessService.getRoutine()\r\n      if (routine) {\r\n        routine.name = version.name\r\n        routine.userProfile = version.userProfile\r\n        routine.injuryProtocol = version.injuryProtocol ?? routine.injuryProtocol\r\n        routine.schedule = version.schedule\r\n        routine.dailyRoutines = version.dailyRoutines\r\n        await this.fitnessService.updateRoutine(routine)\r\n      }\r\n\r\n      // Update workout definitions file\r\n      await this.fitnessService.updateWorkoutDefinitions(version.workoutDefinitions)\r\n    } catch (error) {\r\n      this.logError('Error syncing version to files', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sync activated version to fitness_routines table\r\n   */\r\n  private async syncVersionToRoutineTable(version: RoutineVersion): Promise<void> {\r\n    if (!this.isSupabaseAvailable()) return\r\n\r\n    const client = this.getWriteClient()\r\n    if (!client) return\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      await clientAny\r\n        .from('fitness_routines')\r\n        .upsert({\r\n          id: version.routineId,\r\n          name: version.name,\r\n          user_profile: version.userProfile,\r\n          injury_protocol: version.injuryProtocol,\r\n          schedule: version.schedule,\r\n          daily_routines: version.dailyRoutines,\r\n          updated_at: getCurrentTimestamp(),\r\n        }, { onConflict: 'id' })\r\n    } catch (error) {\r\n      this.logError('Error syncing version to routine table', error)\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet fitnessAdapterInstance: FitnessAdapter | null = null\r\n\r\nexport function getFitnessAdapter(): FitnessAdapter {\r\n  if (!fitnessAdapterInstance) {\r\n    fitnessAdapterInstance = new FitnessAdapter()\r\n  }\r\n  return fitnessAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1866, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/app/api/fitness/consistency/route.ts"],"sourcesContent":["import { handleApiError, successResponse } from '@/lib/api/utils'\r\nimport { getFitnessAdapter } from '@/lib/adapters/fitness.adapter'\r\nimport { NextRequest } from 'next/server'\r\n\r\nexport async function GET(_request: NextRequest) {\r\n  try {\r\n    const adapter = getFitnessAdapter()\r\n    const stats = await adapter.getConsistencyStats()\r\n    return successResponse(stats)\r\n  } catch (error) {\r\n    return handleApiError(error)\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGO,eAAe,IAAI,QAAqB;IAC7C,IAAI;QACF,MAAM,UAAU,IAAA,4JAAiB;QACjC,MAAM,QAAQ,MAAM,QAAQ,mBAAmB;QAC/C,OAAO,IAAA,wIAAe,EAAC;IACzB,EAAE,OAAO,OAAO;QACd,OAAO,IAAA,uIAAc,EAAC;IACxB;AACF"}}]
}