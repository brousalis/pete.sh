{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/supabase/client.ts"],"sourcesContent":["/**\r\n * Supabase Client\r\n * Initializes and exports Supabase clients for the application\r\n */\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\r\nimport type { Database } from './types'\r\n\r\n// Environment variables\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n/**\r\n * Check if a string is a valid HTTP/HTTPS URL\r\n */\r\nfunction isValidUrl(urlString: string | undefined): boolean {\r\n  if (!urlString) return false\r\n  try {\r\n    const url = new URL(urlString)\r\n    return url.protocol === 'http:' || url.protocol === 'https:'\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Supabase is properly configured with valid credentials\r\n */\r\nexport function isSupabaseConfigured(): boolean {\r\n  // Check that URL exists and is a valid HTTP/HTTPS URL\r\n  if (!isValidUrl(supabaseUrl)) return false\r\n  // Check that anon key exists and isn't a placeholder\r\n  if (!supabaseAnonKey || supabaseAnonKey.includes('your-') || supabaseAnonKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n/**\r\n * Check if service role key is available and valid (for writes)\r\n */\r\nexport function hasServiceRoleKey(): boolean {\r\n  if (!supabaseServiceKey) return false\r\n  // Check it's not a placeholder\r\n  if (supabaseServiceKey.includes('your-') || supabaseServiceKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n// Singleton instances\r\nlet anonClient: SupabaseClient<Database> | null = null\r\nlet serviceClient: SupabaseClient<Database> | null = null\r\n\r\n/**\r\n * Get the public Supabase client (anon key)\r\n * Use this for read operations and client-side queries\r\n * Returns null if not configured (call isSupabaseConfigured() first)\r\n */\r\nexport function getSupabaseClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!anonClient) {\r\n    try {\r\n      anonClient = createClient<Database>(supabaseUrl!, supabaseAnonKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return anonClient\r\n}\r\n\r\n/**\r\n * Get the service role Supabase client\r\n * Use this for server-side write operations (local mode only)\r\n * Returns null if not configured\r\n * WARNING: Never expose this in client-side code\r\n */\r\nexport function getSupabaseServiceClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!hasServiceRoleKey()) {\r\n    return null\r\n  }\r\n\r\n  if (!serviceClient) {\r\n    try {\r\n      serviceClient = createClient<Database>(supabaseUrl!, supabaseServiceKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return serviceClient\r\n}\r\n\r\n/**\r\n * Get the appropriate client based on operation type\r\n * - For reads: use anon client\r\n * - For writes: use service client (if available) or anon client\r\n * Returns null if Supabase is not configured\r\n */\r\nexport function getSupabaseClientForOperation(operation: 'read' | 'write'): SupabaseClient<Database> | null {\r\n  if (operation === 'write' && hasServiceRoleKey()) {\r\n    return getSupabaseServiceClient()\r\n  }\r\n  return getSupabaseClient()\r\n}\r\n\r\n// Export types for convenience\r\nexport type { Database }\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGC,GAED;;AAGA,wBAAwB;AACxB,MAAM;AACN,MAAM;AACN,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;AAEhE;;CAEC,GACD,SAAS,WAAW,SAA6B;IAC/C,IAAI,CAAC,WAAW,OAAO;IACvB,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;IACtD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,SAAS;IACd,sDAAsD;IACtD,IAAI,CAAC,WAAW,cAAc,OAAO;IACrC,qDAAqD;IACrD,IAAI,CAAC,mBAAmB,gBAAgB,QAAQ,CAAC,YAAY,gBAAgB,MAAM,GAAG,IAAI,OAAO;IACjG,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,oBAAoB,OAAO;IAChC,+BAA+B;IAC/B,IAAI,mBAAmB,QAAQ,CAAC,YAAY,mBAAmB,MAAM,GAAG,IAAI,OAAO;IACnF,OAAO;AACT;AAEA,sBAAsB;AACtB,IAAI,aAA8C;AAClD,IAAI,gBAAiD;AAO9C,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,YAAY;QACf,IAAI;YACF,aAAa,IAAA,gMAAY,EAAW,aAAc,iBAAkB;gBAClE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,eAAe;QAClB,IAAI;YACF,gBAAgB,IAAA,gMAAY,EAAW,aAAc,oBAAqB;gBACxE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,8BAA8B,SAA2B;IACvE,IAAI,cAAc,WAAW,qBAAqB;QAChD,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/spotify-history.service.ts"],"sourcesContent":["/**\n * Spotify Listening History Service\n * Handles syncing and retrieving Spotify listening history from Supabase\n */\n\nimport {\n  getSupabaseClient,\n  getSupabaseServiceClient,\n  isSupabaseConfigured,\n} from '@/lib/supabase/client'\nimport type { SpotifySyncCursorInsert } from '@/lib/supabase/types'\nimport type {\n  SpotifyHistorySyncResult,\n  SpotifyListeningHistoryEntry,\n  SpotifyListeningStats,\n  SpotifyRecentTrack,\n  SpotifySyncCursor,\n} from '@/lib/types/spotify.types'\nimport { SpotifyService } from './spotify.service'\n\nexport class SpotifyHistoryService {\n  private spotifyService: SpotifyService | null = null\n\n  constructor(spotifyService?: SpotifyService) {\n    this.spotifyService = spotifyService || null\n  }\n\n  /**\n   * Set the authenticated Spotify service for API calls\n   */\n  setSpotifyService(spotifyService: SpotifyService): void {\n    this.spotifyService = spotifyService\n  }\n\n  /**\n   * Check if the service is configured (Supabase available)\n   */\n  isConfigured(): boolean {\n    return isSupabaseConfigured()\n  }\n\n  /**\n   * Get the best client for reads: service role when available (so server-side\n   * reads see the same data as writes), otherwise anon. Fixes mismatch where\n   * sync inserts with service role but getHistory/getTotalTrackCount used anon\n   * and could see 0 rows due to RLS or missing anon policy.\n   */\n  private getReadClient() {\n    return getSupabaseServiceClient() ?? getSupabaseClient()\n  }\n\n  /**\n   * Sync recent plays from Spotify API to Supabase\n   * Returns the number of new tracks added\n   */\n  async syncRecentPlays(): Promise<SpotifyHistorySyncResult> {\n    if (!this.spotifyService) {\n      return {\n        success: false,\n        newTracks: 0,\n        totalTracksInDb: 0,\n        error: 'Spotify service not initialized',\n      }\n    }\n\n    const serviceClient = getSupabaseServiceClient()\n    if (!serviceClient) {\n      return {\n        success: false,\n        newTracks: 0,\n        totalTracksInDb: 0,\n        error: 'Supabase service client not available',\n      }\n    }\n\n    try {\n      // Get the sync cursor to know where we left off\n      const cursor = await this.getSyncCursor()\n\n      // Fetch recent plays from Spotify (max 50)\n      // Note: Spotify's recently-played endpoint only returns last 50 tracks\n      const recentPlays = await this.spotifyService.getRecentlyPlayed(50)\n\n      if (!recentPlays.items || recentPlays.items.length === 0) {\n        return {\n          success: true,\n          newTracks: 0,\n          totalTracksInDb: await this.getTotalTrackCount(),\n        }\n      }\n\n      // Filter out tracks we've already synced\n      const newTracks = cursor.last_played_at\n        ? recentPlays.items.filter(\n            item => new Date(item.played_at) > new Date(cursor.last_played_at!)\n          )\n        : recentPlays.items\n\n      if (newTracks.length === 0) {\n        return {\n          success: true,\n          newTracks: 0,\n          totalTracksInDb: await this.getTotalTrackCount(),\n        }\n      }\n\n      // Transform and insert new tracks\n      const historyEntries = newTracks.map(item =>\n        this.transformToHistoryEntry(item)\n      )\n\n      // Upsert to handle any potential duplicates\n      const { error } = await serviceClient\n        .from('spotify_listening_history')\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Supabase Insert inferred as never for this table\n        .upsert(historyEntries as any, {\n          onConflict: 'track_id,played_at',\n          ignoreDuplicates: true,\n        })\n\n      if (error) {\n        // Only log if it's not a \"table doesn't exist\" error (which is expected before migration)\n        if (error.code !== 'PGRST205') {\n          console.error('[SpotifyHistory] Insert error:', error)\n        }\n        return {\n          success: false,\n          newTracks: 0,\n          totalTracksInDb: 0,\n          error:\n            error.code === 'PGRST205'\n              ? 'Table not found - run migration 004_spotify_listening_history.sql'\n              : error.message,\n        }\n      }\n\n      // Update the sync cursor\n      const newestPlayedAt = newTracks[0]?.played_at\n      if (newestPlayedAt) {\n        await this.updateSyncCursor(newestPlayedAt, historyEntries.length)\n      }\n\n      const totalInDb = await this.getTotalTrackCount()\n\n      return {\n        success: true,\n        newTracks: historyEntries.length,\n        totalTracksInDb: totalInDb,\n        oldestTrack: historyEntries[historyEntries.length - 1]?.played_at,\n        newestTrack: historyEntries[0]?.played_at,\n      }\n    } catch (error) {\n      console.error('[SpotifyHistory] Sync error:', error)\n      return {\n        success: false,\n        newTracks: 0,\n        totalTracksInDb: 0,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      }\n    }\n  }\n\n  /**\n   * Get listening history from Supabase\n   */\n  async getHistory(options?: {\n    limit?: number\n    offset?: number\n    startDate?: Date\n    endDate?: Date\n  }): Promise<SpotifyListeningHistoryEntry[]> {\n    const client = this.getReadClient()\n    if (!client) return []\n\n    const { limit = 50, offset = 0, startDate, endDate } = options || {}\n\n    let query = client\n      .from('spotify_listening_history')\n      .select('*')\n      .order('played_at', { ascending: false })\n      .limit(limit)\n      .range(offset, offset + limit - 1)\n\n    if (startDate) {\n      query = query.gte('played_at', startDate.toISOString())\n    }\n    if (endDate) {\n      query = query.lte('played_at', endDate.toISOString())\n    }\n\n    const { data, error } = await query\n\n    if (error) {\n      // Don't log \"table doesn't exist\" errors - expected before migration\n      if (error.code !== 'PGRST205') {\n        console.error('[SpotifyHistory] Get history error:', error)\n      }\n      return []\n    }\n\n    return (data as SpotifyListeningHistoryEntry[]) || []\n  }\n\n  /**\n   * Get listening stats for a time period\n   */\n  async getStats(days = 30): Promise<SpotifyListeningStats | null> {\n    const client = this.getReadClient()\n    if (!client) return null\n\n    const sinceDate = new Date()\n    sinceDate.setDate(sinceDate.getDate() - days)\n\n    try {\n      // Get total and unique counts\n      const { data: rawData, error: historyError } = await client\n        .from('spotify_listening_history')\n        .select('track_id, track_name, track_artists, duration_ms')\n        .gte('played_at', sinceDate.toISOString())\n\n      if (historyError || !rawData) {\n        // Don't log \"table doesn't exist\" errors - expected before migration\n        if (historyError?.code !== 'PGRST205') {\n          console.error('[SpotifyHistory] Stats error:', historyError)\n        }\n        return null\n      }\n\n      type StatsRow = {\n        track_id: string\n        track_name: string\n        track_artists: string\n        duration_ms: number\n      }\n      const historyData = rawData as StatsRow[]\n\n      // Calculate stats in memory\n      const totalTracks = historyData.length\n      const uniqueTracks = new Set(historyData.map(t => t.track_id)).size\n      const uniqueArtists = new Set(historyData.map(t => t.track_artists)).size\n      const totalListeningTimeMs = historyData.reduce(\n        (sum, t) => sum + (t.duration_ms || 0),\n        0\n      )\n\n      // Find top track\n      const trackCounts = new Map<string, number>()\n      historyData.forEach(t => {\n        trackCounts.set(t.track_name, (trackCounts.get(t.track_name) || 0) + 1)\n      })\n      let topTrack: string | undefined\n      let topTrackCount = 0\n      trackCounts.forEach((count, name) => {\n        if (count > topTrackCount) {\n          topTrackCount = count\n          topTrack = name\n        }\n      })\n\n      // Find top artist\n      const artistCounts = new Map<string, number>()\n      historyData.forEach(t => {\n        artistCounts.set(\n          t.track_artists,\n          (artistCounts.get(t.track_artists) || 0) + 1\n        )\n      })\n      let topArtist: string | undefined\n      let topArtistCount = 0\n      artistCounts.forEach((count, name) => {\n        if (count > topArtistCount) {\n          topArtistCount = count\n          topArtist = name\n        }\n      })\n\n      return {\n        total_tracks: totalTracks,\n        unique_tracks: uniqueTracks,\n        unique_artists: uniqueArtists,\n        total_listening_time_ms: totalListeningTimeMs,\n        top_track: topTrack,\n        top_track_count: topTrackCount,\n        top_artist: topArtist,\n        top_artist_count: topArtistCount,\n      }\n    } catch (error: unknown) {\n      // Don't log \"table doesn't exist\" errors - expected before migration\n      const pgError = error as { code?: string }\n      if (pgError?.code !== 'PGRST205') {\n        console.error('[SpotifyHistory] Stats error:', error)\n      }\n      return null\n    }\n  }\n\n  /**\n   * Get the sync cursor\n   */\n  async getSyncCursor(): Promise<SpotifySyncCursor> {\n    const client = this.getReadClient()\n    const defaultCursor: SpotifySyncCursor = {\n      id: 'default',\n      last_played_at: null,\n      last_sync_at: new Date().toISOString(),\n      total_tracks_synced: 0,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    }\n\n    if (!client) return defaultCursor\n\n    const { data, error } = await client\n      .from('spotify_sync_cursor')\n      .select('*')\n      .eq('id', 'default')\n      .single()\n\n    if (error || !data) {\n      return defaultCursor\n    }\n\n    return data as SpotifySyncCursor\n  }\n\n  /**\n   * Update the sync cursor after successful sync\n   */\n  private async updateSyncCursor(\n    lastPlayedAt: string,\n    newTracksCount: number\n  ): Promise<void> {\n    const serviceClient = getSupabaseServiceClient()\n    if (!serviceClient) return\n\n    const cursor = await this.getSyncCursor()\n\n    const cursorPayload: SpotifySyncCursorInsert = {\n      id: 'default',\n      last_played_at: lastPlayedAt,\n      last_sync_at: new Date().toISOString(),\n      total_tracks_synced: cursor.total_tracks_synced + newTracksCount,\n      updated_at: new Date().toISOString(),\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Supabase Insert inferred as never for this table\n    await serviceClient.from('spotify_sync_cursor').upsert(cursorPayload as any)\n  }\n\n  /**\n   * Get total track count in the history\n   */\n  private async getTotalTrackCount(): Promise<number> {\n    const client = this.getReadClient()\n    if (!client) return 0\n\n    const { count, error } = await client\n      .from('spotify_listening_history')\n      .select('*', { count: 'exact', head: true })\n\n    if (error) return 0\n    return count || 0\n  }\n\n  /**\n   * Transform a Spotify recent track to a history entry\n   */\n  private transformToHistoryEntry(\n    item: SpotifyRecentTrack\n  ): Omit<SpotifyListeningHistoryEntry, 'id' | 'created_at' | 'synced_at'> {\n    const track = item.track\n    return {\n      track_id: track.id,\n      track_uri: track.uri,\n      track_name: track.name,\n      track_artists: track.artists.map(a => a.name).join(', '),\n      track_artist_ids: track.artists.map(a => a.id).join(', '),\n      album_name: track.album.name,\n      album_id: track.album.id,\n      album_image_url: track.album.images?.[0]?.url ?? undefined,\n      duration_ms: track.duration_ms,\n      context_type: item.context?.type ?? undefined,\n      context_uri: item.context?.uri ?? undefined,\n      played_at: item.played_at,\n    }\n  }\n\n  /**\n   * Get tracks grouped by day for a given time period\n   */\n  async getHistoryByDay(\n    days = 7\n  ): Promise<Map<string, SpotifyListeningHistoryEntry[]>> {\n    const startDate = new Date()\n    startDate.setDate(startDate.getDate() - days)\n    startDate.setHours(0, 0, 0, 0)\n\n    const history = await this.getHistory({\n      startDate,\n      limit: 500, // Get more for grouping\n    })\n\n    const byDay = new Map<string, SpotifyListeningHistoryEntry[]>()\n\n    history.forEach(entry => {\n      const date = new Date(entry.played_at).toLocaleDateString('en-US', {\n        weekday: 'short',\n        month: 'short',\n        day: 'numeric',\n      })\n      if (!byDay.has(date)) {\n        byDay.set(date, [])\n      }\n      byDay.get(date)!.push(entry)\n    })\n\n    return byDay\n  }\n}\n\n// Singleton instance\nlet historyServiceInstance: SpotifyHistoryService | null = null\n\nexport function getSpotifyHistoryService(): SpotifyHistoryService {\n  if (!historyServiceInstance) {\n    historyServiceInstance = new SpotifyHistoryService()\n  }\n  return historyServiceInstance\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 459, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/api/cors.ts"],"sourcesContent":["/**\r\n * CORS helper for API routes\r\n */\r\n\r\nimport { NextResponse } from 'next/server'\r\n\r\nexport const CORS_HEADERS = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n  'Access-Control-Allow-Headers': 'Content-Type',\r\n}\r\n\r\nexport function withCors<T>(response: NextResponse<T>): NextResponse<T> {\r\n  Object.entries(CORS_HEADERS).forEach(([key, value]) => {\r\n    response.headers.set(key, value)\r\n  })\r\n  return response\r\n}\r\n\r\nexport function corsOptionsResponse() {\r\n  return NextResponse.json({}, { headers: CORS_HEADERS })\r\n}\r\n\r\nexport function corsErrorResponse(error: string, status: number = 500) {\r\n  return withCors(\r\n    NextResponse.json(\r\n      {\r\n        success: false,\r\n        error,\r\n      },\r\n      { status }\r\n    )\r\n  )\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;CAEC,GAED;;AAEO,MAAM,eAAe;IAC1B,+BAA+B;IAC/B,gCAAgC;IAChC,gCAAgC;AAClC;AAEO,SAAS,SAAY,QAAyB;IACnD,OAAO,OAAO,CAAC,cAAc,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;QAChD,SAAS,OAAO,CAAC,GAAG,CAAC,KAAK;IAC5B;IACA,OAAO;AACT;AAEO,SAAS;IACd,OAAO,gJAAY,CAAC,IAAI,CAAC,CAAC,GAAG;QAAE,SAAS;IAAa;AACvD;AAEO,SAAS,kBAAkB,KAAa,EAAE,SAAiB,GAAG;IACnE,OAAO,SACL,gJAAY,CAAC,IAAI,CACf;QACE,SAAS;QACT;IACF,GACA;QAAE;IAAO;AAGf"}},
    {"offset": {"line": 501, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/app/api/spotify/history/route.ts"],"sourcesContent":["/**\r\n * Spotify Listening History API\r\n * GET - Fetch listening history from Supabase\r\n */\r\n\r\nimport { NextRequest, NextResponse } from \"next/server\"\r\nimport { getSpotifyHistoryService } from \"@/lib/services/spotify-history.service\"\r\nimport { CORS_HEADERS, corsOptionsResponse } from \"@/lib/api/cors\"\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const historyService = getSpotifyHistoryService()\r\n\r\n  if (!historyService.isConfigured()) {\r\n    return NextResponse.json(\r\n      {\r\n        success: true,\r\n        data: {\r\n          history: [],\r\n          count: 0,\r\n        },\r\n        message: \"History service not configured (Supabase required)\",\r\n      },\r\n      { status: 200, headers: CORS_HEADERS }\r\n    )\r\n  }\r\n\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n    const limit = parseInt(searchParams.get(\"limit\") || \"50\", 10)\r\n    const offset = parseInt(searchParams.get(\"offset\") || \"0\", 10)\r\n    const startDate = searchParams.get(\"startDate\")\r\n    const endDate = searchParams.get(\"endDate\")\r\n\r\n    const history = await historyService.getHistory({\r\n      limit: Math.min(limit, 100), // Cap at 100\r\n      offset,\r\n      startDate: startDate ? new Date(startDate) : undefined,\r\n      endDate: endDate ? new Date(endDate) : undefined,\r\n    })\r\n\r\n    return NextResponse.json(\r\n      {\r\n        success: true,\r\n        data: {\r\n          history,\r\n          count: history.length,\r\n          offset,\r\n          limit,\r\n        },\r\n      },\r\n      { headers: CORS_HEADERS }\r\n    )\r\n  } catch (error) {\r\n    console.error(\"[API] History fetch error:\", error)\r\n    return NextResponse.json(\r\n      {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : \"Failed to fetch history\",\r\n      },\r\n      { status: 500, headers: CORS_HEADERS }\r\n    )\r\n  }\r\n}\r\n\r\n// Handle CORS preflight\r\nexport async function OPTIONS() {\r\n  return corsOptionsResponse()\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;;CAGC,GAED;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,MAAM,iBAAiB,IAAA,8KAAwB;IAE/C,IAAI,CAAC,eAAe,YAAY,IAAI;QAClC,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;gBACJ,SAAS,EAAE;gBACX,OAAO;YACT;YACA,SAAS;QACX,GACA;YAAE,QAAQ;YAAK,SAAS,oIAAY;QAAC;IAEzC;IAEA,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY,MAAM;QAC1D,MAAM,SAAS,SAAS,aAAa,GAAG,CAAC,aAAa,KAAK;QAC3D,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,UAAU,aAAa,GAAG,CAAC;QAEjC,MAAM,UAAU,MAAM,eAAe,UAAU,CAAC;YAC9C,OAAO,KAAK,GAAG,CAAC,OAAO;YACvB;YACA,WAAW,YAAY,IAAI,KAAK,aAAa;YAC7C,SAAS,UAAU,IAAI,KAAK,WAAW;QACzC;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,MAAM;gBACJ;gBACA,OAAO,QAAQ,MAAM;gBACrB;gBACA;YACF;QACF,GACA;YAAE,SAAS,oIAAY;QAAC;IAE5B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;YAAK,SAAS,oIAAY;QAAC;IAEzC;AACF;AAGO,eAAe;IACpB,OAAO,IAAA,2IAAmB;AAC5B"}}]
}