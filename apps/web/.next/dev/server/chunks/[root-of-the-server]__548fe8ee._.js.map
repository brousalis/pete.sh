{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/supabase/client.ts"],"sourcesContent":["/**\r\n * Supabase Client\r\n * Initializes and exports Supabase clients for the application\r\n */\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\r\nimport type { Database } from './types'\r\n\r\n// Environment variables\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n/**\r\n * Check if a string is a valid HTTP/HTTPS URL\r\n */\r\nfunction isValidUrl(urlString: string | undefined): boolean {\r\n  if (!urlString) return false\r\n  try {\r\n    const url = new URL(urlString)\r\n    return url.protocol === 'http:' || url.protocol === 'https:'\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Supabase is properly configured with valid credentials\r\n */\r\nexport function isSupabaseConfigured(): boolean {\r\n  // Check that URL exists and is a valid HTTP/HTTPS URL\r\n  if (!isValidUrl(supabaseUrl)) return false\r\n  // Check that anon key exists and isn't a placeholder\r\n  if (!supabaseAnonKey || supabaseAnonKey.includes('your-') || supabaseAnonKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n/**\r\n * Check if service role key is available and valid (for writes)\r\n */\r\nexport function hasServiceRoleKey(): boolean {\r\n  if (!supabaseServiceKey) return false\r\n  // Check it's not a placeholder\r\n  if (supabaseServiceKey.includes('your-') || supabaseServiceKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n// Singleton instances\r\nlet anonClient: SupabaseClient<Database> | null = null\r\nlet serviceClient: SupabaseClient<Database> | null = null\r\n\r\n/**\r\n * Get the public Supabase client (anon key)\r\n * Use this for read operations and client-side queries\r\n * Returns null if not configured (call isSupabaseConfigured() first)\r\n */\r\nexport function getSupabaseClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!anonClient) {\r\n    try {\r\n      anonClient = createClient<Database>(supabaseUrl!, supabaseAnonKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return anonClient\r\n}\r\n\r\n/**\r\n * Get the service role Supabase client\r\n * Use this for server-side write operations (local mode only)\r\n * Returns null if not configured\r\n * WARNING: Never expose this in client-side code\r\n */\r\nexport function getSupabaseServiceClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!hasServiceRoleKey()) {\r\n    return null\r\n  }\r\n\r\n  if (!serviceClient) {\r\n    try {\r\n      serviceClient = createClient<Database>(supabaseUrl!, supabaseServiceKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return serviceClient\r\n}\r\n\r\n/**\r\n * Get the appropriate client based on operation type\r\n * - For reads: use anon client\r\n * - For writes: use service client (if available) or anon client\r\n * Returns null if Supabase is not configured\r\n */\r\nexport function getSupabaseClientForOperation(operation: 'read' | 'write'): SupabaseClient<Database> | null {\r\n  if (operation === 'write' && hasServiceRoleKey()) {\r\n    return getSupabaseServiceClient()\r\n  }\r\n  return getSupabaseClient()\r\n}\r\n\r\n// Export types for convenience\r\nexport type { Database }\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGC,GAED;;AAGA,wBAAwB;AACxB,MAAM;AACN,MAAM;AACN,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;AAEhE;;CAEC,GACD,SAAS,WAAW,SAA6B;IAC/C,IAAI,CAAC,WAAW,OAAO;IACvB,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;IACtD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,SAAS;IACd,sDAAsD;IACtD,IAAI,CAAC,WAAW,cAAc,OAAO;IACrC,qDAAqD;IACrD,IAAI,CAAC,mBAAmB,gBAAgB,QAAQ,CAAC,YAAY,gBAAgB,MAAM,GAAG,IAAI,OAAO;IACjG,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,oBAAoB,OAAO;IAChC,+BAA+B;IAC/B,IAAI,mBAAmB,QAAQ,CAAC,YAAY,mBAAmB,MAAM,GAAG,IAAI,OAAO;IACnF,OAAO;AACT;AAEA,sBAAsB;AACtB,IAAI,aAA8C;AAClD,IAAI,gBAAiD;AAO9C,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,YAAY;QACf,IAAI;YACF,aAAa,IAAA,gMAAY,EAAW,aAAc,iBAAkB;gBAClE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,eAAe;QAClB,IAAI;YACF,gBAAgB,IAAA,gMAAY,EAAW,aAAc,oBAAqB;gBACxE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,8BAA8B,SAA2B;IACvE,IAAI,cAAc,WAAW,qBAAqB;QAChD,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/base.adapter.ts"],"sourcesContent":["/**\r\n * Base Adapter\r\n * Provides common functionality for all service adapters\r\n * \r\n * The adapter pattern allows seamless switching between:\r\n * - Local mode: Fetch from real service + write to Supabase (auto-detected)\r\n * - Production mode: Read from Supabase cache (fallback when services unreachable)\r\n * \r\n * Mode is auto-detected by attempting to reach local services.\r\n * No DEPLOYMENT_MODE env var required.\r\n */\r\n\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\nimport { getSupabaseClient, getSupabaseServiceClient, isSupabaseConfigured, hasServiceRoleKey } from '@/lib/supabase/client'\r\nimport type { Database, ServiceName } from '@/lib/supabase/types'\r\n\r\n// ============================================\r\n// Server-side Connectivity Detection\r\n// ============================================\r\n\r\ninterface ServiceAvailability {\r\n  available: boolean\r\n  checkedAt: Date\r\n  error?: string\r\n}\r\n\r\n/** Cache of service availability checks */\r\nconst serviceAvailabilityCache = new Map<ServiceName, ServiceAvailability>()\r\n\r\n/** How long to cache availability results (ms) */\r\nconst AVAILABILITY_CACHE_TTL = 5 * 60 * 1000 // 5 minutes\r\n\r\n/** Timeout for availability checks (ms) */\r\nexport const AVAILABILITY_CHECK_TIMEOUT = 2000 // 2 seconds\r\n\r\n/**\r\n * Check if a cached availability result is still valid\r\n */\r\nfunction isAvailabilityCacheValid(serviceName: ServiceName): boolean {\r\n  const cached = serviceAvailabilityCache.get(serviceName)\r\n  if (!cached) return false\r\n  \r\n  const age = Date.now() - cached.checkedAt.getTime()\r\n  return age < AVAILABILITY_CACHE_TTL\r\n}\r\n\r\n/**\r\n * Get global service availability status (for health endpoint)\r\n */\r\nexport function getServiceAvailabilityStatus(): Record<ServiceName, ServiceAvailability | null> {\r\n  const result: Record<string, ServiceAvailability | null> = {}\r\n  const services: ServiceName[] = ['hue', 'spotify', 'cta', 'calendar', 'fitness']\r\n  \r\n  for (const service of services) {\r\n    result[service] = serviceAvailabilityCache.get(service) ?? null\r\n  }\r\n  \r\n  return result as Record<ServiceName, ServiceAvailability | null>\r\n}\r\n\r\n/**\r\n * Check if any local service is available (for mode detection)\r\n */\r\nexport function isAnyLocalServiceAvailable(): boolean {\r\n  for (const [, status] of serviceAvailabilityCache) {\r\n    if (status.available) return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Clear the availability cache (for testing or manual refresh)\r\n */\r\nexport function clearAvailabilityCache(): void {\r\n  serviceAvailabilityCache.clear()\r\n}\r\n\r\n// ============================================\r\n// Adapter Types\r\n// ============================================\r\n\r\nexport interface AdapterConfig {\r\n  /** Service name for logging and sync tracking */\r\n  serviceName: ServiceName\r\n  /** Whether to log operations */\r\n  debug?: boolean\r\n}\r\n\r\nexport interface SyncResult {\r\n  success: boolean\r\n  recordsWritten: number\r\n  error?: string\r\n}\r\n\r\n/**\r\n * Base adapter class that all service adapters extend\r\n */\r\nexport abstract class BaseAdapter<TServiceData, TCachedData> {\r\n  protected serviceName: ServiceName\r\n  protected debug: boolean\r\n  \r\n  /** Cached availability status for this adapter instance */\r\n  private localAvailable: boolean | null = null\r\n\r\n  constructor(config: AdapterConfig) {\r\n    this.serviceName = config.serviceName\r\n    this.debug = config.debug ?? false\r\n  }\r\n\r\n  /**\r\n   * Get the Supabase client for read operations\r\n   * Returns null if Supabase is not configured\r\n   */\r\n  protected getReadClient(): SupabaseClient<Database> | null {\r\n    return getSupabaseClient()\r\n  }\r\n\r\n  /**\r\n   * Get the Supabase client for write operations\r\n   * Uses service role key if available (for local mode writes)\r\n   * Returns null if Supabase is not configured\r\n   */\r\n  protected getWriteClient(): SupabaseClient<Database> | null {\r\n    if (hasServiceRoleKey()) {\r\n      return getSupabaseServiceClient()\r\n    }\r\n    return getSupabaseClient()\r\n  }\r\n\r\n  /**\r\n   * Check if Supabase is available for caching\r\n   */\r\n  protected isSupabaseAvailable(): boolean {\r\n    return isSupabaseConfigured()\r\n  }\r\n\r\n  // ============================================\r\n  // Auto-Detection Methods\r\n  // ============================================\r\n\r\n  /**\r\n   * Abstract method to check if the local service is reachable\r\n   * Each adapter implements this with a quick ping to their service\r\n   * Should timeout quickly (< 2 seconds)\r\n   */\r\n  protected abstract checkServiceAvailability(): Promise<boolean>\r\n\r\n  /**\r\n   * Check if local service is available (with caching)\r\n   */\r\n  protected async isLocalServiceAvailable(): Promise<boolean> {\r\n    // Check instance cache first (for multiple calls in same request)\r\n    if (this.localAvailable !== null) {\r\n      return this.localAvailable\r\n    }\r\n\r\n    // Check global cache\r\n    if (isAvailabilityCacheValid(this.serviceName)) {\r\n      const cached = serviceAvailabilityCache.get(this.serviceName)!\r\n      this.localAvailable = cached.available\r\n      return cached.available\r\n    }\r\n\r\n    // Perform actual check\r\n    this.log('Checking local service availability...')\r\n    \r\n    try {\r\n      const available = await this.checkServiceAvailability()\r\n      \r\n      // Cache the result\r\n      serviceAvailabilityCache.set(this.serviceName, {\r\n        available,\r\n        checkedAt: new Date(),\r\n      })\r\n      this.localAvailable = available\r\n      \r\n      this.log(`Local service ${available ? 'available' : 'unavailable'}`)\r\n      return available\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      \r\n      // Cache the failure\r\n      serviceAvailabilityCache.set(this.serviceName, {\r\n        available: false,\r\n        checkedAt: new Date(),\r\n        error: errorMessage,\r\n      })\r\n      this.localAvailable = false\r\n      \r\n      this.log(`Local service check failed: ${errorMessage}`)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if running in local mode (service available)\r\n   * Auto-detects based on service reachability\r\n   */\r\n  protected async isLocal(): Promise<boolean> {\r\n    return this.isLocalServiceAvailable()\r\n  }\r\n\r\n  /**\r\n   * Check if running in production mode (service unavailable)\r\n   * Auto-detects based on service reachability\r\n   */\r\n  protected async isProduction(): Promise<boolean> {\r\n    return !(await this.isLocalServiceAvailable())\r\n  }\r\n\r\n  /**\r\n   * Synchronous check if local - uses cached value\r\n   * Returns false if no cached value (assumes production until proven otherwise)\r\n   */\r\n  protected isLocalSync(): boolean {\r\n    if (this.localAvailable !== null) {\r\n      return this.localAvailable\r\n    }\r\n    \r\n    const cached = serviceAvailabilityCache.get(this.serviceName)\r\n    if (cached && isAvailabilityCacheValid(this.serviceName)) {\r\n      return cached.available\r\n    }\r\n    \r\n    // Default to false (production) if not yet checked\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Log a message if debug is enabled\r\n   */\r\n  protected log(message: string, data?: unknown): void {\r\n    if (this.debug) {\r\n      console.log(`[${this.serviceName.toUpperCase()} Adapter] ${message}`, data ?? '')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log an error\r\n   * Silently ignores Supabase configuration errors to avoid console spam\r\n   */\r\n  protected logError(message: string, error?: unknown): void {\r\n    // Suppress errors related to missing tables or unconfigured Supabase\r\n    if (error && typeof error === 'object') {\r\n      const errObj = error as Record<string, unknown>\r\n      // Suppress table not found errors (migration not run yet)\r\n      if (errObj.code === 'PGRST205' || errObj.code === '42P01') return\r\n      // Suppress connection errors when Supabase isn't properly configured  \r\n      if (errObj.message && String(errObj.message).includes('not configured')) return\r\n    }\r\n    console.error(`[${this.serviceName.toUpperCase()} Adapter] ${message}`, error ?? '')\r\n  }\r\n\r\n  /**\r\n   * Record a sync operation in the sync_log table\r\n   */\r\n  protected async logSync(status: 'success' | 'error', recordsSynced: number = 0, errorMessage?: string): Promise<void> {\r\n    if (!this.isSupabaseAvailable()) return\r\n\r\n    try {\r\n      const client = this.getWriteClient()\r\n      if (!client) return // Supabase not configured\r\n      \r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      await (client.from('sync_log') as any).insert({\r\n        service: this.serviceName,\r\n        status,\r\n        records_synced: recordsSynced,\r\n        error_message: errorMessage ?? null,\r\n        synced_at: new Date().toISOString(),\r\n      })\r\n    } catch (error) {\r\n      // Silently ignore - logging sync shouldn't break the app\r\n      if (this.debug) {\r\n        this.logError('Failed to log sync', error)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the last sync time for this service\r\n   */\r\n  async getLastSyncTime(): Promise<Date | null> {\r\n    if (!this.isSupabaseAvailable()) return null\r\n\r\n    try {\r\n      const client = this.getReadClient()\r\n      if (!client) return null // Supabase not configured\r\n      \r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const { data, error } = await (client.from('sync_log') as any)\r\n        .select('synced_at')\r\n        .eq('service', this.serviceName)\r\n        .eq('status', 'success')\r\n        .order('synced_at', { ascending: false })\r\n        .limit(1)\r\n        .single()\r\n\r\n      if (error || !data) return null\r\n      return new Date((data as { synced_at: string }).synced_at)\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Abstract method to fetch data from the real service\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract fetchFromService(): Promise<TServiceData>\r\n\r\n  /**\r\n   * Abstract method to fetch cached data from Supabase\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract fetchFromCache(): Promise<TCachedData | null>\r\n\r\n  /**\r\n   * Abstract method to write data to Supabase cache\r\n   * Implemented by each service adapter\r\n   */\r\n  protected abstract writeToCache(data: TServiceData): Promise<SyncResult>\r\n\r\n  /**\r\n   * Main method to get data\r\n   * Auto-detects mode:\r\n   * - If local service reachable: fetches from service and writes to cache\r\n   * - If local service unreachable: reads from cache\r\n   */\r\n  async getData(): Promise<TServiceData | TCachedData | null> {\r\n    const isLocalAvailable = await this.isLocal()\r\n    \r\n    if (isLocalAvailable) {\r\n      return this.getDataLocal()\r\n    }\r\n    return this.getDataProduction()\r\n  }\r\n\r\n  /**\r\n   * Get data in local mode\r\n   * Fetches from real service and writes to Supabase\r\n   */\r\n  protected async getDataLocal(): Promise<TServiceData | null> {\r\n    this.log('Fetching from real service (local mode)')\r\n\r\n    try {\r\n      const data = await this.fetchFromService()\r\n      \r\n      // Write to cache in background (don't block the response)\r\n      if (this.isSupabaseAvailable()) {\r\n        this.writeToCache(data)\r\n          .then((result) => {\r\n            if (result.success) {\r\n              this.log(`Cached ${result.recordsWritten} records`)\r\n            } else {\r\n              this.logError('Failed to cache data', result.error)\r\n            }\r\n          })\r\n          .catch((error) => {\r\n            this.logError('Error writing to cache', error)\r\n          })\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from service', error)\r\n      \r\n      // On service error, try falling back to cache\r\n      this.log('Service error, attempting cache fallback...')\r\n      if (this.isSupabaseAvailable()) {\r\n        try {\r\n          const cached = await this.fetchFromCache()\r\n          if (cached) {\r\n            this.log('Using cached data as fallback')\r\n            return cached as TServiceData\r\n          }\r\n        } catch {\r\n          // Cache fallback also failed\r\n        }\r\n      }\r\n      \r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get data in production mode\r\n   * Reads from Supabase cache\r\n   */\r\n  protected async getDataProduction(): Promise<TCachedData | null> {\r\n    this.log('Fetching from cache (production mode)')\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      this.logError('Supabase not configured')\r\n      return null\r\n    }\r\n\r\n    try {\r\n      const data = await this.fetchFromCache()\r\n      \r\n      if (!data) {\r\n        this.log('No cached data available')\r\n        return null\r\n      }\r\n\r\n      return data\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force refresh the cache (local mode only)\r\n   * Fetches from service and writes to cache, waiting for write to complete\r\n   */\r\n  async refreshCache(): Promise<SyncResult> {\r\n    const isLocalAvailable = await this.isLocal()\r\n    \r\n    if (!isLocalAvailable) {\r\n      return { success: false, recordsWritten: 0, error: 'Cache refresh only available when local services are reachable' }\r\n    }\r\n\r\n    if (!this.isSupabaseAvailable()) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n\r\n    this.log('Force refreshing cache')\r\n\r\n    try {\r\n      const data = await this.fetchFromService()\r\n      const result = await this.writeToCache(data)\r\n      \r\n      await this.logSync(result.success ? 'success' : 'error', result.recordsWritten, result.error)\r\n      \r\n      return result\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      await this.logSync('error', 0, errorMessage)\r\n      return { success: false, recordsWritten: 0, error: errorMessage }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Utility function to safely parse JSON from Supabase\r\n */\r\nexport function parseJsonSafe<T>(data: unknown, fallback: T): T {\r\n  if (data === null || data === undefined) return fallback\r\n  if (typeof data === 'object') return data as T\r\n  if (typeof data === 'string') {\r\n    try {\r\n      return JSON.parse(data) as T\r\n    } catch {\r\n      return fallback\r\n    }\r\n  }\r\n  return fallback\r\n}\r\n\r\n/**\r\n * Utility function to get current timestamp in ISO format\r\n */\r\nexport function getCurrentTimestamp(): string {\r\n  return new Date().toISOString()\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/config.ts"],"sourcesContent":["/**\n * Configuration utility for environment variables\n * Validates and provides typed access to environment variables\n */\n\nimport { z } from 'zod'\n\n// Schema for environment variables\nconst envSchema = z.object({\n  // HUE Bridge\n  HUE_BRIDGE_IP: z.string().ip().optional(),\n  HUE_BRIDGE_USERNAME: z.string().optional(),\n  HUE_CLIENT_KEY: z.string().optional(), // Required for entertainment streaming\n\n  // Google\n  GOOGLE_CLIENT_ID: z.string().optional(),\n  GOOGLE_CLIENT_SECRET: z.string().optional(),\n  GOOGLE_API_KEY: z.string().optional(),\n  GOOGLE_CALENDAR_ID: z.string().optional(),\n\n  // Weather\n  WEATHER_LATITUDE: z\n    .string()\n    .regex(/^-?\\d+\\.?\\d*$/)\n    .optional(),\n  WEATHER_LONGITUDE: z\n    .string()\n    .regex(/^-?\\d+\\.?\\d*$/)\n    .optional(),\n\n  // CTA\n  CTA_API_KEY: z.string().optional(),\n  CTA_TRAIN_API_KEY: z.string().optional(),\n\n  // Spotify\n  NEXT_SPOTIFY_CLIENT_ID: z.string().optional(),\n  NEXT_SPOTIFY_CLIENT_SECRET: z.string().optional(),\n\n  // Desktop (local Windows features)\n  DESKTOP_ENABLED: z.string().optional(),\n})\n\n// Parse and validate environment variables\nconst parseEnv = () => {\n  const parsed = envSchema.safeParse(process.env)\n\n  if (!parsed.success) {\n    console.warn(\n      'Environment variable validation warnings:',\n      parsed.error.format()\n    )\n  }\n\n  return parsed.success ? parsed.data : {}\n}\n\nconst env = parseEnv()\n\n/**\n * Configuration object with typed environment variables\n */\nexport const config = {\n  hue: {\n    bridgeIp: env.HUE_BRIDGE_IP,\n    username: env.HUE_BRIDGE_USERNAME,\n    clientKey: env.HUE_CLIENT_KEY, // For entertainment streaming\n    isConfigured: Boolean(env.HUE_BRIDGE_IP && env.HUE_BRIDGE_USERNAME),\n    isEntertainmentConfigured: Boolean(\n      env.HUE_BRIDGE_IP && env.HUE_BRIDGE_USERNAME && env.HUE_CLIENT_KEY\n    ),\n  },\n  google: {\n    clientId: env.GOOGLE_CLIENT_ID,\n    clientSecret: env.GOOGLE_CLIENT_SECRET,\n    apiKey: env.GOOGLE_API_KEY,\n    calendarId: env.GOOGLE_CALENDAR_ID || 'primary',\n    isConfigured: Boolean(\n      env.GOOGLE_CLIENT_ID && env.GOOGLE_CLIENT_SECRET && env.GOOGLE_API_KEY\n    ),\n  },\n  weather: {\n    latitude: env.WEATHER_LATITUDE ? parseFloat(env.WEATHER_LATITUDE) : 41.8781, // Chicago default\n    longitude: env.WEATHER_LONGITUDE\n      ? parseFloat(env.WEATHER_LONGITUDE)\n      : -87.6298, // Chicago default\n  },\n  cta: {\n    apiKey: env.CTA_API_KEY,\n    trainApiKey: env.CTA_TRAIN_API_KEY,\n    isConfigured: Boolean(env.CTA_API_KEY),\n    isTrainConfigured: Boolean(env.CTA_TRAIN_API_KEY),\n  },\n  spotify: {\n    clientId: env.NEXT_SPOTIFY_CLIENT_ID,\n    clientSecret: env.NEXT_SPOTIFY_CLIENT_SECRET,\n    redirectUri: 'http://127.0.0.1:3000/spotify/callback',\n    isConfigured: Boolean(\n      env.NEXT_SPOTIFY_CLIENT_ID && env.NEXT_SPOTIFY_CLIENT_SECRET\n    ),\n    scopes: [\n      'user-read-playback-state',\n      'user-modify-playback-state',\n      'user-read-currently-playing',\n      'user-read-recently-played',\n      'user-library-read',\n      'playlist-read-private',\n      'playlist-read-collaborative',\n      'streaming',\n      'user-read-email',\n      'user-read-private',\n    ],\n  },\n  desktop: {\n    enabled: env.DESKTOP_ENABLED === 'true',\n  },\n} as const\n\n/**\n * Check if running in development mode\n */\nexport const isDev = process.env.NODE_ENV === 'development'\n\n/**\n * Check if running on localhost\n */\nexport const isLocalhost =\n  typeof window !== 'undefined' &&\n  (window.location.hostname === 'localhost' ||\n    window.location.hostname === '127.0.0.1' ||\n    window.location.hostname.startsWith('192.168.') ||\n    window.location.hostname.startsWith('10.'))\n"],"names":[],"mappings":";;;;;;;;AAAA;;;CAGC,GAED;;AAEA,mCAAmC;AACnC,MAAM,YAAY,yKAAC,CAAC,MAAM,CAAC;IACzB,aAAa;IACb,eAAe,yKAAC,CAAC,MAAM,GAAG,EAAE,GAAG,QAAQ;IACvC,qBAAqB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACxC,gBAAgB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAEnC,SAAS;IACT,kBAAkB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACrC,sBAAsB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACzC,gBAAgB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,oBAAoB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAEvC,UAAU;IACV,kBAAkB,yKAAC,CAChB,MAAM,GACN,KAAK,CAAC,iBACN,QAAQ;IACX,mBAAmB,yKAAC,CACjB,MAAM,GACN,KAAK,CAAC,iBACN,QAAQ;IAEX,MAAM;IACN,aAAa,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAChC,mBAAmB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAEtC,UAAU;IACV,wBAAwB,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAC3C,4BAA4B,yKAAC,CAAC,MAAM,GAAG,QAAQ;IAE/C,mCAAmC;IACnC,iBAAiB,yKAAC,CAAC,MAAM,GAAG,QAAQ;AACtC;AAEA,2CAA2C;AAC3C,MAAM,WAAW;IACf,MAAM,SAAS,UAAU,SAAS,CAAC,QAAQ,GAAG;IAE9C,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,QAAQ,IAAI,CACV,6CACA,OAAO,KAAK,CAAC,MAAM;IAEvB;IAEA,OAAO,OAAO,OAAO,GAAG,OAAO,IAAI,GAAG,CAAC;AACzC;AAEA,MAAM,MAAM;AAKL,MAAM,SAAS;IACpB,KAAK;QACH,UAAU,IAAI,aAAa;QAC3B,UAAU,IAAI,mBAAmB;QACjC,WAAW,IAAI,cAAc;QAC7B,cAAc,QAAQ,IAAI,aAAa,IAAI,IAAI,mBAAmB;QAClE,2BAA2B,QACzB,IAAI,aAAa,IAAI,IAAI,mBAAmB,IAAI,IAAI,cAAc;IAEtE;IACA,QAAQ;QACN,UAAU,IAAI,gBAAgB;QAC9B,cAAc,IAAI,oBAAoB;QACtC,QAAQ,IAAI,cAAc;QAC1B,YAAY,IAAI,kBAAkB,IAAI;QACtC,cAAc,QACZ,IAAI,gBAAgB,IAAI,IAAI,oBAAoB,IAAI,IAAI,cAAc;IAE1E;IACA,SAAS;QACP,UAAU,IAAI,gBAAgB,GAAG,WAAW,IAAI,gBAAgB,IAAI;QACpE,WAAW,IAAI,iBAAiB,GAC5B,WAAW,IAAI,iBAAiB,IAChC,CAAC;IACP;IACA,KAAK;QACH,QAAQ,IAAI,WAAW;QACvB,aAAa,IAAI,iBAAiB;QAClC,cAAc,QAAQ,IAAI,WAAW;QACrC,mBAAmB,QAAQ,IAAI,iBAAiB;IAClD;IACA,SAAS;QACP,UAAU,IAAI,sBAAsB;QACpC,cAAc,IAAI,0BAA0B;QAC5C,aAAa;QACb,cAAc,QACZ,IAAI,sBAAsB,IAAI,IAAI,0BAA0B;QAE9D,QAAQ;YACN;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;IACH;IACA,SAAS;QACP,SAAS,IAAI,eAAe,KAAK;IACnC;AACF;AAKO,MAAM,QAAQ,oDAAyB;AAKvC,MAAM,cACX,kDAAkB,eAClB,CAAC,OAAO,QAAQ,CAAC,QAAQ,KAAK,eAC5B,OAAO,QAAQ,CAAC,QAAQ,KAAK,eAC7B,OAAO,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,eACpC,OAAO,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM"}},
    {"offset": {"line": 669, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/hue.service.ts"],"sourcesContent":["/**\r\n * HUE Bridge Service\r\n * Handles communication with Philips HUE bridge\r\n */\r\n\r\nimport axios from \"axios\"\r\nimport { config } from \"@/lib/config\"\r\nimport type { HueLight, HueZone, HueScene } from \"@/lib/types/hue.types\"\r\n\r\nexport class HueService {\r\n  private baseUrl: string\r\n\r\n  constructor() {\r\n    const bridgeIp = config.hue.bridgeIp\r\n    const username = config.hue.username\r\n\r\n    if (!bridgeIp || !username) {\r\n      this.baseUrl = \"\"\r\n      return\r\n    }\r\n\r\n    this.baseUrl = `http://${bridgeIp}/api/${username}`\r\n  }\r\n\r\n  isConfigured(): boolean {\r\n    return config.hue.isConfigured && this.baseUrl !== \"\"\r\n  }\r\n\r\n  /**\r\n   * Get all lights\r\n   */\r\n  async getLights(): Promise<Record<string, HueLight>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<Record<string, HueLight>>(`${this.baseUrl}/lights`)\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a single light by ID\r\n   */\r\n  async getLight(lightId: string): Promise<HueLight> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<HueLight>(`${this.baseUrl}/lights/${lightId}`)\r\n      return { ...response.data, id: lightId }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle an individual light on/off\r\n   */\r\n  async toggleLight(lightId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      // If on is not provided, toggle the current state\r\n      if (on === undefined) {\r\n        const light = await this.getLight(lightId)\r\n        on = !light.state.on\r\n      }\r\n\r\n      const response = await axios.put(`${this.baseUrl}/lights/${lightId}/state`, {\r\n        on,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all zones/rooms\r\n   */\r\n  async getZones(): Promise<Record<string, HueZone>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<Record<string, HueZone>>(`${this.baseUrl}/groups`)\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a single zone by ID\r\n   */\r\n  async getZone(zoneId: string): Promise<HueZone> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<HueZone>(`${this.baseUrl}/groups/${zoneId}`)\r\n      return { ...response.data, id: zoneId }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle a zone on/off\r\n   */\r\n  async toggleZone(zoneId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      // If on is not provided, toggle the current state\r\n      if (on === undefined) {\r\n        const zones = await this.getZones()\r\n        const zone = zones[zoneId]\r\n        if (!zone) {\r\n          throw new Error(`Zone ${zoneId} not found`)\r\n        }\r\n        on = !zone.state.any_on\r\n      }\r\n\r\n      const response = await axios.put(`${this.baseUrl}/groups/${zoneId}/action`, {\r\n        on,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle all lights on/off\r\n   */\r\n  async toggleAllLights(on: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      // Group 0 is special - it always refers to all lights\r\n      const response = await axios.put(`${this.baseUrl}/groups/0/action`, {\r\n        on,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set brightness for all lights\r\n   */\r\n  async setAllBrightness(brightness: number): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    if (brightness < 1 || brightness > 254) {\r\n      throw new Error(\"Brightness must be between 1 and 254\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/0/action`, {\r\n        on: true,\r\n        bri: brightness,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set brightness for a light\r\n   */\r\n  async setBrightness(lightId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    if (brightness < 0 || brightness > 254) {\r\n      throw new Error(\"Brightness must be between 0 and 254\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/lights/${lightId}/state`, {\r\n        bri: brightness,\r\n        on: true,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set brightness for a zone/group\r\n   */\r\n  async setZoneBrightness(zoneId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    if (brightness < 1 || brightness > 254) {\r\n      throw new Error(\"Brightness must be between 1 and 254\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/${zoneId}/action`, {\r\n        bri: brightness,\r\n        on: true,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set light state (comprehensive control)\r\n   */\r\n  async setLightState(\r\n    lightId: string,\r\n    state: {\r\n      on?: boolean\r\n      bri?: number\r\n      hue?: number\r\n      sat?: number\r\n      ct?: number\r\n      xy?: [number, number]\r\n      transitiontime?: number\r\n    }\r\n  ): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(\r\n        `${this.baseUrl}/lights/${lightId}/state`,\r\n        state\r\n      )\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set zone state (comprehensive control)\r\n   */\r\n  async setZoneState(\r\n    zoneId: string,\r\n    state: {\r\n      on?: boolean\r\n      bri?: number\r\n      hue?: number\r\n      sat?: number\r\n      ct?: number\r\n      xy?: [number, number]\r\n      scene?: string\r\n      transitiontime?: number\r\n    }\r\n  ): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(\r\n        `${this.baseUrl}/groups/${zoneId}/action`,\r\n        state\r\n      )\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all scenes\r\n   */\r\n  async getScenes(): Promise<Record<string, HueScene>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get<Record<string, HueScene>>(`${this.baseUrl}/scenes`)\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get scenes for a specific zone (properly filtered)\r\n   */\r\n  async getScenesForZone(zoneId: string): Promise<HueScene[]> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const allScenes = await this.getScenes()\r\n      const zone = await this.getZone(zoneId)\r\n      const zoneLightIds = zone.lights\r\n\r\n      // Filter scenes that belong to this zone\r\n      const zoneScenes = Object.entries(allScenes)\r\n        .filter(([_, scene]) => {\r\n          // Check if scene is explicitly for this group\r\n          if (scene.group === zoneId) return true\r\n          // Check if all scene lights belong to this zone\r\n          if (scene.lights.length > 0) {\r\n            return scene.lights.every((lightId) => zoneLightIds.includes(lightId))\r\n          }\r\n          return false\r\n        })\r\n        .map(([id, scene]) => ({ ...scene, id }))\r\n\r\n      return zoneScenes\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all scenes with their zone information\r\n   */\r\n  async getAllScenesWithZones(): Promise<Array<HueScene & { zoneName?: string }>> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const [scenes, zones] = await Promise.all([\r\n        this.getScenes(),\r\n        this.getZones(),\r\n      ])\r\n\r\n      const zonesArray = Object.entries(zones).map(([id, zone]) => ({\r\n        ...zone,\r\n        id,\r\n      }))\r\n\r\n      return Object.entries(scenes).map(([id, scene]) => {\r\n        const zone = zonesArray.find((z) => z.id === scene.group)\r\n        return {\r\n          ...scene,\r\n          id,\r\n          zoneName: zone?.name,\r\n        }\r\n      })\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find scene by name (case-insensitive partial match)\r\n   */\r\n  async findSceneByName(name: string): Promise<HueScene | null> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const scenes = await this.getScenes()\r\n      const normalizedSearch = name.toLowerCase()\r\n\r\n      const entry = Object.entries(scenes).find(([_, scene]) =>\r\n        scene.name.toLowerCase().includes(normalizedSearch)\r\n      )\r\n\r\n      if (entry) {\r\n        return { ...entry[1], id: entry[0] }\r\n      }\r\n\r\n      return null\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate a scene for a zone\r\n   */\r\n  async activateScene(zoneId: string, sceneId: string): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/${zoneId}/action`, {\r\n        scene: sceneId,\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get lights for a zone with full details\r\n   */\r\n  async getLightsForZone(zoneId: string): Promise<HueLight[]> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const [zone, allLights] = await Promise.all([\r\n        this.getZone(zoneId),\r\n        this.getLights(),\r\n      ])\r\n\r\n      return zone.lights\r\n        .filter((lightId) => allLights[lightId] !== undefined)\r\n        .map((lightId) => {\r\n          const light = allLights[lightId]\r\n          return {\r\n            ...light,\r\n            id: lightId,\r\n          } as HueLight\r\n        })\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get aggregate status for all lights\r\n   */\r\n  async getAllLightsStatus(): Promise<{\r\n    totalLights: number\r\n    lightsOn: number\r\n    anyOn: boolean\r\n    allOn: boolean\r\n    averageBrightness: number\r\n  }> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const lights = await this.getLights()\r\n      const lightsArray = Object.values(lights)\r\n\r\n      const lightsOn = lightsArray.filter((l) => l.state.on).length\r\n      const onLights = lightsArray.filter((l) => l.state.on)\r\n      const avgBrightness =\r\n        onLights.length > 0\r\n          ? Math.round(\r\n              onLights.reduce((sum, l) => sum + (l.state.bri || 0), 0) /\r\n                onLights.length\r\n            )\r\n          : 0\r\n\r\n      return {\r\n        totalLights: lightsArray.length,\r\n        lightsOn,\r\n        anyOn: lightsOn > 0,\r\n        allOn: lightsOn === lightsArray.length,\r\n        averageBrightness: avgBrightness,\r\n      }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all entertainment areas (for Hue Sync)\r\n   */\r\n  async getEntertainmentAreas(): Promise<\r\n    Array<HueZone & { stream?: { proxymode: string; proxynode: string; active: boolean; owner?: string } }>\r\n  > {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const groups = await this.getZones()\r\n      const entertainmentAreas = Object.entries(groups)\r\n        .filter(([_, group]) => group.type === \"Entertainment\")\r\n        .map(([id, group]) => ({\r\n          ...group,\r\n          id,\r\n        }))\r\n\r\n      return entertainmentAreas\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get entertainment area by name (case-insensitive partial match)\r\n   */\r\n  async getEntertainmentAreaByName(\r\n    name: string\r\n  ): Promise<(HueZone & { stream?: { proxymode: string; proxynode: string; active: boolean; owner?: string } }) | null> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const areas = await this.getEntertainmentAreas()\r\n      const normalizedSearch = name.toLowerCase()\r\n\r\n      const area = areas.find((a) => a.name.toLowerCase().includes(normalizedSearch))\r\n\r\n      return area || null\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get entertainment/sync status for an area\r\n   */\r\n  async getEntertainmentStatus(areaId: string): Promise<{\r\n    active: boolean\r\n    owner?: string\r\n    proxymode?: string\r\n  }> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.get(`${this.baseUrl}/groups/${areaId}`)\r\n      const group = response.data\r\n\r\n      return {\r\n        active: group.stream?.active || false,\r\n        owner: group.stream?.owner,\r\n        proxymode: group.stream?.proxymode,\r\n      }\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggle entertainment/streaming mode for an area\r\n   * Note: This enables the entertainment API mode. The actual streaming\r\n   * (sending colors) is done by Hue Sync app or Sync Box.\r\n   * \r\n   * When active=false, this stops any active entertainment session,\r\n   * returning lights to their previous state.\r\n   */\r\n  async setEntertainmentMode(areaId: string, active: boolean): Promise<unknown> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error(\"HUE bridge not configured\")\r\n    }\r\n\r\n    try {\r\n      const response = await axios.put(`${this.baseUrl}/groups/${areaId}`, {\r\n        stream: { active },\r\n      })\r\n\r\n      return response.data\r\n    } catch (error) {\r\n      if (axios.isAxiosError(error)) {\r\n        throw new Error(`HUE API error: ${error.message}`)\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1190, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/adapters/hue.adapter.ts"],"sourcesContent":["/**\r\n * Hue Adapter\r\n * Handles Philips Hue data with write-through caching to Supabase\r\n * \r\n * Auto-detects mode based on Hue bridge reachability:\r\n * - Bridge reachable: Fetches from Hue bridge, writes to Supabase\r\n * - Bridge unreachable: Reads from Supabase cache\r\n */\r\n\r\nimport { BaseAdapter, SyncResult, getCurrentTimestamp, AVAILABILITY_CHECK_TIMEOUT } from './base.adapter'\r\nimport { HueService } from '@/lib/services/hue.service'\r\nimport { config } from '@/lib/config'\r\nimport type { HueLight, HueZone, HueScene, HueAllLightsStatus } from '@/lib/types/hue.types'\r\nimport type { \r\n  HueLightRow, \r\n  HueZoneRow, \r\n  HueSceneRow, \r\n  HueStatusRow,\r\n  HueLightInsert,\r\n  HueZoneInsert,\r\n  HueSceneInsert,\r\n  HueStatusInsert\r\n} from '@/lib/supabase/types'\r\n\r\n// Interfaces for the combined Hue data\r\nexport interface HueFullState {\r\n  lights: Record<string, HueLight>\r\n  zones: HueZone[]\r\n  scenes: HueScene[]\r\n  status: HueAllLightsStatus\r\n}\r\n\r\nexport interface HueCachedState {\r\n  lights: HueLightRow[]\r\n  zones: HueZoneRow[]\r\n  scenes: HueSceneRow[]\r\n  status: HueStatusRow | null\r\n  recordedAt: string\r\n}\r\n\r\n/**\r\n * Hue Adapter - manages all Hue-related data\r\n */\r\nexport class HueAdapter extends BaseAdapter<HueFullState, HueCachedState> {\r\n  private hueService: HueService\r\n\r\n  constructor(debug: boolean = false) {\r\n    super({ serviceName: 'hue', debug })\r\n    this.hueService = new HueService()\r\n  }\r\n\r\n  /**\r\n   * Check if Hue bridge is configured (has IP and username)\r\n   */\r\n  isConfigured(): boolean {\r\n    return this.hueService.isConfigured()\r\n  }\r\n\r\n  /**\r\n   * Check if Hue bridge is reachable\r\n   * Used for auto-detection of local vs production mode\r\n   */\r\n  protected async checkServiceAvailability(): Promise<boolean> {\r\n    // If not configured, definitely not available\r\n    if (!this.isConfigured()) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      const bridgeIp = config.hue.bridgeIp\r\n      const username = config.hue.username\r\n      \r\n      if (!bridgeIp || !username) {\r\n        return false\r\n      }\r\n\r\n      // Quick ping to the bridge config endpoint (doesn't require auth for basic info)\r\n      const controller = new AbortController()\r\n      const timeoutId = setTimeout(() => controller.abort(), AVAILABILITY_CHECK_TIMEOUT)\r\n\r\n      const response = await fetch(`http://${bridgeIp}/api/${username}/config`, {\r\n        method: 'GET',\r\n        signal: controller.signal,\r\n      })\r\n\r\n      clearTimeout(timeoutId)\r\n\r\n      // Bridge is available if we get a valid response\r\n      return response.ok\r\n    } catch {\r\n      // Any error means bridge is not reachable\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch all Hue data from the bridge\r\n   */\r\n  protected async fetchFromService(): Promise<HueFullState> {\r\n    if (!this.isConfigured()) {\r\n      throw new Error('Hue bridge not configured')\r\n    }\r\n\r\n    const [lights, zones, scenes, status] = await Promise.all([\r\n      this.hueService.getLights(),\r\n      this.hueService.getZones(),\r\n      this.hueService.getScenes(),\r\n      this.hueService.getAllLightsStatus(),\r\n    ])\r\n\r\n    // Convert zones object to array with IDs\r\n    const zonesArray = Object.entries(zones)\r\n      .map(([id, zone]) => ({ ...zone, id }))\r\n      .filter(z => z.type === 'Room' || z.type === 'Zone')\r\n\r\n    // Convert scenes object to array with IDs\r\n    const scenesArray = Object.entries(scenes)\r\n      .map(([id, scene]) => ({ ...scene, id }))\r\n\r\n    return {\r\n      lights,\r\n      zones: zonesArray,\r\n      scenes: scenesArray,\r\n      status,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch cached Hue data from Supabase\r\n   */\r\n  protected async fetchFromCache(): Promise<HueCachedState | null> {\r\n    const client = this.getReadClient()\r\n    if (!client) return null // Supabase not configured\r\n\r\n    try {\r\n      // Fetch latest lights, zones, scenes, and status in parallel\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n      const [lightsResult, zonesResult, scenesResult, statusResult] = await Promise.all([\r\n        clientAny.rpc('get_latest_hue_lights'),\r\n        clientAny.rpc('get_latest_hue_zones'),\r\n        clientAny.rpc('get_latest_hue_scenes'),\r\n        clientAny.rpc('get_latest_hue_status'),\r\n      ])\r\n\r\n      if (lightsResult.error) throw lightsResult.error\r\n      if (zonesResult.error) throw zonesResult.error\r\n      if (scenesResult.error) throw scenesResult.error\r\n      if (statusResult.error) throw statusResult.error\r\n\r\n      const lights = (lightsResult.data ?? []) as HueLightRow[]\r\n      const zones = (zonesResult.data ?? []) as HueZoneRow[]\r\n      const scenes = (scenesResult.data ?? []) as HueSceneRow[]\r\n      const status = statusResult.data as HueStatusRow | null\r\n\r\n      // Determine the most recent recorded_at\r\n      const timestamps = [\r\n        ...lights.map(l => l.recorded_at),\r\n        ...zones.map(z => z.recorded_at),\r\n        ...scenes.map(s => s.recorded_at),\r\n        status?.recorded_at,\r\n      ].filter(Boolean) as string[]\r\n\r\n      const recordedAt = timestamps.length > 0 \r\n        ? timestamps.sort().reverse()[0]! \r\n        : new Date().toISOString()\r\n\r\n      return {\r\n        lights,\r\n        zones,\r\n        scenes,\r\n        status,\r\n        recordedAt,\r\n      }\r\n    } catch (error) {\r\n      this.logError('Error fetching from cache', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write Hue data to Supabase\r\n   */\r\n  protected async writeToCache(data: HueFullState): Promise<SyncResult> {\r\n    const client = this.getWriteClient()\r\n    if (!client) {\r\n      return { success: false, recordsWritten: 0, error: 'Supabase not configured' }\r\n    }\r\n    const timestamp = getCurrentTimestamp()\r\n    let recordsWritten = 0\r\n\r\n    try {\r\n      // Write lights\r\n      const lightInserts: HueLightInsert[] = Object.entries(data.lights).map(([id, light]) => ({\r\n        light_id: id,\r\n        name: light.name,\r\n        type: light.type,\r\n        model_id: light.modelid,\r\n        product_name: light.productname,\r\n        state: light.state,\r\n        is_on: light.state.on,\r\n        brightness: light.state.bri ?? null,\r\n        is_reachable: light.state.reachable,\r\n        recorded_at: timestamp,\r\n      }))\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const clientAny = client as any\r\n\r\n      if (lightInserts.length > 0) {\r\n        const { error: lightsError } = await clientAny\r\n          .from('hue_lights')\r\n          .insert(lightInserts)\r\n        \r\n        if (lightsError) throw lightsError\r\n        recordsWritten += lightInserts.length\r\n      }\r\n\r\n      // Write zones\r\n      const zoneInserts: HueZoneInsert[] = data.zones.map(zone => ({\r\n        zone_id: zone.id,\r\n        name: zone.name,\r\n        type: zone.type,\r\n        class: zone.class ?? null,\r\n        lights: zone.lights,\r\n        state: zone.state,\r\n        action: zone.action ?? null,\r\n        any_on: zone.state.any_on,\r\n        all_on: zone.state.all_on,\r\n        recorded_at: timestamp,\r\n      }))\r\n\r\n      if (zoneInserts.length > 0) {\r\n        const { error: zonesError } = await clientAny\r\n          .from('hue_zones')\r\n          .insert(zoneInserts)\r\n        \r\n        if (zonesError) throw zonesError\r\n        recordsWritten += zoneInserts.length\r\n      }\r\n\r\n      // Write scenes\r\n      const sceneInserts: HueSceneInsert[] = data.scenes.map(scene => ({\r\n        scene_id: scene.id,\r\n        name: scene.name,\r\n        type: scene.type,\r\n        zone_id: scene.group ?? null,\r\n        zone_name: scene.zoneName ?? null,\r\n        lights: scene.lights,\r\n        owner: scene.owner ?? null,\r\n        recycle: scene.recycle ?? false,\r\n        locked: scene.locked ?? false,\r\n        recorded_at: timestamp,\r\n      }))\r\n\r\n      if (sceneInserts.length > 0) {\r\n        const { error: scenesError } = await clientAny\r\n          .from('hue_scenes')\r\n          .insert(sceneInserts)\r\n        \r\n        if (scenesError) throw scenesError\r\n        recordsWritten += sceneInserts.length\r\n      }\r\n\r\n      // Write status\r\n      const statusInsert: HueStatusInsert = {\r\n        total_lights: data.status.totalLights,\r\n        lights_on: data.status.lightsOn,\r\n        any_on: data.status.anyOn,\r\n        all_on: data.status.allOn,\r\n        average_brightness: data.status.averageBrightness,\r\n        recorded_at: timestamp,\r\n      }\r\n\r\n      const { error: statusError } = await clientAny\r\n        .from('hue_status')\r\n        .insert(statusInsert)\r\n      \r\n      if (statusError) throw statusError\r\n      recordsWritten += 1\r\n\r\n      return { success: true, recordsWritten }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\r\n      this.logError('Error writing to cache', error)\r\n      return { success: false, recordsWritten, error: errorMessage }\r\n    }\r\n  }\r\n\r\n  // ==========================================\r\n  // High-level API methods\r\n  // ==========================================\r\n\r\n  /**\r\n   * Get all lights status\r\n   */\r\n  async getAllLightsStatus(): Promise<HueAllLightsStatus | null> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      try {\r\n        const status = await this.hueService.getAllLightsStatus()\r\n        \r\n        // Write to cache in background (only if Supabase is configured)\r\n        if (this.isSupabaseAvailable()) {\r\n          const client = this.getWriteClient()\r\n          if (client) {\r\n            const timestamp = getCurrentTimestamp()\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            ;(client as any)\r\n              .from('hue_status')\r\n              .insert({\r\n                total_lights: status.totalLights,\r\n                lights_on: status.lightsOn,\r\n                any_on: status.anyOn,\r\n                all_on: status.allOn,\r\n                average_brightness: status.averageBrightness,\r\n                recorded_at: timestamp,\r\n              })\r\n              .then(({ error }: { error: unknown }) => {\r\n                if (error) this.logError('Failed to cache status', error)\r\n              })\r\n          }\r\n        }\r\n\r\n        return status\r\n      } catch (error) {\r\n        this.logError('Error fetching status', error)\r\n        throw error\r\n      }\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached?.status) return null\r\n\r\n    return {\r\n      totalLights: cached.status.total_lights,\r\n      lightsOn: cached.status.lights_on,\r\n      anyOn: cached.status.any_on,\r\n      allOn: cached.status.all_on,\r\n      averageBrightness: cached.status.average_brightness,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all lights\r\n   */\r\n  async getLights(): Promise<Record<string, HueLight>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getLights()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return {}\r\n\r\n    const lights: Record<string, HueLight> = {}\r\n    for (const row of cached.lights) {\r\n      lights[row.light_id] = {\r\n        id: row.light_id,\r\n        name: row.name,\r\n        type: row.type ?? '',\r\n        modelid: row.model_id ?? '',\r\n        manufacturername: '',\r\n        productname: row.product_name ?? '',\r\n        state: row.state,\r\n        capabilities: { control: { mindimlevel: 0, maxlumen: 0 } },\r\n      }\r\n    }\r\n    return lights\r\n  }\r\n\r\n  /**\r\n   * Get all zones\r\n   */\r\n  async getZones(): Promise<Record<string, HueZone>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getZones()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return {}\r\n\r\n    const zones: Record<string, HueZone> = {}\r\n    for (const row of cached.zones) {\r\n      zones[row.zone_id] = {\r\n        id: row.zone_id,\r\n        name: row.name,\r\n        type: row.type ?? '',\r\n        class: row.class ?? undefined,\r\n        lights: row.lights,\r\n        state: row.state,\r\n        action: row.action ?? undefined,\r\n      }\r\n    }\r\n    return zones\r\n  }\r\n\r\n  /**\r\n   * Get all scenes\r\n   */\r\n  async getScenes(): Promise<Record<string, HueScene>> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getScenes()\r\n    }\r\n\r\n    // Production mode - read from cache\r\n    const cached = await this.fetchFromCache()\r\n    if (!cached) return {}\r\n\r\n    const scenes: Record<string, HueScene> = {}\r\n    for (const row of cached.scenes) {\r\n      scenes[row.scene_id] = {\r\n        id: row.scene_id,\r\n        name: row.name,\r\n        type: row.type ?? '',\r\n        group: row.zone_id ?? undefined,\r\n        zoneName: row.zone_name ?? undefined,\r\n        lights: row.lights,\r\n        owner: row.owner ?? undefined,\r\n        recycle: row.recycle,\r\n        locked: row.locked,\r\n      }\r\n    }\r\n    return scenes\r\n  }\r\n\r\n  /**\r\n   * Get scenes for a specific zone\r\n   */\r\n  async getScenesForZone(zoneId: string): Promise<HueScene[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getScenesForZone(zoneId)\r\n    }\r\n\r\n    // Production mode - filter cached scenes\r\n    const scenes = await this.getScenes()\r\n    return Object.values(scenes).filter(scene => scene.group === zoneId)\r\n  }\r\n\r\n  /**\r\n   * Get a specific zone\r\n   */\r\n  async getZone(zoneId: string): Promise<HueZone | null> {\r\n    const zones = await this.getZones()\r\n    return zones[zoneId] ?? null\r\n  }\r\n\r\n  /**\r\n   * Get lights for a specific zone\r\n   */\r\n  async getLightsForZone(zoneId: string): Promise<HueLight[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getLightsForZone(zoneId)\r\n    }\r\n\r\n    // Production mode - get zone and filter lights\r\n    const [zone, allLights] = await Promise.all([\r\n      this.getZone(zoneId),\r\n      this.getLights(),\r\n    ])\r\n\r\n    if (!zone) return []\r\n\r\n    return zone.lights\r\n      .filter(lightId => allLights[lightId] !== undefined)\r\n      .map(lightId => {\r\n        const light = allLights[lightId]!\r\n        return { ...light, id: lightId }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Get entertainment areas\r\n   */\r\n  async getEntertainmentAreas(): Promise<HueZone[]> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getEntertainmentAreas()\r\n    }\r\n\r\n    // Production mode - filter cached zones\r\n    const zones = await this.getZones()\r\n    return Object.values(zones).filter(z => z.type === 'Entertainment')\r\n  }\r\n\r\n  /**\r\n   * Get entertainment status for an area\r\n   */\r\n  async getEntertainmentStatus(areaId: string): Promise<{ active: boolean; owner?: string; proxymode?: string }> {\r\n    const isLocal = await this.isLocal()\r\n    \r\n    if (isLocal) {\r\n      return this.hueService.getEntertainmentStatus(areaId)\r\n    }\r\n\r\n    // Production mode - return inactive (can't know real status)\r\n    return { active: false }\r\n  }\r\n\r\n  // ==========================================\r\n  // Mutation methods (local mode only)\r\n  // Use isLocalSync() since by the time controls are enabled,\r\n  // the availability check has already been cached\r\n  // ==========================================\r\n\r\n  async toggleLight(lightId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.toggleLight(lightId, on)\r\n  }\r\n\r\n  async toggleZone(zoneId: string, on?: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.toggleZone(zoneId, on)\r\n  }\r\n\r\n  async toggleAllLights(on: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.toggleAllLights(on)\r\n  }\r\n\r\n  async setBrightness(lightId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setBrightness(lightId, brightness)\r\n  }\r\n\r\n  async setZoneBrightness(zoneId: string, brightness: number): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setZoneBrightness(zoneId, brightness)\r\n  }\r\n\r\n  async setAllBrightness(brightness: number): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setAllBrightness(brightness)\r\n  }\r\n\r\n  async activateScene(zoneId: string, sceneId: string): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.activateScene(zoneId, sceneId)\r\n  }\r\n\r\n  async setLightState(lightId: string, state: Parameters<HueService['setLightState']>[1]): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setLightState(lightId, state)\r\n  }\r\n\r\n  async setZoneState(zoneId: string, state: Parameters<HueService['setZoneState']>[1]): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setZoneState(zoneId, state)\r\n  }\r\n\r\n  async setEntertainmentMode(areaId: string, active: boolean): Promise<unknown> {\r\n    if (!this.isLocalSync()) throw new Error('Controls only available when local services are reachable')\r\n    return this.hueService.setEntertainmentMode(areaId, active)\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nlet hueAdapterInstance: HueAdapter | null = null\r\n\r\nexport function getHueAdapter(): HueAdapter {\r\n  if (!hueAdapterInstance) {\r\n    hueAdapterInstance = new HueAdapter()\r\n  }\r\n  return hueAdapterInstance\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1664, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/app/api/health/route.ts"],"sourcesContent":["/**\n * GET /api/health - Health check endpoint for connectivity detection\n * \n * This endpoint is used by the client to determine if the local instance\n * is reachable. When accessible, the client can use local APIs directly.\n * \n * The response includes:\n * - mode: 'local' if any local services are reachable, 'production' otherwise\n * - instanceId: Identifier to verify it's the correct instance\n * - services: Status of each service's availability (cached results)\n */\n\nimport { NextResponse } from \"next/server\"\nimport { getHueAdapter } from \"@/lib/adapters/hue.adapter\"\nimport { getServiceAvailabilityStatus, isAnyLocalServiceAvailable } from \"@/lib/adapters/base.adapter\"\n\nexport async function GET() {\n  // Trigger a Hue bridge check if not already cached\n  // This is the primary indicator of \"local mode\" since Hue requires local network\n  const hueAdapter = getHueAdapter()\n  \n  // Check if Hue is reachable (this will cache the result)\n  let hueAvailable = false\n  try {\n    // Use the adapter's availability check\n    hueAvailable = await hueAdapter['isLocalServiceAvailable']()\n  } catch {\n    // Ignore errors - just means not available\n  }\n\n  // Determine mode based on service availability\n  const isLocal = hueAvailable || isAnyLocalServiceAvailable()\n  \n  return NextResponse.json({\n    ok: true,\n    mode: isLocal ? \"local\" : \"production\",\n    timestamp: new Date().toISOString(),\n    // Include a unique identifier so the client can verify it's the right instance\n    instanceId: \"petehome-local\",\n    // Include service availability status for debugging\n    services: getServiceAvailabilityStatus(),\n  }, {\n    headers: {\n      // Allow cross-origin requests from production domain\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type\",\n      // Prevent caching of health checks\n      \"Cache-Control\": \"no-store, no-cache, must-revalidate\",\n    },\n  })\n}\n\nexport async function OPTIONS() {\n  return NextResponse.json({}, {\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type\",\n    },\n  })\n}\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;;;;;CAUC,GAED;AACA;AACA;;;;AAEO,eAAe;IACpB,mDAAmD;IACnD,iFAAiF;IACjF,MAAM,aAAa,IAAA,oJAAa;IAEhC,yDAAyD;IACzD,IAAI,eAAe;IACnB,IAAI;QACF,uCAAuC;QACvC,eAAe,MAAM,UAAU,CAAC,0BAA0B;IAC5D,EAAE,OAAM;IACN,2CAA2C;IAC7C;IAEA,+CAA+C;IAC/C,MAAM,UAAU,gBAAgB,IAAA,kKAA0B;IAE1D,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB,IAAI;QACJ,MAAM,UAAU,UAAU;QAC1B,WAAW,IAAI,OAAO,WAAW;QACjC,+EAA+E;QAC/E,YAAY;QACZ,oDAAoD;QACpD,UAAU,IAAA,oKAA4B;IACxC,GAAG;QACD,SAAS;YACP,qDAAqD;YACrD,+BAA+B;YAC/B,gCAAgC;YAChC,gCAAgC;YAChC,mCAAmC;YACnC,iBAAiB;QACnB;IACF;AACF;AAEO,eAAe;IACpB,OAAO,gJAAY,CAAC,IAAI,CAAC,CAAC,GAAG;QAC3B,SAAS;YACP,+BAA+B;YAC/B,gCAAgC;YAChC,gCAAgC;QAClC;IACF;AACF"}}]
}