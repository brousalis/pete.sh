{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/supabase/client.ts"],"sourcesContent":["/**\r\n * Supabase Client\r\n * Initializes and exports Supabase clients for the application\r\n */\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\r\nimport type { Database } from './types'\r\n\r\n// Environment variables\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n/**\r\n * Check if a string is a valid HTTP/HTTPS URL\r\n */\r\nfunction isValidUrl(urlString: string | undefined): boolean {\r\n  if (!urlString) return false\r\n  try {\r\n    const url = new URL(urlString)\r\n    return url.protocol === 'http:' || url.protocol === 'https:'\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Supabase is properly configured with valid credentials\r\n */\r\nexport function isSupabaseConfigured(): boolean {\r\n  // Check that URL exists and is a valid HTTP/HTTPS URL\r\n  if (!isValidUrl(supabaseUrl)) return false\r\n  // Check that anon key exists and isn't a placeholder\r\n  if (!supabaseAnonKey || supabaseAnonKey.includes('your-') || supabaseAnonKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n/**\r\n * Check if service role key is available and valid (for writes)\r\n */\r\nexport function hasServiceRoleKey(): boolean {\r\n  if (!supabaseServiceKey) return false\r\n  // Check it's not a placeholder\r\n  if (supabaseServiceKey.includes('your-') || supabaseServiceKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n// Singleton instances\r\nlet anonClient: SupabaseClient<Database> | null = null\r\nlet serviceClient: SupabaseClient<Database> | null = null\r\n\r\n/**\r\n * Get the public Supabase client (anon key)\r\n * Use this for read operations and client-side queries\r\n * Returns null if not configured (call isSupabaseConfigured() first)\r\n */\r\nexport function getSupabaseClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!anonClient) {\r\n    try {\r\n      anonClient = createClient<Database>(supabaseUrl!, supabaseAnonKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return anonClient\r\n}\r\n\r\n/**\r\n * Get the service role Supabase client\r\n * Use this for server-side write operations (local mode only)\r\n * Returns null if not configured\r\n * WARNING: Never expose this in client-side code\r\n */\r\nexport function getSupabaseServiceClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!hasServiceRoleKey()) {\r\n    return null\r\n  }\r\n\r\n  if (!serviceClient) {\r\n    try {\r\n      serviceClient = createClient<Database>(supabaseUrl!, supabaseServiceKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return serviceClient\r\n}\r\n\r\n/**\r\n * Get the appropriate client based on operation type\r\n * - For reads: use anon client\r\n * - For writes: use service client (if available) or anon client\r\n * Returns null if Supabase is not configured\r\n */\r\nexport function getSupabaseClientForOperation(operation: 'read' | 'write'): SupabaseClient<Database> | null {\r\n  if (operation === 'write' && hasServiceRoleKey()) {\r\n    return getSupabaseServiceClient()\r\n  }\r\n  return getSupabaseClient()\r\n}\r\n\r\n// Export types for convenience\r\nexport type { Database }\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGC,GAED;;AAGA,wBAAwB;AACxB,MAAM;AACN,MAAM;AACN,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;AAEhE;;CAEC,GACD,SAAS,WAAW,SAA6B;IAC/C,IAAI,CAAC,WAAW,OAAO;IACvB,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;IACtD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,SAAS;IACd,sDAAsD;IACtD,IAAI,CAAC,WAAW,cAAc,OAAO;IACrC,qDAAqD;IACrD,IAAI,CAAC,mBAAmB,gBAAgB,QAAQ,CAAC,YAAY,gBAAgB,MAAM,GAAG,IAAI,OAAO;IACjG,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,oBAAoB,OAAO;IAChC,+BAA+B;IAC/B,IAAI,mBAAmB,QAAQ,CAAC,YAAY,mBAAmB,MAAM,GAAG,IAAI,OAAO;IACnF,OAAO;AACT;AAEA,sBAAsB;AACtB,IAAI,aAA8C;AAClD,IAAI,gBAAiD;AAO9C,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,YAAY;QACf,IAAI;YACF,aAAa,IAAA,gMAAY,EAAW,aAAc,iBAAkB;gBAClE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,eAAe;QAClB,IAAI;YACF,gBAAgB,IAAA,gMAAY,EAAW,aAAc,oBAAqB;gBACxE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,8BAA8B,SAA2B;IACvE,IAAI,cAAc,WAAW,qBAAqB;QAChD,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/cooking.service.ts"],"sourcesContent":["/**\r\n * Cooking Service\r\n * Handles recipe storage, version history, and management\r\n */\r\n\r\nimport { getSupabaseClientForOperation } from '@/lib/supabase/client'\r\nimport type {\r\n  Recipe,\r\n  RecipeWithIngredients,\r\n  RecipeIngredient,\r\n  RecipeVersion,\r\n  RecipeFilters,\r\n  CreateRecipeInput,\r\n  UpdateRecipeInput,\r\n} from '@/lib/types/cooking.types'\r\n\r\nexport class CookingService {\r\n  /**\r\n   * Get recipes with optional filters\r\n   */\r\n  async getRecipes(filters?: RecipeFilters): Promise<Recipe[]> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    let query = supabase.from('recipes').select('*').order('created_at', { ascending: false })\r\n\r\n    if (filters?.search) {\r\n      query = query.ilike('name', `%${filters.search}%`)\r\n    }\r\n\r\n    if (filters?.source) {\r\n      query = query.eq('source', filters.source)\r\n    }\r\n\r\n    if (filters?.difficulty) {\r\n      query = query.eq('difficulty', filters.difficulty)\r\n    }\r\n\r\n    if (filters?.is_favorite !== undefined) {\r\n      query = query.eq('is_favorite', filters.is_favorite)\r\n    }\r\n\r\n    if (filters?.tags && filters.tags.length > 0) {\r\n      query = query.contains('tags', filters.tags)\r\n    }\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) {\r\n      console.error('Error fetching recipes:', error)\r\n      throw new Error(`Failed to fetch recipes: ${error.message}`)\r\n    }\r\n\r\n    return (data || []) as Recipe[]\r\n  }\r\n\r\n  /**\r\n   * Get a single recipe with ingredients\r\n   */\r\n  async getRecipe(id: string): Promise<RecipeWithIngredients | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get recipe\r\n    const { data: recipeData, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      if (recipeError.code === 'PGRST116') {\r\n        return null // Not found\r\n      }\r\n      console.error('Error fetching recipe:', recipeError)\r\n      throw new Error(`Failed to fetch recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    // Get ingredients\r\n    const { data: ingredientsData, error: ingredientsError } = await supabase\r\n      .from('recipe_ingredients')\r\n      .select('*')\r\n      .eq('recipe_id', id)\r\n      .order('order_index', { ascending: true })\r\n\r\n    if (ingredientsError) {\r\n      console.error('Error fetching ingredients:', ingredientsError)\r\n      throw new Error(`Failed to fetch ingredients: ${ingredientsError.message}`)\r\n    }\r\n\r\n    const recipe = recipeData as Recipe\r\n    const ingredients = (ingredientsData || []) as RecipeIngredient[]\r\n\r\n    return {\r\n      ...recipe,\r\n      ingredients,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new recipe\r\n   */\r\n  async createRecipe(input: CreateRecipeInput): Promise<RecipeWithIngredients> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const {\r\n      ingredients,\r\n      instructions = [],\r\n      tags = [],\r\n      is_favorite = false,\r\n      source = 'custom',\r\n      ...recipeData\r\n    } = input\r\n\r\n    // Insert recipe\r\n    const { data: recipe, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .insert({\r\n        ...recipeData,\r\n        instructions: instructions as unknown as Record<string, unknown>,\r\n        tags: tags || [],\r\n        is_favorite,\r\n        source,\r\n        updated_at: new Date().toISOString(),\r\n      } as never)\r\n      .select()\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      console.error('Error creating recipe:', recipeError)\r\n      throw new Error(`Failed to create recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    const recipeId = (recipe as Recipe).id\r\n\r\n    // Insert ingredients if provided\r\n    if (ingredients && ingredients.length > 0) {\r\n      const ingredientsToInsert = ingredients.map((ing, index) => ({\r\n        recipe_id: recipeId,\r\n        name: ing.name,\r\n        amount: ing.amount ?? null,\r\n        unit: ing.unit ?? null,\r\n        notes: ing.notes ?? null,\r\n        order_index: ing.order_index ?? index,\r\n      }))\r\n\r\n      const { error: ingredientsError } = await supabase\r\n        .from('recipe_ingredients')\r\n        .insert(ingredientsToInsert as never)\r\n\r\n      if (ingredientsError) {\r\n        console.error('Error creating ingredients:', ingredientsError)\r\n        // Don't fail the whole operation, but log the error\r\n      }\r\n    }\r\n\r\n    // Create initial version\r\n    await this.createVersion(recipeId, recipe as Recipe, 'Initial version')\r\n\r\n    // Fetch the complete recipe with ingredients\r\n    const fullRecipe = await this.getRecipe(recipeId)\r\n    if (!fullRecipe) {\r\n      throw new Error('Failed to fetch created recipe')\r\n    }\r\n\r\n    return fullRecipe\r\n  }\r\n\r\n  /**\r\n   * Update a recipe (creates a new version)\r\n   */\r\n  async updateRecipe(\r\n    id: string,\r\n    input: UpdateRecipeInput,\r\n    commitMessage?: string\r\n  ): Promise<RecipeWithIngredients> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get current recipe for version snapshot\r\n    const currentRecipe = await this.getRecipe(id)\r\n    if (!currentRecipe) {\r\n      throw new Error('Recipe not found')\r\n    }\r\n\r\n    const { ingredients, instructions, tags, ...recipeData } = input\r\n\r\n    // Update recipe\r\n    const updateData: Record<string, unknown> = {\r\n      ...recipeData,\r\n      updated_at: new Date().toISOString(),\r\n    }\r\n\r\n    if (instructions !== undefined) {\r\n      updateData.instructions = instructions as unknown as Record<string, unknown>\r\n    }\r\n\r\n    if (tags !== undefined) {\r\n      updateData.tags = tags\r\n    }\r\n\r\n    const { data: updatedRecipe, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .update(updateData as never)\r\n      .eq('id', id)\r\n      .select()\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      console.error('Error updating recipe:', recipeError)\r\n      throw new Error(`Failed to update recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    // Update ingredients if provided\r\n    if (ingredients !== undefined) {\r\n      // Delete existing ingredients\r\n      await supabase.from('recipe_ingredients').delete().eq('recipe_id', id)\r\n\r\n      // Insert new ingredients\r\n      if (ingredients.length > 0) {\r\n        const ingredientsToInsert = ingredients.map((ing, index) => ({\r\n          recipe_id: id,\r\n          name: ing.name,\r\n          amount: ing.amount ?? null,\r\n          unit: ing.unit ?? null,\r\n          notes: ing.notes ?? null,\r\n          order_index: ing.order_index ?? index,\r\n        }))\r\n\r\n        const { error: ingredientsError } = await supabase\r\n          .from('recipe_ingredients')\r\n          .insert(ingredientsToInsert as never)\r\n\r\n        if (ingredientsError) {\r\n          console.error('Error updating ingredients:', ingredientsError)\r\n          // Don't fail the whole operation\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create version snapshot\r\n    const versionMessage = commitMessage || 'Recipe updated'\r\n    await this.createVersion(id, updatedRecipe as Recipe, versionMessage)\r\n\r\n    // Fetch the complete updated recipe\r\n    const fullRecipe = await this.getRecipe(id)\r\n    if (!fullRecipe) {\r\n      throw new Error('Failed to fetch updated recipe')\r\n    }\r\n\r\n    return fullRecipe\r\n  }\r\n\r\n  /**\r\n   * Delete a recipe\r\n   */\r\n  async deleteRecipe(id: string): Promise<void> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Delete recipe (cascade will delete ingredients and versions)\r\n    const { error } = await supabase.from('recipes').delete().eq('id', id)\r\n\r\n    if (error) {\r\n      console.error('Error deleting recipe:', error)\r\n      throw new Error(`Failed to delete recipe: ${error.message}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get version history for a recipe\r\n   */\r\n  async getRecipeVersions(recipeId: string): Promise<RecipeVersion[]> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('recipe_versions')\r\n      .select('*')\r\n      .eq('recipe_id', recipeId)\r\n      .order('version_number', { ascending: false })\r\n\r\n    if (error) {\r\n      console.error('Error fetching versions:', error)\r\n      throw new Error(`Failed to fetch versions: ${error.message}`)\r\n    }\r\n\r\n    return (data || []) as RecipeVersion[]\r\n  }\r\n\r\n  /**\r\n   * Get a specific version\r\n   */\r\n  async getRecipeVersion(recipeId: string, versionId: string): Promise<RecipeVersion | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('recipe_versions')\r\n      .select('*')\r\n      .eq('id', versionId)\r\n      .eq('recipe_id', recipeId)\r\n      .single()\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        return null\r\n      }\r\n      console.error('Error fetching version:', error)\r\n      throw new Error(`Failed to fetch version: ${error.message}`)\r\n    }\r\n\r\n    return data as RecipeVersion\r\n  }\r\n\r\n  /**\r\n   * Restore a recipe to a specific version\r\n   */\r\n  async restoreRecipeVersion(recipeId: string, versionId: string): Promise<RecipeWithIngredients> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get the version\r\n    const version = await this.getRecipeVersion(recipeId, versionId)\r\n    if (!version) {\r\n      throw new Error('Version not found')\r\n    }\r\n\r\n    const snapshot = version.recipe_snapshot as Recipe\r\n\r\n    // Restore recipe from snapshot\r\n    const { data: updatedRecipe, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .update({\r\n        name: snapshot.name,\r\n        description: snapshot.description,\r\n        source: snapshot.source,\r\n        source_url: snapshot.source_url,\r\n        prep_time: snapshot.prep_time,\r\n        cook_time: snapshot.cook_time,\r\n        servings: snapshot.servings,\r\n        difficulty: snapshot.difficulty,\r\n        tags: snapshot.tags,\r\n        image_url: snapshot.image_url,\r\n        instructions: snapshot.instructions as unknown as Record<string, unknown>,\r\n        notes: snapshot.notes,\r\n        is_favorite: snapshot.is_favorite,\r\n        updated_at: new Date().toISOString(),\r\n      } as never)\r\n      .eq('id', recipeId)\r\n      .select()\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      console.error('Error restoring recipe:', recipeError)\r\n      throw new Error(`Failed to restore recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    // Restore ingredients from snapshot (if available in snapshot)\r\n    // Note: We need to check if ingredients are stored in the snapshot\r\n    // For now, we'll restore from the current recipe's ingredients structure\r\n    // In a full implementation, you might want to store ingredients in the snapshot too\r\n\r\n    // Create a new version documenting the restore\r\n    await this.createVersion(\r\n      recipeId,\r\n      updatedRecipe as Recipe,\r\n      `Restored to version ${version.version_number}`\r\n    )\r\n\r\n    // Fetch the complete restored recipe\r\n    const fullRecipe = await this.getRecipe(recipeId)\r\n    if (!fullRecipe) {\r\n      throw new Error('Failed to fetch restored recipe')\r\n    }\r\n\r\n    return fullRecipe\r\n  }\r\n\r\n  /**\r\n   * Create a version snapshot (internal method)\r\n   */\r\n  private async createVersion(\r\n    recipeId: string,\r\n    recipe: Recipe,\r\n    commitMessage: string\r\n  ): Promise<void> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get next version number\r\n    const { data: versionData } = await supabase.rpc('get_next_version_number', {\r\n      p_recipe_id: recipeId,\r\n    } as never)\r\n\r\n    const versionNumber = ((versionData as unknown) as number) || 1\r\n\r\n    // Get current ingredients to include in snapshot\r\n    const { data: ingredientsData } = await supabase\r\n      .from('recipe_ingredients')\r\n      .select('*')\r\n      .eq('recipe_id', recipeId)\r\n      .order('order_index', { ascending: true })\r\n\r\n    const ingredients = (ingredientsData || []) as RecipeIngredient[]\r\n\r\n    // Create snapshot with recipe and ingredients\r\n    const snapshot: RecipeWithIngredients = {\r\n      ...recipe,\r\n      ingredients,\r\n    }\r\n\r\n    // Insert version\r\n    const { error } = await supabase.from('recipe_versions').insert({\r\n      recipe_id: recipeId,\r\n      version_number: versionNumber,\r\n      commit_message: commitMessage,\r\n      recipe_snapshot: snapshot as unknown as Record<string, unknown>,\r\n    } as never)\r\n\r\n    if (error) {\r\n      console.error('Error creating version:', error)\r\n      // Don't throw - versioning is not critical for recipe updates\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const cookingService = new CookingService()\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/meal-planning.service.ts"],"sourcesContent":["/**\r\n * Meal Planning Service\r\n * Handles meal plan creation, management, and shopping list generation\r\n */\r\n\r\nimport { getSupabaseClientForOperation } from '@/lib/supabase/client'\r\nimport { cookingService } from './cooking.service'\r\nimport type {\r\n  MealPlan,\r\n  CreateMealPlanInput,\r\n  UpdateMealPlanInput,\r\n  ShoppingList,\r\n  ShoppingListItem,\r\n  RecipeWithIngredients,\r\n} from '@/lib/types/cooking.types'\r\n\r\nexport class MealPlanningService {\r\n  /**\r\n   * Get week start date (Monday) for a given date\r\n   */\r\n  private getWeekStart(date: Date): Date {\r\n    const d = new Date(date)\r\n    const day = d.getDay()\r\n    const diff = d.getDate() - day + (day === 0 ? -6 : 1) // Adjust when day is Sunday\r\n    return new Date(d.setDate(diff))\r\n  }\r\n\r\n  /**\r\n   * Get week number for a date\r\n   */\r\n  private getWeekNumber(date: Date): number {\r\n    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()))\r\n    const dayNum = d.getUTCDay() || 7\r\n    d.setUTCDate(d.getUTCDate() + 4 - dayNum)\r\n    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1))\r\n    return Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7)\r\n  }\r\n\r\n  /**\r\n   * Get meal plan for a specific week\r\n   */\r\n  async getMealPlan(weekStart?: Date): Promise<MealPlan | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const targetDate = weekStart || new Date()\r\n    const weekStartDate = this.getWeekStart(targetDate)\r\n    const year = weekStartDate.getFullYear()\r\n    const weekNumber = this.getWeekNumber(weekStartDate)\r\n\r\n    const { data, error } = await supabase\r\n      .from('meal_plans')\r\n      .select('*')\r\n      .eq('year', year)\r\n      .eq('week_number', weekNumber)\r\n      .single()\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        return null // Not found\r\n      }\r\n      console.error('Error fetching meal plan:', error)\r\n      throw new Error(`Failed to fetch meal plan: ${error.message}`)\r\n    }\r\n\r\n    return data as MealPlan\r\n  }\r\n\r\n  /**\r\n   * Save or update a meal plan\r\n   */\r\n  async saveMealPlan(input: CreateMealPlanInput | UpdateMealPlanInput): Promise<MealPlan> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const weekStartDate = new Date(input.week_start_date || new Date())\r\n    const year = weekStartDate.getFullYear()\r\n    const weekNumber = this.getWeekNumber(weekStartDate)\r\n\r\n    // Check if meal plan exists\r\n    const existing = await this.getMealPlan(weekStartDate)\r\n\r\n    if (existing) {\r\n      // Update existing\r\n      const { data, error } = await supabase\r\n        .from('meal_plans')\r\n        .update({\r\n          meals: input.meals as unknown as Record<string, unknown>,\r\n          notes: input.notes || null,\r\n          updated_at: new Date().toISOString(),\r\n        } as never)\r\n        .eq('id', existing.id)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) {\r\n        console.error('Error updating meal plan:', error)\r\n        throw new Error(`Failed to update meal plan: ${error.message}`)\r\n      }\r\n\r\n      return data as MealPlan\r\n    } else {\r\n      // Create new\r\n      const { data, error } = await supabase\r\n        .from('meal_plans')\r\n        .insert({\r\n          week_start_date: weekStartDate.toISOString().split('T')[0],\r\n          year,\r\n          week_number: weekNumber,\r\n          meals: input.meals as unknown as Record<string, unknown>,\r\n          notes: input.notes || null,\r\n        } as never)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) {\r\n        console.error('Error creating meal plan:', error)\r\n        throw new Error(`Failed to create meal plan: ${error.message}`)\r\n      }\r\n\r\n      return data as MealPlan\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a meal plan\r\n   */\r\n  async deleteMealPlan(id: string): Promise<void> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { error } = await supabase.from('meal_plans').delete().eq('id', id)\r\n\r\n    if (error) {\r\n      console.error('Error deleting meal plan:', error)\r\n      throw new Error(`Failed to delete meal plan: ${error.message}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate shopping list from meal plan\r\n   */\r\n  async generateShoppingList(mealPlanId: string): Promise<ShoppingList> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get meal plan\r\n    const mealPlan = await this.getMealPlanById(mealPlanId)\r\n    if (!mealPlan) {\r\n      throw new Error('Meal plan not found')\r\n    }\r\n\r\n    // Collect all recipe IDs from the meal plan\r\n    const recipeIds = new Set<string>()\r\n    const days: Array<keyof typeof mealPlan.meals> = [\r\n      'monday',\r\n      'tuesday',\r\n      'wednesday',\r\n      'thursday',\r\n      'friday',\r\n      'saturday',\r\n      'sunday',\r\n    ]\r\n\r\n    days.forEach((day) => {\r\n      const dayMeals = mealPlan.meals[day]\r\n      if (dayMeals) {\r\n        if (dayMeals.breakfast) recipeIds.add(dayMeals.breakfast)\r\n        if (dayMeals.lunch) recipeIds.add(dayMeals.lunch)\r\n        if (dayMeals.dinner) recipeIds.add(dayMeals.dinner)\r\n        if (dayMeals.snack) recipeIds.add(dayMeals.snack)\r\n      }\r\n    })\r\n\r\n    // Fetch all recipes with ingredients\r\n    const recipes: Array<{ recipe: RecipeWithIngredients; mealTypes: string[] }> = []\r\n\r\n    for (const recipeId of recipeIds) {\r\n      try {\r\n        const recipe = await cookingService.getRecipe(recipeId)\r\n        if (recipe) {\r\n          // Determine which meals use this recipe\r\n          const mealTypes: string[] = []\r\n          days.forEach((day) => {\r\n            const dayMeals = mealPlan.meals[day]\r\n            if (dayMeals) {\r\n              if (dayMeals.breakfast === recipeId) mealTypes.push(`${day} breakfast`)\r\n              if (dayMeals.lunch === recipeId) mealTypes.push(`${day} lunch`)\r\n              if (dayMeals.dinner === recipeId) mealTypes.push(`${day} dinner`)\r\n              if (dayMeals.snack === recipeId) mealTypes.push(`${day} snack`)\r\n            }\r\n          })\r\n          recipes.push({ recipe, mealTypes })\r\n        }\r\n      } catch (error) {\r\n        console.error(`Failed to fetch recipe ${recipeId}:`, error)\r\n      }\r\n    }\r\n\r\n    // Aggregate ingredients\r\n    const ingredientMap = new Map<string, ShoppingListItem>()\r\n\r\n    recipes.forEach(({ recipe, mealTypes }) => {\r\n      recipe.ingredients.forEach((ing) => {\r\n        const key = ing.name.toLowerCase().trim()\r\n        const existing = ingredientMap.get(key)\r\n\r\n        if (existing) {\r\n          // Merge amounts if same unit\r\n          if (existing.unit === ing.unit && ing.amount && existing.amount) {\r\n            existing.amount += ing.amount\r\n          } else if (ing.amount) {\r\n            // Different units or no existing amount - keep separate or combine\r\n            existing.recipes.push(recipe.name)\r\n          }\r\n        } else {\r\n          ingredientMap.set(key, {\r\n            ingredient: ing.name,\r\n            amount: ing.amount || 0,\r\n            unit: ing.unit || '',\r\n            recipes: [recipe.name],\r\n          })\r\n        }\r\n      })\r\n    })\r\n\r\n    const items: ShoppingListItem[] = Array.from(ingredientMap.values())\r\n\r\n    // Check if shopping list already exists\r\n    const { data: existingList } = await supabase\r\n      .from('shopping_lists')\r\n      .select('*')\r\n      .eq('meal_plan_id', mealPlanId)\r\n      .single()\r\n\r\n    const listData = {\r\n      meal_plan_id: mealPlanId,\r\n      items: items as unknown as Record<string, unknown>[],\r\n      status: 'draft' as const,\r\n      updated_at: new Date().toISOString(),\r\n    }\r\n\r\n    if (existingList) {\r\n      // Update existing\r\n      const { data, error } = await supabase\r\n        .from('shopping_lists')\r\n        .update(listData as never)\r\n        .eq('id', (existingList as { id: string }).id)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) {\r\n        console.error('Error updating shopping list:', error)\r\n        throw new Error(`Failed to update shopping list: ${error.message}`)\r\n      }\r\n\r\n      return {\r\n        ...(data as ShoppingList),\r\n        items,\r\n      }\r\n    } else {\r\n      // Create new\r\n      const { data, error } = await supabase\r\n        .from('shopping_lists')\r\n        .insert(listData as never)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) {\r\n        console.error('Error creating shopping list:', error)\r\n        throw new Error(`Failed to create shopping list: ${error.message}`)\r\n      }\r\n\r\n      return {\r\n        ...(data as ShoppingList),\r\n        items,\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get shopping list for a meal plan\r\n   */\r\n  async getShoppingList(mealPlanId: string): Promise<ShoppingList | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('shopping_lists')\r\n      .select('*')\r\n      .eq('meal_plan_id', mealPlanId)\r\n      .single()\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        return null\r\n      }\r\n      console.error('Error fetching shopping list:', error)\r\n      throw new Error(`Failed to fetch shopping list: ${error.message}`)\r\n    }\r\n\r\n    return {\r\n      ...(data as ShoppingList),\r\n      items: ((data as ShoppingList).items as unknown as ShoppingListItem[]) || [],\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update shopping list status\r\n   */\r\n  async updateShoppingListStatus(\r\n    shoppingListId: string,\r\n    status: 'draft' | 'active' | 'completed'\r\n  ): Promise<void> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { error } = await supabase\r\n      .from('shopping_lists')\r\n      .update({ status, updated_at: new Date().toISOString() } as never)\r\n      .eq('id', shoppingListId)\r\n\r\n    if (error) {\r\n      console.error('Error updating shopping list status:', error)\r\n      throw new Error(`Failed to update shopping list: ${error.message}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get meal plan by ID\r\n   */\r\n  async getMealPlanById(id: string): Promise<MealPlan | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { data, error } = await supabase.from('meal_plans').select('*').eq('id', id).single()\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        return null\r\n      }\r\n      throw new Error(`Failed to fetch meal plan: ${error.message}`)\r\n    }\r\n\r\n    return data as MealPlan\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const mealPlanningService = new MealPlanningService()\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 742, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/api/cors.ts"],"sourcesContent":["/**\r\n * CORS helper for API routes\r\n */\r\n\r\nimport { NextResponse } from 'next/server'\r\n\r\nexport const CORS_HEADERS = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n  'Access-Control-Allow-Headers': 'Content-Type',\r\n}\r\n\r\nexport function withCors<T>(response: NextResponse<T>): NextResponse<T> {\r\n  Object.entries(CORS_HEADERS).forEach(([key, value]) => {\r\n    response.headers.set(key, value)\r\n  })\r\n  return response\r\n}\r\n\r\nexport function corsOptionsResponse() {\r\n  return NextResponse.json({}, { headers: CORS_HEADERS })\r\n}\r\n\r\nexport function corsErrorResponse(error: string, status: number = 500) {\r\n  return withCors(\r\n    NextResponse.json(\r\n      {\r\n        success: false,\r\n        error,\r\n      },\r\n      { status }\r\n    )\r\n  )\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;CAEC,GAED;;AAEO,MAAM,eAAe;IAC1B,+BAA+B;IAC/B,gCAAgC;IAChC,gCAAgC;AAClC;AAEO,SAAS,SAAY,QAAyB;IACnD,OAAO,OAAO,CAAC,cAAc,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;QAChD,SAAS,OAAO,CAAC,GAAG,CAAC,KAAK;IAC5B;IACA,OAAO;AACT;AAEO,SAAS;IACd,OAAO,gJAAY,CAAC,IAAI,CAAC,CAAC,GAAG;QAAE,SAAS;IAAa;AACvD;AAEO,SAAS,kBAAkB,KAAa,EAAE,SAAiB,GAAG;IACnE,OAAO,SACL,gJAAY,CAAC,IAAI,CACf;QACE,SAAS;QACT;IACF,GACA;QAAE;IAAO;AAGf"}},
    {"offset": {"line": 784, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/app/api/cooking/meal-plans/route.ts"],"sourcesContent":["/**\r\n * Meal Plans API Routes\r\n * GET - Get meal plans (filter by week)\r\n * POST - Create/update meal plan\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server'\r\nimport { mealPlanningService } from '@/lib/services/meal-planning.service'\r\nimport type { CreateMealPlanInput } from '@/lib/types/cooking.types'\r\nimport { withCors, corsOptionsResponse } from '@/lib/api/cors'\r\n\r\n/**\r\n * GET /api/cooking/meal-plans\r\n * Get meal plan for a specific week\r\n * Query params:\r\n *   - week_start: ISO date string (optional, defaults to current week)\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n    const weekStartParam = searchParams.get('week_start')\r\n\r\n    const weekStart = weekStartParam ? new Date(weekStartParam) : undefined\r\n    const mealPlan = await mealPlanningService.getMealPlan(weekStart)\r\n\r\n    return withCors(\r\n      NextResponse.json({\r\n        success: true,\r\n        data: mealPlan,\r\n      })\r\n    )\r\n  } catch (error) {\r\n    console.error('Error fetching meal plan:', error)\r\n    return withCors(\r\n      NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n        },\r\n        { status: 500 }\r\n      )\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * POST /api/cooking/meal-plans\r\n * Create or update a meal plan\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n    const input: CreateMealPlanInput = body\r\n\r\n    if (!input.week_start_date) {\r\n      return withCors(\r\n        NextResponse.json(\r\n          {\r\n            success: false,\r\n            error: 'week_start_date is required',\r\n          },\r\n          { status: 400 }\r\n        )\r\n      )\r\n    }\r\n\r\n    const mealPlan = await mealPlanningService.saveMealPlan(input)\r\n\r\n    return withCors(\r\n      NextResponse.json({\r\n        success: true,\r\n        data: mealPlan,\r\n      })\r\n    )\r\n  } catch (error) {\r\n    console.error('Error saving meal plan:', error)\r\n    return withCors(\r\n      NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n        },\r\n        { status: 500 }\r\n      )\r\n    )\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;;;CAIC,GAED;AACA;AAEA;;;;AAQO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,iBAAiB,aAAa,GAAG,CAAC;QAExC,MAAM,YAAY,iBAAiB,IAAI,KAAK,kBAAkB;QAC9D,MAAM,WAAW,MAAM,uKAAmB,CAAC,WAAW,CAAC;QAEvD,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CAAC;YAChB,SAAS;YACT,MAAM;QACR;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CACf;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;QAAI;IAGpB;AACF;AAMO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,QAA6B;QAEnC,IAAI,CAAC,MAAM,eAAe,EAAE;YAC1B,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CACf;gBACE,SAAS;gBACT,OAAO;YACT,GACA;gBAAE,QAAQ;YAAI;QAGpB;QAEA,MAAM,WAAW,MAAM,uKAAmB,CAAC,YAAY,CAAC;QAExD,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CAAC;YAChB,SAAS;YACT,MAAM;QACR;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CACf;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;QAAI;IAGpB;AACF"}}]
}