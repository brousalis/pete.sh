{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/supabase/client.ts"],"sourcesContent":["/**\r\n * Supabase Client\r\n * Initializes and exports Supabase clients for the application\r\n */\r\n\r\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\r\nimport type { Database } from './types'\r\n\r\n// Environment variables\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\r\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY\r\n\r\n/**\r\n * Check if a string is a valid HTTP/HTTPS URL\r\n */\r\nfunction isValidUrl(urlString: string | undefined): boolean {\r\n  if (!urlString) return false\r\n  try {\r\n    const url = new URL(urlString)\r\n    return url.protocol === 'http:' || url.protocol === 'https:'\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Supabase is properly configured with valid credentials\r\n */\r\nexport function isSupabaseConfigured(): boolean {\r\n  // Check that URL exists and is a valid HTTP/HTTPS URL\r\n  if (!isValidUrl(supabaseUrl)) return false\r\n  // Check that anon key exists and isn't a placeholder\r\n  if (!supabaseAnonKey || supabaseAnonKey.includes('your-') || supabaseAnonKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n/**\r\n * Check if service role key is available and valid (for writes)\r\n */\r\nexport function hasServiceRoleKey(): boolean {\r\n  if (!supabaseServiceKey) return false\r\n  // Check it's not a placeholder\r\n  if (supabaseServiceKey.includes('your-') || supabaseServiceKey.length < 20) return false\r\n  return true\r\n}\r\n\r\n// Singleton instances\r\nlet anonClient: SupabaseClient<Database> | null = null\r\nlet serviceClient: SupabaseClient<Database> | null = null\r\n\r\n/**\r\n * Get the public Supabase client (anon key)\r\n * Use this for read operations and client-side queries\r\n * Returns null if not configured (call isSupabaseConfigured() first)\r\n */\r\nexport function getSupabaseClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!anonClient) {\r\n    try {\r\n      anonClient = createClient<Database>(supabaseUrl!, supabaseAnonKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return anonClient\r\n}\r\n\r\n/**\r\n * Get the service role Supabase client\r\n * Use this for server-side write operations (local mode only)\r\n * Returns null if not configured\r\n * WARNING: Never expose this in client-side code\r\n */\r\nexport function getSupabaseServiceClient(): SupabaseClient<Database> | null {\r\n  if (!isSupabaseConfigured()) {\r\n    return null\r\n  }\r\n\r\n  if (!hasServiceRoleKey()) {\r\n    return null\r\n  }\r\n\r\n  if (!serviceClient) {\r\n    try {\r\n      serviceClient = createClient<Database>(supabaseUrl!, supabaseServiceKey!, {\r\n        auth: {\r\n          persistSession: false,\r\n          autoRefreshToken: false,\r\n        },\r\n      })\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  return serviceClient\r\n}\r\n\r\n/**\r\n * Get the appropriate client based on operation type\r\n * - For reads: use anon client\r\n * - For writes: use service client (if available) or anon client\r\n * Returns null if Supabase is not configured\r\n */\r\nexport function getSupabaseClientForOperation(operation: 'read' | 'write'): SupabaseClient<Database> | null {\r\n  if (operation === 'write' && hasServiceRoleKey()) {\r\n    return getSupabaseServiceClient()\r\n  }\r\n  return getSupabaseClient()\r\n}\r\n\r\n// Export types for convenience\r\nexport type { Database }\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;CAGC,GAED;;AAGA,wBAAwB;AACxB,MAAM;AACN,MAAM;AACN,MAAM,qBAAqB,QAAQ,GAAG,CAAC,yBAAyB;AAEhE;;CAEC,GACD,SAAS,WAAW,SAA6B;IAC/C,IAAI,CAAC,WAAW,OAAO;IACvB,IAAI;QACF,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;IACtD,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAKO,SAAS;IACd,sDAAsD;IACtD,IAAI,CAAC,WAAW,cAAc,OAAO;IACrC,qDAAqD;IACrD,IAAI,CAAC,mBAAmB,gBAAgB,QAAQ,CAAC,YAAY,gBAAgB,MAAM,GAAG,IAAI,OAAO;IACjG,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,oBAAoB,OAAO;IAChC,+BAA+B;IAC/B,IAAI,mBAAmB,QAAQ,CAAC,YAAY,mBAAmB,MAAM,GAAG,IAAI,OAAO;IACnF,OAAO;AACT;AAEA,sBAAsB;AACtB,IAAI,aAA8C;AAClD,IAAI,gBAAiD;AAO9C,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,YAAY;QACf,IAAI;YACF,aAAa,IAAA,gMAAY,EAAW,aAAc,iBAAkB;gBAClE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS;IACd,IAAI,CAAC,wBAAwB;QAC3B,OAAO;IACT;IAEA,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,eAAe;QAClB,IAAI;YACF,gBAAgB,IAAA,gMAAY,EAAW,aAAc,oBAAqB;gBACxE,MAAM;oBACJ,gBAAgB;oBAChB,kBAAkB;gBACpB;YACF;QACF,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,8BAA8B,SAA2B;IACvE,IAAI,cAAc,WAAW,qBAAqB;QAChD,OAAO;IACT;IACA,OAAO;AACT"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/services/cooking.service.ts"],"sourcesContent":["/**\r\n * Cooking Service\r\n * Handles recipe storage, version history, and management\r\n */\r\n\r\nimport { getSupabaseClientForOperation } from '@/lib/supabase/client'\r\nimport type {\r\n  Recipe,\r\n  RecipeWithIngredients,\r\n  RecipeIngredient,\r\n  RecipeVersion,\r\n  RecipeFilters,\r\n  CreateRecipeInput,\r\n  UpdateRecipeInput,\r\n} from '@/lib/types/cooking.types'\r\n\r\nexport class CookingService {\r\n  /**\r\n   * Get recipes with optional filters\r\n   */\r\n  async getRecipes(filters?: RecipeFilters): Promise<Recipe[]> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    let query = supabase.from('recipes').select('*').order('created_at', { ascending: false })\r\n\r\n    if (filters?.search) {\r\n      query = query.ilike('name', `%${filters.search}%`)\r\n    }\r\n\r\n    if (filters?.source) {\r\n      query = query.eq('source', filters.source)\r\n    }\r\n\r\n    if (filters?.difficulty) {\r\n      query = query.eq('difficulty', filters.difficulty)\r\n    }\r\n\r\n    if (filters?.is_favorite !== undefined) {\r\n      query = query.eq('is_favorite', filters.is_favorite)\r\n    }\r\n\r\n    if (filters?.tags && filters.tags.length > 0) {\r\n      query = query.contains('tags', filters.tags)\r\n    }\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) {\r\n      console.error('Error fetching recipes:', error)\r\n      throw new Error(`Failed to fetch recipes: ${error.message}`)\r\n    }\r\n\r\n    return (data || []) as Recipe[]\r\n  }\r\n\r\n  /**\r\n   * Get a single recipe with ingredients\r\n   */\r\n  async getRecipe(id: string): Promise<RecipeWithIngredients | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get recipe\r\n    const { data: recipeData, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      if (recipeError.code === 'PGRST116') {\r\n        return null // Not found\r\n      }\r\n      console.error('Error fetching recipe:', recipeError)\r\n      throw new Error(`Failed to fetch recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    // Get ingredients\r\n    const { data: ingredientsData, error: ingredientsError } = await supabase\r\n      .from('recipe_ingredients')\r\n      .select('*')\r\n      .eq('recipe_id', id)\r\n      .order('order_index', { ascending: true })\r\n\r\n    if (ingredientsError) {\r\n      console.error('Error fetching ingredients:', ingredientsError)\r\n      throw new Error(`Failed to fetch ingredients: ${ingredientsError.message}`)\r\n    }\r\n\r\n    const recipe = recipeData as Recipe\r\n    const ingredients = (ingredientsData || []) as RecipeIngredient[]\r\n\r\n    return {\r\n      ...recipe,\r\n      ingredients,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new recipe\r\n   */\r\n  async createRecipe(input: CreateRecipeInput): Promise<RecipeWithIngredients> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const {\r\n      ingredients,\r\n      instructions = [],\r\n      tags = [],\r\n      is_favorite = false,\r\n      source = 'custom',\r\n      ...recipeData\r\n    } = input\r\n\r\n    // Insert recipe\r\n    const { data: recipe, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .insert({\r\n        ...recipeData,\r\n        instructions: instructions as unknown as Record<string, unknown>,\r\n        tags: tags || [],\r\n        is_favorite,\r\n        source,\r\n        updated_at: new Date().toISOString(),\r\n      } as never)\r\n      .select()\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      console.error('Error creating recipe:', recipeError)\r\n      throw new Error(`Failed to create recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    const recipeId = (recipe as Recipe).id\r\n\r\n    // Insert ingredients if provided\r\n    if (ingredients && ingredients.length > 0) {\r\n      const ingredientsToInsert = ingredients.map((ing, index) => ({\r\n        recipe_id: recipeId,\r\n        name: ing.name,\r\n        amount: ing.amount ?? null,\r\n        unit: ing.unit ?? null,\r\n        notes: ing.notes ?? null,\r\n        order_index: ing.order_index ?? index,\r\n      }))\r\n\r\n      const { error: ingredientsError } = await supabase\r\n        .from('recipe_ingredients')\r\n        .insert(ingredientsToInsert as never)\r\n\r\n      if (ingredientsError) {\r\n        console.error('Error creating ingredients:', ingredientsError)\r\n        // Don't fail the whole operation, but log the error\r\n      }\r\n    }\r\n\r\n    // Create initial version\r\n    await this.createVersion(recipeId, recipe as Recipe, 'Initial version')\r\n\r\n    // Fetch the complete recipe with ingredients\r\n    const fullRecipe = await this.getRecipe(recipeId)\r\n    if (!fullRecipe) {\r\n      throw new Error('Failed to fetch created recipe')\r\n    }\r\n\r\n    return fullRecipe\r\n  }\r\n\r\n  /**\r\n   * Update a recipe (creates a new version)\r\n   */\r\n  async updateRecipe(\r\n    id: string,\r\n    input: UpdateRecipeInput,\r\n    commitMessage?: string\r\n  ): Promise<RecipeWithIngredients> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get current recipe for version snapshot\r\n    const currentRecipe = await this.getRecipe(id)\r\n    if (!currentRecipe) {\r\n      throw new Error('Recipe not found')\r\n    }\r\n\r\n    const { ingredients, instructions, tags, ...recipeData } = input\r\n\r\n    // Update recipe\r\n    const updateData: Record<string, unknown> = {\r\n      ...recipeData,\r\n      updated_at: new Date().toISOString(),\r\n    }\r\n\r\n    if (instructions !== undefined) {\r\n      updateData.instructions = instructions as unknown as Record<string, unknown>\r\n    }\r\n\r\n    if (tags !== undefined) {\r\n      updateData.tags = tags\r\n    }\r\n\r\n    const { data: updatedRecipe, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .update(updateData as never)\r\n      .eq('id', id)\r\n      .select()\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      console.error('Error updating recipe:', recipeError)\r\n      throw new Error(`Failed to update recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    // Update ingredients if provided\r\n    if (ingredients !== undefined) {\r\n      // Delete existing ingredients\r\n      await supabase.from('recipe_ingredients').delete().eq('recipe_id', id)\r\n\r\n      // Insert new ingredients\r\n      if (ingredients.length > 0) {\r\n        const ingredientsToInsert = ingredients.map((ing, index) => ({\r\n          recipe_id: id,\r\n          name: ing.name,\r\n          amount: ing.amount ?? null,\r\n          unit: ing.unit ?? null,\r\n          notes: ing.notes ?? null,\r\n          order_index: ing.order_index ?? index,\r\n        }))\r\n\r\n        const { error: ingredientsError } = await supabase\r\n          .from('recipe_ingredients')\r\n          .insert(ingredientsToInsert as never)\r\n\r\n        if (ingredientsError) {\r\n          console.error('Error updating ingredients:', ingredientsError)\r\n          // Don't fail the whole operation\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create version snapshot\r\n    const versionMessage = commitMessage || 'Recipe updated'\r\n    await this.createVersion(id, updatedRecipe as Recipe, versionMessage)\r\n\r\n    // Fetch the complete updated recipe\r\n    const fullRecipe = await this.getRecipe(id)\r\n    if (!fullRecipe) {\r\n      throw new Error('Failed to fetch updated recipe')\r\n    }\r\n\r\n    return fullRecipe\r\n  }\r\n\r\n  /**\r\n   * Delete a recipe\r\n   */\r\n  async deleteRecipe(id: string): Promise<void> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Delete recipe (cascade will delete ingredients and versions)\r\n    const { error } = await supabase.from('recipes').delete().eq('id', id)\r\n\r\n    if (error) {\r\n      console.error('Error deleting recipe:', error)\r\n      throw new Error(`Failed to delete recipe: ${error.message}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get version history for a recipe\r\n   */\r\n  async getRecipeVersions(recipeId: string): Promise<RecipeVersion[]> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('recipe_versions')\r\n      .select('*')\r\n      .eq('recipe_id', recipeId)\r\n      .order('version_number', { ascending: false })\r\n\r\n    if (error) {\r\n      console.error('Error fetching versions:', error)\r\n      throw new Error(`Failed to fetch versions: ${error.message}`)\r\n    }\r\n\r\n    return (data || []) as RecipeVersion[]\r\n  }\r\n\r\n  /**\r\n   * Get a specific version\r\n   */\r\n  async getRecipeVersion(recipeId: string, versionId: string): Promise<RecipeVersion | null> {\r\n    const supabase = getSupabaseClientForOperation('read')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    const { data, error } = await supabase\r\n      .from('recipe_versions')\r\n      .select('*')\r\n      .eq('id', versionId)\r\n      .eq('recipe_id', recipeId)\r\n      .single()\r\n\r\n    if (error) {\r\n      if (error.code === 'PGRST116') {\r\n        return null\r\n      }\r\n      console.error('Error fetching version:', error)\r\n      throw new Error(`Failed to fetch version: ${error.message}`)\r\n    }\r\n\r\n    return data as RecipeVersion\r\n  }\r\n\r\n  /**\r\n   * Restore a recipe to a specific version\r\n   */\r\n  async restoreRecipeVersion(recipeId: string, versionId: string): Promise<RecipeWithIngredients> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get the version\r\n    const version = await this.getRecipeVersion(recipeId, versionId)\r\n    if (!version) {\r\n      throw new Error('Version not found')\r\n    }\r\n\r\n    const snapshot = version.recipe_snapshot as Recipe\r\n\r\n    // Restore recipe from snapshot\r\n    const { data: updatedRecipe, error: recipeError } = await supabase\r\n      .from('recipes')\r\n      .update({\r\n        name: snapshot.name,\r\n        description: snapshot.description,\r\n        source: snapshot.source,\r\n        source_url: snapshot.source_url,\r\n        prep_time: snapshot.prep_time,\r\n        cook_time: snapshot.cook_time,\r\n        servings: snapshot.servings,\r\n        difficulty: snapshot.difficulty,\r\n        tags: snapshot.tags,\r\n        image_url: snapshot.image_url,\r\n        instructions: snapshot.instructions as unknown as Record<string, unknown>,\r\n        notes: snapshot.notes,\r\n        is_favorite: snapshot.is_favorite,\r\n        updated_at: new Date().toISOString(),\r\n      } as never)\r\n      .eq('id', recipeId)\r\n      .select()\r\n      .single()\r\n\r\n    if (recipeError) {\r\n      console.error('Error restoring recipe:', recipeError)\r\n      throw new Error(`Failed to restore recipe: ${recipeError.message}`)\r\n    }\r\n\r\n    // Restore ingredients from snapshot (if available in snapshot)\r\n    // Note: We need to check if ingredients are stored in the snapshot\r\n    // For now, we'll restore from the current recipe's ingredients structure\r\n    // In a full implementation, you might want to store ingredients in the snapshot too\r\n\r\n    // Create a new version documenting the restore\r\n    await this.createVersion(\r\n      recipeId,\r\n      updatedRecipe as Recipe,\r\n      `Restored to version ${version.version_number}`\r\n    )\r\n\r\n    // Fetch the complete restored recipe\r\n    const fullRecipe = await this.getRecipe(recipeId)\r\n    if (!fullRecipe) {\r\n      throw new Error('Failed to fetch restored recipe')\r\n    }\r\n\r\n    return fullRecipe\r\n  }\r\n\r\n  /**\r\n   * Create a version snapshot (internal method)\r\n   */\r\n  private async createVersion(\r\n    recipeId: string,\r\n    recipe: Recipe,\r\n    commitMessage: string\r\n  ): Promise<void> {\r\n    const supabase = getSupabaseClientForOperation('write')\r\n    if (!supabase) {\r\n      throw new Error('Supabase not configured')\r\n    }\r\n\r\n    // Get next version number\r\n    const { data: versionData } = await supabase.rpc('get_next_version_number', {\r\n      p_recipe_id: recipeId,\r\n    } as never)\r\n\r\n    const versionNumber = ((versionData as unknown) as number) || 1\r\n\r\n    // Get current ingredients to include in snapshot\r\n    const { data: ingredientsData } = await supabase\r\n      .from('recipe_ingredients')\r\n      .select('*')\r\n      .eq('recipe_id', recipeId)\r\n      .order('order_index', { ascending: true })\r\n\r\n    const ingredients = (ingredientsData || []) as RecipeIngredient[]\r\n\r\n    // Create snapshot with recipe and ingredients\r\n    const snapshot: RecipeWithIngredients = {\r\n      ...recipe,\r\n      ingredients,\r\n    }\r\n\r\n    // Insert version\r\n    const { error } = await supabase.from('recipe_versions').insert({\r\n      recipe_id: recipeId,\r\n      version_number: versionNumber,\r\n      commit_message: commitMessage,\r\n      recipe_snapshot: snapshot as unknown as Record<string, unknown>,\r\n    } as never)\r\n\r\n    if (error) {\r\n      console.error('Error creating version:', error)\r\n      // Don't throw - versioning is not critical for recipe updates\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const cookingService = new CookingService()\r\n"],"names":[],"mappings":";;;;;;AAAA;;;CAGC,GAED;;AAWO,MAAM;IACX;;GAEC,GACD,MAAM,WAAW,OAAuB,EAAqB;QAC3D,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,QAAQ,SAAS,IAAI,CAAC,WAAW,MAAM,CAAC,KAAK,KAAK,CAAC,cAAc;YAAE,WAAW;QAAM;QAExF,IAAI,SAAS,QAAQ;YACnB,QAAQ,MAAM,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,MAAM,CAAC,CAAC,CAAC;QACnD;QAEA,IAAI,SAAS,QAAQ;YACnB,QAAQ,MAAM,EAAE,CAAC,UAAU,QAAQ,MAAM;QAC3C;QAEA,IAAI,SAAS,YAAY;YACvB,QAAQ,MAAM,EAAE,CAAC,cAAc,QAAQ,UAAU;QACnD;QAEA,IAAI,SAAS,gBAAgB,WAAW;YACtC,QAAQ,MAAM,EAAE,CAAC,eAAe,QAAQ,WAAW;QACrD;QAEA,IAAI,SAAS,QAAQ,QAAQ,IAAI,CAAC,MAAM,GAAG,GAAG;YAC5C,QAAQ,MAAM,QAAQ,CAAC,QAAQ,QAAQ,IAAI;QAC7C;QAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM;QAE9B,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,2BAA2B;YACzC,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,MAAM,OAAO,EAAE;QAC7D;QAEA,OAAQ,QAAQ,EAAE;IACpB;IAEA;;GAEC,GACD,MAAM,UAAU,EAAU,EAAyC;QACjE,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,aAAa;QACb,MAAM,EAAE,MAAM,UAAU,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACpD,IAAI,CAAC,WACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,IACT,MAAM;QAET,IAAI,aAAa;YACf,IAAI,YAAY,IAAI,KAAK,YAAY;gBACnC,OAAO,KAAK,YAAY;;YAC1B;YACA,QAAQ,KAAK,CAAC,0BAA0B;YACxC,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,YAAY,OAAO,EAAE;QAClE;QAEA,kBAAkB;QAClB,MAAM,EAAE,MAAM,eAAe,EAAE,OAAO,gBAAgB,EAAE,GAAG,MAAM,SAC9D,IAAI,CAAC,sBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAa,IAChB,KAAK,CAAC,eAAe;YAAE,WAAW;QAAK;QAE1C,IAAI,kBAAkB;YACpB,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,iBAAiB,OAAO,EAAE;QAC5E;QAEA,MAAM,SAAS;QACf,MAAM,cAAe,mBAAmB,EAAE;QAE1C,OAAO;YACL,GAAG,MAAM;YACT;QACF;IACF;IAEA;;GAEC,GACD,MAAM,aAAa,KAAwB,EAAkC;QAC3E,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,EACJ,WAAW,EACX,eAAe,EAAE,EACjB,OAAO,EAAE,EACT,cAAc,KAAK,EACnB,SAAS,QAAQ,EACjB,GAAG,YACJ,GAAG;QAEJ,gBAAgB;QAChB,MAAM,EAAE,MAAM,MAAM,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SAChD,IAAI,CAAC,WACL,MAAM,CAAC;YACN,GAAG,UAAU;YACb,cAAc;YACd,MAAM,QAAQ,EAAE;YAChB;YACA;YACA,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,MAAM,GACN,MAAM;QAET,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,0BAA0B;YACxC,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,YAAY,OAAO,EAAE;QACnE;QAEA,MAAM,WAAW,AAAC,OAAkB,EAAE;QAEtC,iCAAiC;QACjC,IAAI,eAAe,YAAY,MAAM,GAAG,GAAG;YACzC,MAAM,sBAAsB,YAAY,GAAG,CAAC,CAAC,KAAK,QAAU,CAAC;oBAC3D,WAAW;oBACX,MAAM,IAAI,IAAI;oBACd,QAAQ,IAAI,MAAM,IAAI;oBACtB,MAAM,IAAI,IAAI,IAAI;oBAClB,OAAO,IAAI,KAAK,IAAI;oBACpB,aAAa,IAAI,WAAW,IAAI;gBAClC,CAAC;YAED,MAAM,EAAE,OAAO,gBAAgB,EAAE,GAAG,MAAM,SACvC,IAAI,CAAC,sBACL,MAAM,CAAC;YAEV,IAAI,kBAAkB;gBACpB,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,oDAAoD;YACtD;QACF;QAEA,yBAAyB;QACzB,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,QAAkB;QAErD,6CAA6C;QAC7C,MAAM,aAAa,MAAM,IAAI,CAAC,SAAS,CAAC;QACxC,IAAI,CAAC,YAAY;YACf,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,aACJ,EAAU,EACV,KAAwB,EACxB,aAAsB,EACU;QAChC,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,0CAA0C;QAC1C,MAAM,gBAAgB,MAAM,IAAI,CAAC,SAAS,CAAC;QAC3C,IAAI,CAAC,eAAe;YAClB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,IAAI,EAAE,GAAG,YAAY,GAAG;QAE3D,gBAAgB;QAChB,MAAM,aAAsC;YAC1C,GAAG,UAAU;YACb,YAAY,IAAI,OAAO,WAAW;QACpC;QAEA,IAAI,iBAAiB,WAAW;YAC9B,WAAW,YAAY,GAAG;QAC5B;QAEA,IAAI,SAAS,WAAW;YACtB,WAAW,IAAI,GAAG;QACpB;QAEA,MAAM,EAAE,MAAM,aAAa,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACvD,IAAI,CAAC,WACL,MAAM,CAAC,YACP,EAAE,CAAC,MAAM,IACT,MAAM,GACN,MAAM;QAET,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,0BAA0B;YACxC,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,YAAY,OAAO,EAAE;QACnE;QAEA,iCAAiC;QACjC,IAAI,gBAAgB,WAAW;YAC7B,8BAA8B;YAC9B,MAAM,SAAS,IAAI,CAAC,sBAAsB,MAAM,GAAG,EAAE,CAAC,aAAa;YAEnE,yBAAyB;YACzB,IAAI,YAAY,MAAM,GAAG,GAAG;gBAC1B,MAAM,sBAAsB,YAAY,GAAG,CAAC,CAAC,KAAK,QAAU,CAAC;wBAC3D,WAAW;wBACX,MAAM,IAAI,IAAI;wBACd,QAAQ,IAAI,MAAM,IAAI;wBACtB,MAAM,IAAI,IAAI,IAAI;wBAClB,OAAO,IAAI,KAAK,IAAI;wBACpB,aAAa,IAAI,WAAW,IAAI;oBAClC,CAAC;gBAED,MAAM,EAAE,OAAO,gBAAgB,EAAE,GAAG,MAAM,SACvC,IAAI,CAAC,sBACL,MAAM,CAAC;gBAEV,IAAI,kBAAkB;oBACpB,QAAQ,KAAK,CAAC,+BAA+B;gBAC7C,iCAAiC;gBACnC;YACF;QACF;QAEA,0BAA0B;QAC1B,MAAM,iBAAiB,iBAAiB;QACxC,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,eAAyB;QAEtD,oCAAoC;QACpC,MAAM,aAAa,MAAM,IAAI,CAAC,SAAS,CAAC;QACxC,IAAI,CAAC,YAAY;YACf,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,aAAa,EAAU,EAAiB;QAC5C,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,+DAA+D;QAC/D,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,WAAW,MAAM,GAAG,EAAE,CAAC,MAAM;QAEnE,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,0BAA0B;YACxC,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,MAAM,OAAO,EAAE;QAC7D;IACF;IAEA;;GAEC,GACD,MAAM,kBAAkB,QAAgB,EAA4B;QAClE,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAa,UAChB,KAAK,CAAC,kBAAkB;YAAE,WAAW;QAAM;QAE9C,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,MAAM,OAAO,EAAE;QAC9D;QAEA,OAAQ,QAAQ,EAAE;IACpB;IAEA;;GAEC,GACD,MAAM,iBAAiB,QAAgB,EAAE,SAAiB,EAAiC;QACzF,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,SAC3B,IAAI,CAAC,mBACL,MAAM,CAAC,KACP,EAAE,CAAC,MAAM,WACT,EAAE,CAAC,aAAa,UAChB,MAAM;QAET,IAAI,OAAO;YACT,IAAI,MAAM,IAAI,KAAK,YAAY;gBAC7B,OAAO;YACT;YACA,QAAQ,KAAK,CAAC,2BAA2B;YACzC,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,MAAM,OAAO,EAAE;QAC7D;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,qBAAqB,QAAgB,EAAE,SAAiB,EAAkC;QAC9F,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,kBAAkB;QAClB,MAAM,UAAU,MAAM,IAAI,CAAC,gBAAgB,CAAC,UAAU;QACtD,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,WAAW,QAAQ,eAAe;QAExC,+BAA+B;QAC/B,MAAM,EAAE,MAAM,aAAa,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACvD,IAAI,CAAC,WACL,MAAM,CAAC;YACN,MAAM,SAAS,IAAI;YACnB,aAAa,SAAS,WAAW;YACjC,QAAQ,SAAS,MAAM;YACvB,YAAY,SAAS,UAAU;YAC/B,WAAW,SAAS,SAAS;YAC7B,WAAW,SAAS,SAAS;YAC7B,UAAU,SAAS,QAAQ;YAC3B,YAAY,SAAS,UAAU;YAC/B,MAAM,SAAS,IAAI;YACnB,WAAW,SAAS,SAAS;YAC7B,cAAc,SAAS,YAAY;YACnC,OAAO,SAAS,KAAK;YACrB,aAAa,SAAS,WAAW;YACjC,YAAY,IAAI,OAAO,WAAW;QACpC,GACC,EAAE,CAAC,MAAM,UACT,MAAM,GACN,MAAM;QAET,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,2BAA2B;YACzC,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,YAAY,OAAO,EAAE;QACpE;QAEA,+DAA+D;QAC/D,mEAAmE;QACnE,yEAAyE;QACzE,oFAAoF;QAEpF,+CAA+C;QAC/C,MAAM,IAAI,CAAC,aAAa,CACtB,UACA,eACA,CAAC,oBAAoB,EAAE,QAAQ,cAAc,EAAE;QAGjD,qCAAqC;QACrC,MAAM,aAAa,MAAM,IAAI,CAAC,SAAS,CAAC;QACxC,IAAI,CAAC,YAAY;YACf,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,MAAc,cACZ,QAAgB,EAChB,MAAc,EACd,aAAqB,EACN;QACf,MAAM,WAAW,IAAA,4JAA6B,EAAC;QAC/C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,0BAA0B;QAC1B,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,SAAS,GAAG,CAAC,2BAA2B;YAC1E,aAAa;QACf;QAEA,MAAM,gBAAgB,AAAE,eAAsC;QAE9D,iDAAiD;QACjD,MAAM,EAAE,MAAM,eAAe,EAAE,GAAG,MAAM,SACrC,IAAI,CAAC,sBACL,MAAM,CAAC,KACP,EAAE,CAAC,aAAa,UAChB,KAAK,CAAC,eAAe;YAAE,WAAW;QAAK;QAE1C,MAAM,cAAe,mBAAmB,EAAE;QAE1C,8CAA8C;QAC9C,MAAM,WAAkC;YACtC,GAAG,MAAM;YACT;QACF;QAEA,iBAAiB;QACjB,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,mBAAmB,MAAM,CAAC;YAC9D,WAAW;YACX,gBAAgB;YAChB,gBAAgB;YAChB,iBAAiB;QACnB;QAEA,IAAI,OAAO;YACT,QAAQ,KAAK,CAAC,2BAA2B;QACzC,8DAA8D;QAChE;IACF;AACF;AAGO,MAAM,iBAAiB,IAAI"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/lib/api/cors.ts"],"sourcesContent":["/**\r\n * CORS helper for API routes\r\n */\r\n\r\nimport { NextResponse } from 'next/server'\r\n\r\nexport const CORS_HEADERS = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n  'Access-Control-Allow-Headers': 'Content-Type',\r\n}\r\n\r\nexport function withCors<T>(response: NextResponse<T>): NextResponse<T> {\r\n  Object.entries(CORS_HEADERS).forEach(([key, value]) => {\r\n    response.headers.set(key, value)\r\n  })\r\n  return response\r\n}\r\n\r\nexport function corsOptionsResponse() {\r\n  return NextResponse.json({}, { headers: CORS_HEADERS })\r\n}\r\n\r\nexport function corsErrorResponse(error: string, status: number = 500) {\r\n  return withCors(\r\n    NextResponse.json(\r\n      {\r\n        success: false,\r\n        error,\r\n      },\r\n      { status }\r\n    )\r\n  )\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;CAEC,GAED;;AAEO,MAAM,eAAe;IAC1B,+BAA+B;IAC/B,gCAAgC;IAChC,gCAAgC;AAClC;AAEO,SAAS,SAAY,QAAyB;IACnD,OAAO,OAAO,CAAC,cAAc,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;QAChD,SAAS,OAAO,CAAC,GAAG,CAAC,KAAK;IAC5B;IACA,OAAO;AACT;AAEO,SAAS;IACd,OAAO,gJAAY,CAAC,IAAI,CAAC,CAAC,GAAG;QAAE,SAAS;IAAa;AACvD;AAEO,SAAS,kBAAkB,KAAa,EAAE,SAAiB,GAAG;IACnE,OAAO,SACL,gJAAY,CAAC,IAAI,CACf;QACE,SAAS;QACT;IACF,GACA;QAAE;IAAO;AAGf"}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":["file:///D:/documents/dev/petehome/apps/web/app/api/cooking/recipes/route.ts"],"sourcesContent":["/**\r\n * Recipe API Routes\r\n * GET - List recipes with filters\r\n * POST - Create new recipe\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server'\r\nimport { cookingService } from '@/lib/services/cooking.service'\r\nimport type { RecipeFilters, CreateRecipeInput } from '@/lib/types/cooking.types'\r\nimport { withCors, corsOptionsResponse } from '@/lib/api/cors'\r\n\r\n/**\r\n * GET /api/cooking/recipes\r\n * List recipes with optional filters\r\n * Query params:\r\n *   - search: Search by name\r\n *   - tags: Comma-separated tags\r\n *   - source: 'trader_joes' | 'custom' | 'imported'\r\n *   - difficulty: 'easy' | 'medium' | 'hard'\r\n *   - is_favorite: 'true' | 'false'\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n\r\n    const filters: RecipeFilters = {}\r\n\r\n    if (searchParams.get('search')) {\r\n      filters.search = searchParams.get('search') || undefined\r\n    }\r\n\r\n    if (searchParams.get('tags')) {\r\n      filters.tags = searchParams.get('tags')?.split(',').filter(Boolean)\r\n    }\r\n\r\n    if (searchParams.get('source')) {\r\n      filters.source = searchParams.get('source') as RecipeFilters['source']\r\n    }\r\n\r\n    if (searchParams.get('difficulty')) {\r\n      filters.difficulty = searchParams.get('difficulty') as RecipeFilters['difficulty']\r\n    }\r\n\r\n    if (searchParams.get('is_favorite')) {\r\n      filters.is_favorite = searchParams.get('is_favorite') === 'true'\r\n    }\r\n\r\n    const recipes = await cookingService.getRecipes(filters)\r\n\r\n    return withCors(\r\n      NextResponse.json({\r\n        success: true,\r\n        data: recipes,\r\n      })\r\n    )\r\n  } catch (error) {\r\n    console.error('Error fetching recipes:', error)\r\n    return withCors(\r\n      NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n        },\r\n        { status: 500 }\r\n      )\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * POST /api/cooking/recipes\r\n * Create a new recipe\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n    const input: CreateRecipeInput = body\r\n\r\n    // Validate required fields\r\n    if (!input.name || input.name.trim().length === 0) {\r\n      return withCors(\r\n        NextResponse.json(\r\n          {\r\n            success: false,\r\n            error: 'Recipe name is required',\r\n          },\r\n          { status: 400 }\r\n        )\r\n      )\r\n    }\r\n\r\n    const recipe = await cookingService.createRecipe(input)\r\n\r\n    return withCors(\r\n      NextResponse.json({\r\n        success: true,\r\n        data: recipe,\r\n      })\r\n    )\r\n  } catch (error) {\r\n    console.error('Error creating recipe:', error)\r\n    return withCors(\r\n      NextResponse.json(\r\n        {\r\n          success: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n        },\r\n        { status: 500 }\r\n      )\r\n    )\r\n  }\r\n}\r\n\r\nexport async function OPTIONS() {\r\n  return corsOptionsResponse()\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;CAIC,GAED;AACA;AAEA;;;;AAYO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAE5C,MAAM,UAAyB,CAAC;QAEhC,IAAI,aAAa,GAAG,CAAC,WAAW;YAC9B,QAAQ,MAAM,GAAG,aAAa,GAAG,CAAC,aAAa;QACjD;QAEA,IAAI,aAAa,GAAG,CAAC,SAAS;YAC5B,QAAQ,IAAI,GAAG,aAAa,GAAG,CAAC,SAAS,MAAM,KAAK,OAAO;QAC7D;QAEA,IAAI,aAAa,GAAG,CAAC,WAAW;YAC9B,QAAQ,MAAM,GAAG,aAAa,GAAG,CAAC;QACpC;QAEA,IAAI,aAAa,GAAG,CAAC,eAAe;YAClC,QAAQ,UAAU,GAAG,aAAa,GAAG,CAAC;QACxC;QAEA,IAAI,aAAa,GAAG,CAAC,gBAAgB;YACnC,QAAQ,WAAW,GAAG,aAAa,GAAG,CAAC,mBAAmB;QAC5D;QAEA,MAAM,UAAU,MAAM,yJAAc,CAAC,UAAU,CAAC;QAEhD,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CAAC;YAChB,SAAS;YACT,MAAM;QACR;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CACf;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;QAAI;IAGpB;AACF;AAMO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,QAA2B;QAEjC,2BAA2B;QAC3B,IAAI,CAAC,MAAM,IAAI,IAAI,MAAM,IAAI,CAAC,IAAI,GAAG,MAAM,KAAK,GAAG;YACjD,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CACf;gBACE,SAAS;gBACT,OAAO;YACT,GACA;gBAAE,QAAQ;YAAI;QAGpB;QAEA,MAAM,SAAS,MAAM,yJAAc,CAAC,YAAY,CAAC;QAEjD,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CAAC;YAChB,SAAS;YACT,MAAM;QACR;IAEJ,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,IAAA,gIAAQ,EACb,gJAAY,CAAC,IAAI,CACf;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;QAAI;IAGpB;AACF;AAEO,eAAe;IACpB,OAAO,IAAA,2IAAmB;AAC5B"}}]
}